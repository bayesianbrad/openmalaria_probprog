// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "pharmacology.h"

namespace scnXml
{
  // Pharmacology
  // 

  const Pharmacology::TreatmentsType& Pharmacology::
  getTreatments () const
  {
    return this->treatments_.get ();
  }

  Pharmacology::TreatmentsType& Pharmacology::
  getTreatments ()
  {
    return this->treatments_.get ();
  }

  void Pharmacology::
  setTreatments (const TreatmentsType& x)
  {
    this->treatments_.set (x);
  }

  void Pharmacology::
  setTreatments (::std::unique_ptr< TreatmentsType > x)
  {
    this->treatments_.set (std::move (x));
  }

  const Pharmacology::DrugsType& Pharmacology::
  getDrugs () const
  {
    return this->drugs_.get ();
  }

  Pharmacology::DrugsType& Pharmacology::
  getDrugs ()
  {
    return this->drugs_.get ();
  }

  void Pharmacology::
  setDrugs (const DrugsType& x)
  {
    this->drugs_.set (x);
  }

  void Pharmacology::
  setDrugs (::std::unique_ptr< DrugsType > x)
  {
    this->drugs_.set (std::move (x));
  }


  // PKPDSchedule
  // 

  const PKPDSchedule::MedicateSequence& PKPDSchedule::
  getMedicate () const
  {
    return this->medicate_;
  }

  PKPDSchedule::MedicateSequence& PKPDSchedule::
  getMedicate ()
  {
    return this->medicate_;
  }

  void PKPDSchedule::
  setMedicate (const MedicateSequence& s)
  {
    this->medicate_ = s;
  }

  const PKPDSchedule::NameType& PKPDSchedule::
  getName () const
  {
    return this->name_.get ();
  }

  PKPDSchedule::NameType& PKPDSchedule::
  getName ()
  {
    return this->name_.get ();
  }

  void PKPDSchedule::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void PKPDSchedule::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // PKPDMedication
  // 

  const PKPDMedication::DrugType& PKPDMedication::
  getDrug () const
  {
    return this->drug_.get ();
  }

  PKPDMedication::DrugType& PKPDMedication::
  getDrug ()
  {
    return this->drug_.get ();
  }

  void PKPDMedication::
  setDrug (const DrugType& x)
  {
    this->drug_.set (x);
  }

  void PKPDMedication::
  setDrug (::std::unique_ptr< DrugType > x)
  {
    this->drug_.set (std::move (x));
  }

  const PKPDMedication::MgType& PKPDMedication::
  getMg () const
  {
    return this->mg_.get ();
  }

  PKPDMedication::MgType& PKPDMedication::
  getMg ()
  {
    return this->mg_.get ();
  }

  void PKPDMedication::
  setMg (const MgType& x)
  {
    this->mg_.set (x);
  }

  const PKPDMedication::HourType& PKPDMedication::
  getHour () const
  {
    return this->hour_.get ();
  }

  PKPDMedication::HourType& PKPDMedication::
  getHour ()
  {
    return this->hour_.get ();
  }

  void PKPDMedication::
  setHour (const HourType& x)
  {
    this->hour_.set (x);
  }


  // PKPDDosages
  // 

  const PKPDDosages::AgeSequence& PKPDDosages::
  getAge () const
  {
    return this->age_;
  }

  PKPDDosages::AgeSequence& PKPDDosages::
  getAge ()
  {
    return this->age_;
  }

  void PKPDDosages::
  setAge (const AgeSequence& s)
  {
    this->age_ = s;
  }

  const PKPDDosages::BodymassSequence& PKPDDosages::
  getBodymass () const
  {
    return this->bodymass_;
  }

  PKPDDosages::BodymassSequence& PKPDDosages::
  getBodymass ()
  {
    return this->bodymass_;
  }

  void PKPDDosages::
  setBodymass (const BodymassSequence& s)
  {
    this->bodymass_ = s;
  }

  const PKPDDosages::MultiplyOptional& PKPDDosages::
  getMultiply () const
  {
    return this->multiply_;
  }

  PKPDDosages::MultiplyOptional& PKPDDosages::
  getMultiply ()
  {
    return this->multiply_;
  }

  void PKPDDosages::
  setMultiply (const MultiplyType& x)
  {
    this->multiply_.set (x);
  }

  void PKPDDosages::
  setMultiply (const MultiplyOptional& x)
  {
    this->multiply_ = x;
  }

  void PKPDDosages::
  setMultiply (::std::unique_ptr< MultiplyType > x)
  {
    this->multiply_.set (std::move (x));
  }

  const PKPDDosages::NameType& PKPDDosages::
  getName () const
  {
    return this->name_.get ();
  }

  PKPDDosages::NameType& PKPDDosages::
  getName ()
  {
    return this->name_.get ();
  }

  void PKPDDosages::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void PKPDDosages::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // PKPDDosageRange
  // 

  const PKPDDosageRange::LowerboundType& PKPDDosageRange::
  getLowerbound () const
  {
    return this->lowerbound_.get ();
  }

  PKPDDosageRange::LowerboundType& PKPDDosageRange::
  getLowerbound ()
  {
    return this->lowerbound_.get ();
  }

  void PKPDDosageRange::
  setLowerbound (const LowerboundType& x)
  {
    this->lowerbound_.set (x);
  }

  const PKPDDosageRange::Dose_multType& PKPDDosageRange::
  getDose_mult () const
  {
    return this->dose_mult_.get ();
  }

  PKPDDosageRange::Dose_multType& PKPDDosageRange::
  getDose_mult ()
  {
    return this->dose_mult_.get ();
  }

  void PKPDDosageRange::
  setDose_mult (const Dose_multType& x)
  {
    this->dose_mult_.set (x);
  }


  // PKPDDrug
  // 

  const PKPDDrug::PDType& PKPDDrug::
  getPD () const
  {
    return this->PD_.get ();
  }

  PKPDDrug::PDType& PKPDDrug::
  getPD ()
  {
    return this->PD_.get ();
  }

  void PKPDDrug::
  setPD (const PDType& x)
  {
    this->PD_.set (x);
  }

  void PKPDDrug::
  setPD (::std::unique_ptr< PDType > x)
  {
    this->PD_.set (std::move (x));
  }

  const PKPDDrug::PKType& PKPDDrug::
  getPK () const
  {
    return this->PK_.get ();
  }

  PKPDDrug::PKType& PKPDDrug::
  getPK ()
  {
    return this->PK_.get ();
  }

  void PKPDDrug::
  setPK (const PKType& x)
  {
    this->PK_.set (x);
  }

  void PKPDDrug::
  setPK (::std::unique_ptr< PKType > x)
  {
    this->PK_.set (std::move (x));
  }

  const PKPDDrug::AbbrevType& PKPDDrug::
  getAbbrev () const
  {
    return this->abbrev_.get ();
  }

  PKPDDrug::AbbrevType& PKPDDrug::
  getAbbrev ()
  {
    return this->abbrev_.get ();
  }

  void PKPDDrug::
  setAbbrev (const AbbrevType& x)
  {
    this->abbrev_.set (x);
  }

  void PKPDDrug::
  setAbbrev (::std::unique_ptr< AbbrevType > x)
  {
    this->abbrev_.set (std::move (x));
  }


  // Phenotype
  // 

  const Phenotype::RestrictionSequence& Phenotype::
  getRestriction () const
  {
    return this->restriction_;
  }

  Phenotype::RestrictionSequence& Phenotype::
  getRestriction ()
  {
    return this->restriction_;
  }

  void Phenotype::
  setRestriction (const RestrictionSequence& s)
  {
    this->restriction_ = s;
  }

  const Phenotype::Max_killing_rateType& Phenotype::
  getMax_killing_rate () const
  {
    return this->max_killing_rate_.get ();
  }

  Phenotype::Max_killing_rateType& Phenotype::
  getMax_killing_rate ()
  {
    return this->max_killing_rate_.get ();
  }

  void Phenotype::
  setMax_killing_rate (const Max_killing_rateType& x)
  {
    this->max_killing_rate_.set (x);
  }

  const Phenotype::IC50Type& Phenotype::
  getIC50 () const
  {
    return this->IC50_.get ();
  }

  Phenotype::IC50Type& Phenotype::
  getIC50 ()
  {
    return this->IC50_.get ();
  }

  void Phenotype::
  setIC50 (const IC50Type& x)
  {
    this->IC50_.set (x);
  }

  void Phenotype::
  setIC50 (::std::unique_ptr< IC50Type > x)
  {
    this->IC50_.set (std::move (x));
  }

  const Phenotype::SlopeType& Phenotype::
  getSlope () const
  {
    return this->slope_.get ();
  }

  Phenotype::SlopeType& Phenotype::
  getSlope ()
  {
    return this->slope_.get ();
  }

  void Phenotype::
  setSlope (const SlopeType& x)
  {
    this->slope_.set (x);
  }

  const Phenotype::NameOptional& Phenotype::
  getName () const
  {
    return this->name_;
  }

  Phenotype::NameOptional& Phenotype::
  getName ()
  {
    return this->name_;
  }

  void Phenotype::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Phenotype::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void Phenotype::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // Treatments
  // 

  const Treatments::ScheduleSequence& Treatments::
  getSchedule () const
  {
    return this->schedule_;
  }

  Treatments::ScheduleSequence& Treatments::
  getSchedule ()
  {
    return this->schedule_;
  }

  void Treatments::
  setSchedule (const ScheduleSequence& s)
  {
    this->schedule_ = s;
  }

  const Treatments::DosagesSequence& Treatments::
  getDosages () const
  {
    return this->dosages_;
  }

  Treatments::DosagesSequence& Treatments::
  getDosages ()
  {
    return this->dosages_;
  }

  void Treatments::
  setDosages (const DosagesSequence& s)
  {
    this->dosages_ = s;
  }


  // Drugs
  // 

  const Drugs::DrugSequence& Drugs::
  getDrug () const
  {
    return this->drug_;
  }

  Drugs::DrugSequence& Drugs::
  getDrug ()
  {
    return this->drug_;
  }

  void Drugs::
  setDrug (const DrugSequence& s)
  {
    this->drug_ = s;
  }


  // Multiply
  // 

  const Multiply::ByType& Multiply::
  getBy () const
  {
    return this->by_.get ();
  }

  Multiply::ByType& Multiply::
  getBy ()
  {
    return this->by_.get ();
  }

  void Multiply::
  setBy (const ByType& x)
  {
    this->by_.set (x);
  }

  void Multiply::
  setBy (::std::unique_ptr< ByType > x)
  {
    this->by_.set (std::move (x));
  }


  // PD
  // 

  const PD::PhenotypeSequence& PD::
  getPhenotype () const
  {
    return this->phenotype_;
  }

  PD::PhenotypeSequence& PD::
  getPhenotype ()
  {
    return this->phenotype_;
  }

  void PD::
  setPhenotype (const PhenotypeSequence& s)
  {
    this->phenotype_ = s;
  }

  const PD::LocusOptional& PD::
  getLocus () const
  {
    return this->locus_;
  }

  PD::LocusOptional& PD::
  getLocus ()
  {
    return this->locus_;
  }

  void PD::
  setLocus (const LocusType& x)
  {
    this->locus_.set (x);
  }

  void PD::
  setLocus (const LocusOptional& x)
  {
    this->locus_ = x;
  }

  void PD::
  setLocus (::std::unique_ptr< LocusType > x)
  {
    this->locus_.set (std::move (x));
  }


  // PK
  // 

  const PK::Negligible_concentrationType& PK::
  getNegligible_concentration () const
  {
    return this->negligible_concentration_.get ();
  }

  PK::Negligible_concentrationType& PK::
  getNegligible_concentration ()
  {
    return this->negligible_concentration_.get ();
  }

  void PK::
  setNegligible_concentration (const Negligible_concentrationType& x)
  {
    this->negligible_concentration_.set (x);
  }

  const PK::Half_lifeOptional& PK::
  getHalf_life () const
  {
    return this->half_life_;
  }

  PK::Half_lifeOptional& PK::
  getHalf_life ()
  {
    return this->half_life_;
  }

  void PK::
  setHalf_life (const Half_lifeType& x)
  {
    this->half_life_.set (x);
  }

  void PK::
  setHalf_life (const Half_lifeOptional& x)
  {
    this->half_life_ = x;
  }

  const PK::KOptional& PK::
  getK () const
  {
    return this->k_;
  }

  PK::KOptional& PK::
  getK ()
  {
    return this->k_;
  }

  void PK::
  setK (const KType& x)
  {
    this->k_.set (x);
  }

  void PK::
  setK (const KOptional& x)
  {
    this->k_ = x;
  }

  void PK::
  setK (::std::unique_ptr< KType > x)
  {
    this->k_.set (std::move (x));
  }

  const PK::M_exponentOptional& PK::
  getM_exponent () const
  {
    return this->m_exponent_;
  }

  PK::M_exponentOptional& PK::
  getM_exponent ()
  {
    return this->m_exponent_;
  }

  void PK::
  setM_exponent (const M_exponentType& x)
  {
    this->m_exponent_.set (x);
  }

  void PK::
  setM_exponent (const M_exponentOptional& x)
  {
    this->m_exponent_ = x;
  }

  const PK::K_aOptional& PK::
  getK_a () const
  {
    return this->k_a_;
  }

  PK::K_aOptional& PK::
  getK_a ()
  {
    return this->k_a_;
  }

  void PK::
  setK_a (const K_aType& x)
  {
    this->k_a_.set (x);
  }

  void PK::
  setK_a (const K_aOptional& x)
  {
    this->k_a_ = x;
  }

  void PK::
  setK_a (::std::unique_ptr< K_aType > x)
  {
    this->k_a_.set (std::move (x));
  }

  const PK::ConversionOptional& PK::
  getConversion () const
  {
    return this->conversion_;
  }

  PK::ConversionOptional& PK::
  getConversion ()
  {
    return this->conversion_;
  }

  void PK::
  setConversion (const ConversionType& x)
  {
    this->conversion_.set (x);
  }

  void PK::
  setConversion (const ConversionOptional& x)
  {
    this->conversion_ = x;
  }

  void PK::
  setConversion (::std::unique_ptr< ConversionType > x)
  {
    this->conversion_.set (std::move (x));
  }

  const PK::Vol_distType& PK::
  getVol_dist () const
  {
    return this->vol_dist_.get ();
  }

  PK::Vol_distType& PK::
  getVol_dist ()
  {
    return this->vol_dist_.get ();
  }

  void PK::
  setVol_dist (const Vol_distType& x)
  {
    this->vol_dist_.set (x);
  }

  void PK::
  setVol_dist (::std::unique_ptr< Vol_distType > x)
  {
    this->vol_dist_.set (std::move (x));
  }

  const PK::Compartment2Optional& PK::
  getCompartment2 () const
  {
    return this->compartment2_;
  }

  PK::Compartment2Optional& PK::
  getCompartment2 ()
  {
    return this->compartment2_;
  }

  void PK::
  setCompartment2 (const Compartment2Type& x)
  {
    this->compartment2_.set (x);
  }

  void PK::
  setCompartment2 (const Compartment2Optional& x)
  {
    this->compartment2_ = x;
  }

  void PK::
  setCompartment2 (::std::unique_ptr< Compartment2Type > x)
  {
    this->compartment2_.set (std::move (x));
  }

  const PK::Compartment3Optional& PK::
  getCompartment3 () const
  {
    return this->compartment3_;
  }

  PK::Compartment3Optional& PK::
  getCompartment3 ()
  {
    return this->compartment3_;
  }

  void PK::
  setCompartment3 (const Compartment3Type& x)
  {
    this->compartment3_.set (x);
  }

  void PK::
  setCompartment3 (const Compartment3Optional& x)
  {
    this->compartment3_ = x;
  }

  void PK::
  setCompartment3 (::std::unique_ptr< Compartment3Type > x)
  {
    this->compartment3_.set (std::move (x));
  }


  // Restriction
  // 

  const Restriction::OnLocusType& Restriction::
  getOnLocus () const
  {
    return this->onLocus_.get ();
  }

  Restriction::OnLocusType& Restriction::
  getOnLocus ()
  {
    return this->onLocus_.get ();
  }

  void Restriction::
  setOnLocus (const OnLocusType& x)
  {
    this->onLocus_.set (x);
  }

  void Restriction::
  setOnLocus (::std::unique_ptr< OnLocusType > x)
  {
    this->onLocus_.set (std::move (x));
  }

  const Restriction::ToAlleleType& Restriction::
  getToAllele () const
  {
    return this->toAllele_.get ();
  }

  Restriction::ToAlleleType& Restriction::
  getToAllele ()
  {
    return this->toAllele_.get ();
  }

  void Restriction::
  setToAllele (const ToAlleleType& x)
  {
    this->toAllele_.set (x);
  }

  void Restriction::
  setToAllele (::std::unique_ptr< ToAlleleType > x)
  {
    this->toAllele_.set (std::move (x));
  }


  // IC50
  // 

  const IC50::SigmaType& IC50::
  getSigma () const
  {
    return this->sigma_.get ();
  }

  IC50::SigmaType& IC50::
  getSigma ()
  {
    return this->sigma_.get ();
  }

  void IC50::
  setSigma (const SigmaType& x)
  {
    this->sigma_.set (x);
  }

  IC50::SigmaType IC50::
  getSigmaDefaultValue ()
  {
    return SigmaType (0.0);
  }


  // By
  // 

  By::
  By (Value v)
  : ::xml_schema::String (_xsd_By_literals_[v])
  {
  }

  By::
  By (const char* v)
  : ::xml_schema::String (v)
  {
  }

  By::
  By (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  By::
  By (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  By::
  By (const By& v,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  By& By::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_By_literals_[v]);

    return *this;
  }


  // Conversion
  // 

  const Conversion::MetaboliteType& Conversion::
  getMetabolite () const
  {
    return this->metabolite_.get ();
  }

  Conversion::MetaboliteType& Conversion::
  getMetabolite ()
  {
    return this->metabolite_.get ();
  }

  void Conversion::
  setMetabolite (const MetaboliteType& x)
  {
    this->metabolite_.set (x);
  }

  void Conversion::
  setMetabolite (::std::unique_ptr< MetaboliteType > x)
  {
    this->metabolite_.set (std::move (x));
  }

  const Conversion::RateType& Conversion::
  getRate () const
  {
    return this->rate_.get ();
  }

  Conversion::RateType& Conversion::
  getRate ()
  {
    return this->rate_.get ();
  }

  void Conversion::
  setRate (const RateType& x)
  {
    this->rate_.set (x);
  }

  void Conversion::
  setRate (::std::unique_ptr< RateType > x)
  {
    this->rate_.set (std::move (x));
  }

  const Conversion::MolRatioType& Conversion::
  getMolRatio () const
  {
    return this->molRatio_.get ();
  }

  Conversion::MolRatioType& Conversion::
  getMolRatio ()
  {
    return this->molRatio_.get ();
  }

  void Conversion::
  setMolRatio (const MolRatioType& x)
  {
    this->molRatio_.set (x);
  }


  // Vol_dist
  // 

  const Vol_dist::SigmaType& Vol_dist::
  getSigma () const
  {
    return this->sigma_.get ();
  }

  Vol_dist::SigmaType& Vol_dist::
  getSigma ()
  {
    return this->sigma_.get ();
  }

  void Vol_dist::
  setSigma (const SigmaType& x)
  {
    this->sigma_.set (x);
  }

  Vol_dist::SigmaType Vol_dist::
  getSigmaDefaultValue ()
  {
    return SigmaType (0.0);
  }


  // Compartment2
  // 

  const Compartment2::A12Type& Compartment2::
  getA12 () const
  {
    return this->a12_.get ();
  }

  Compartment2::A12Type& Compartment2::
  getA12 ()
  {
    return this->a12_.get ();
  }

  void Compartment2::
  setA12 (const A12Type& x)
  {
    this->a12_.set (x);
  }

  void Compartment2::
  setA12 (::std::unique_ptr< A12Type > x)
  {
    this->a12_.set (std::move (x));
  }

  const Compartment2::A21Type& Compartment2::
  getA21 () const
  {
    return this->a21_.get ();
  }

  Compartment2::A21Type& Compartment2::
  getA21 ()
  {
    return this->a21_.get ();
  }

  void Compartment2::
  setA21 (const A21Type& x)
  {
    this->a21_.set (x);
  }

  void Compartment2::
  setA21 (::std::unique_ptr< A21Type > x)
  {
    this->a21_.set (std::move (x));
  }


  // Compartment3
  // 

  const Compartment3::A13Type& Compartment3::
  getA13 () const
  {
    return this->a13_.get ();
  }

  Compartment3::A13Type& Compartment3::
  getA13 ()
  {
    return this->a13_.get ();
  }

  void Compartment3::
  setA13 (const A13Type& x)
  {
    this->a13_.set (x);
  }

  void Compartment3::
  setA13 (::std::unique_ptr< A13Type > x)
  {
    this->a13_.set (std::move (x));
  }

  const Compartment3::A31Type& Compartment3::
  getA31 () const
  {
    return this->a31_.get ();
  }

  Compartment3::A31Type& Compartment3::
  getA31 ()
  {
    return this->a31_.get ();
  }

  void Compartment3::
  setA31 (const A31Type& x)
  {
    this->a31_.set (x);
  }

  void Compartment3::
  setA31 (::std::unique_ptr< A31Type > x)
  {
    this->a31_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace scnXml
{
  // Pharmacology
  //

  Pharmacology::
  Pharmacology (const TreatmentsType& treatments,
                const DrugsType& drugs)
  : ::xml_schema::Type (),
    treatments_ (treatments, this),
    drugs_ (drugs, this)
  {
  }

  Pharmacology::
  Pharmacology (::std::unique_ptr< TreatmentsType > treatments,
                ::std::unique_ptr< DrugsType > drugs)
  : ::xml_schema::Type (),
    treatments_ (std::move (treatments), this),
    drugs_ (std::move (drugs), this)
  {
  }

  Pharmacology::
  Pharmacology (const Pharmacology& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    treatments_ (x.treatments_, f, this),
    drugs_ (x.drugs_, f, this)
  {
  }

  Pharmacology::
  Pharmacology (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    treatments_ (this),
    drugs_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Pharmacology::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // treatments
      //
      if (n.name () == "treatments" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TreatmentsType > r (
          TreatmentsTraits::create (i, f, this));

        if (!treatments_.present ())
        {
          this->treatments_.set (::std::move (r));
          continue;
        }
      }

      // drugs
      //
      if (n.name () == "drugs" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DrugsType > r (
          DrugsTraits::create (i, f, this));

        if (!drugs_.present ())
        {
          this->drugs_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!treatments_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "treatments",
        "");
    }

    if (!drugs_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "drugs",
        "");
    }
  }

  Pharmacology* Pharmacology::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Pharmacology (*this, f, c);
  }

  Pharmacology& Pharmacology::
  operator= (const Pharmacology& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->treatments_ = x.treatments_;
      this->drugs_ = x.drugs_;
    }

    return *this;
  }

  Pharmacology::
  ~Pharmacology ()
  {
  }

  // PKPDSchedule
  //

  PKPDSchedule::
  PKPDSchedule (const NameType& name)
  : ::xml_schema::Type (),
    medicate_ (this),
    name_ (name, this)
  {
  }

  PKPDSchedule::
  PKPDSchedule (const PKPDSchedule& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    medicate_ (x.medicate_, f, this),
    name_ (x.name_, f, this)
  {
  }

  PKPDSchedule::
  PKPDSchedule (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    medicate_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PKPDSchedule::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // medicate
      //
      if (n.name () == "medicate" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MedicateType > r (
          MedicateTraits::create (i, f, this));

        this->medicate_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  PKPDSchedule* PKPDSchedule::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PKPDSchedule (*this, f, c);
  }

  PKPDSchedule& PKPDSchedule::
  operator= (const PKPDSchedule& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->medicate_ = x.medicate_;
      this->name_ = x.name_;
    }

    return *this;
  }

  PKPDSchedule::
  ~PKPDSchedule ()
  {
  }

  // PKPDMedication
  //

  PKPDMedication::
  PKPDMedication (const DrugType& drug,
                  const MgType& mg,
                  const HourType& hour)
  : ::xml_schema::Type (),
    drug_ (drug, this),
    mg_ (mg, this),
    hour_ (hour, this)
  {
  }

  PKPDMedication::
  PKPDMedication (const PKPDMedication& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    drug_ (x.drug_, f, this),
    mg_ (x.mg_, f, this),
    hour_ (x.hour_, f, this)
  {
  }

  PKPDMedication::
  PKPDMedication (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    drug_ (this),
    mg_ (this),
    hour_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void PKPDMedication::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "drug" && n.namespace_ ().empty ())
      {
        this->drug_.set (DrugTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "mg" && n.namespace_ ().empty ())
      {
        this->mg_.set (MgTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "hour" && n.namespace_ ().empty ())
      {
        this->hour_.set (HourTraits::create (i, f, this));
        continue;
      }
    }

    if (!drug_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "drug",
        "");
    }

    if (!mg_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mg",
        "");
    }

    if (!hour_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "hour",
        "");
    }
  }

  PKPDMedication* PKPDMedication::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PKPDMedication (*this, f, c);
  }

  PKPDMedication& PKPDMedication::
  operator= (const PKPDMedication& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->drug_ = x.drug_;
      this->mg_ = x.mg_;
      this->hour_ = x.hour_;
    }

    return *this;
  }

  PKPDMedication::
  ~PKPDMedication ()
  {
  }

  // PKPDDosages
  //

  PKPDDosages::
  PKPDDosages (const NameType& name)
  : ::xml_schema::Type (),
    age_ (this),
    bodymass_ (this),
    multiply_ (this),
    name_ (name, this)
  {
  }

  PKPDDosages::
  PKPDDosages (const PKPDDosages& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    age_ (x.age_, f, this),
    bodymass_ (x.bodymass_, f, this),
    multiply_ (x.multiply_, f, this),
    name_ (x.name_, f, this)
  {
  }

  PKPDDosages::
  PKPDDosages (const xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    age_ (this),
    bodymass_ (this),
    multiply_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PKPDDosages::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // age
      //
      if (n.name () == "age" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AgeType > r (
          AgeTraits::create (i, f, this));

        this->age_.push_back (::std::move (r));
        continue;
      }

      // bodymass
      //
      if (n.name () == "bodymass" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< BodymassType > r (
          BodymassTraits::create (i, f, this));

        this->bodymass_.push_back (::std::move (r));
        continue;
      }

      // multiply
      //
      if (n.name () == "multiply" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MultiplyType > r (
          MultiplyTraits::create (i, f, this));

        if (!this->multiply_)
        {
          this->multiply_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  PKPDDosages* PKPDDosages::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PKPDDosages (*this, f, c);
  }

  PKPDDosages& PKPDDosages::
  operator= (const PKPDDosages& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->age_ = x.age_;
      this->bodymass_ = x.bodymass_;
      this->multiply_ = x.multiply_;
      this->name_ = x.name_;
    }

    return *this;
  }

  PKPDDosages::
  ~PKPDDosages ()
  {
  }

  // PKPDDosageRange
  //

  PKPDDosageRange::
  PKPDDosageRange (const LowerboundType& lowerbound,
                   const Dose_multType& dose_mult)
  : ::xml_schema::Type (),
    lowerbound_ (lowerbound, this),
    dose_mult_ (dose_mult, this)
  {
  }

  PKPDDosageRange::
  PKPDDosageRange (const PKPDDosageRange& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    lowerbound_ (x.lowerbound_, f, this),
    dose_mult_ (x.dose_mult_, f, this)
  {
  }

  PKPDDosageRange::
  PKPDDosageRange (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    lowerbound_ (this),
    dose_mult_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void PKPDDosageRange::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lowerbound" && n.namespace_ ().empty ())
      {
        this->lowerbound_.set (LowerboundTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "dose_mult" && n.namespace_ ().empty ())
      {
        this->dose_mult_.set (Dose_multTraits::create (i, f, this));
        continue;
      }
    }

    if (!lowerbound_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lowerbound",
        "");
    }

    if (!dose_mult_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "dose_mult",
        "");
    }
  }

  PKPDDosageRange* PKPDDosageRange::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PKPDDosageRange (*this, f, c);
  }

  PKPDDosageRange& PKPDDosageRange::
  operator= (const PKPDDosageRange& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->lowerbound_ = x.lowerbound_;
      this->dose_mult_ = x.dose_mult_;
    }

    return *this;
  }

  PKPDDosageRange::
  ~PKPDDosageRange ()
  {
  }

  // PKPDDrug
  //

  PKPDDrug::
  PKPDDrug (const PDType& PD,
            const PKType& PK,
            const AbbrevType& abbrev)
  : ::xml_schema::Type (),
    PD_ (PD, this),
    PK_ (PK, this),
    abbrev_ (abbrev, this)
  {
  }

  PKPDDrug::
  PKPDDrug (::std::unique_ptr< PDType > PD,
            ::std::unique_ptr< PKType > PK,
            const AbbrevType& abbrev)
  : ::xml_schema::Type (),
    PD_ (std::move (PD), this),
    PK_ (std::move (PK), this),
    abbrev_ (abbrev, this)
  {
  }

  PKPDDrug::
  PKPDDrug (const PKPDDrug& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    PD_ (x.PD_, f, this),
    PK_ (x.PK_, f, this),
    abbrev_ (x.abbrev_, f, this)
  {
  }

  PKPDDrug::
  PKPDDrug (const xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    PD_ (this),
    PK_ (this),
    abbrev_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PKPDDrug::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // PD
      //
      if (n.name () == "PD" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PDType > r (
          PDTraits::create (i, f, this));

        if (!PD_.present ())
        {
          this->PD_.set (::std::move (r));
          continue;
        }
      }

      // PK
      //
      if (n.name () == "PK" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PKType > r (
          PKTraits::create (i, f, this));

        if (!PK_.present ())
        {
          this->PK_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!PD_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PD",
        "");
    }

    if (!PK_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "PK",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "abbrev" && n.namespace_ ().empty ())
      {
        this->abbrev_.set (AbbrevTraits::create (i, f, this));
        continue;
      }
    }

    if (!abbrev_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "abbrev",
        "");
    }
  }

  PKPDDrug* PKPDDrug::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PKPDDrug (*this, f, c);
  }

  PKPDDrug& PKPDDrug::
  operator= (const PKPDDrug& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->PD_ = x.PD_;
      this->PK_ = x.PK_;
      this->abbrev_ = x.abbrev_;
    }

    return *this;
  }

  PKPDDrug::
  ~PKPDDrug ()
  {
  }

  // Phenotype
  //

  Phenotype::
  Phenotype (const Max_killing_rateType& max_killing_rate,
             const IC50Type& IC50,
             const SlopeType& slope)
  : ::xml_schema::Type (),
    restriction_ (this),
    max_killing_rate_ (max_killing_rate, this),
    IC50_ (IC50, this),
    slope_ (slope, this),
    name_ (this)
  {
  }

  Phenotype::
  Phenotype (const Max_killing_rateType& max_killing_rate,
             ::std::unique_ptr< IC50Type > IC50,
             const SlopeType& slope)
  : ::xml_schema::Type (),
    restriction_ (this),
    max_killing_rate_ (max_killing_rate, this),
    IC50_ (std::move (IC50), this),
    slope_ (slope, this),
    name_ (this)
  {
  }

  Phenotype::
  Phenotype (const Phenotype& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    restriction_ (x.restriction_, f, this),
    max_killing_rate_ (x.max_killing_rate_, f, this),
    IC50_ (x.IC50_, f, this),
    slope_ (x.slope_, f, this),
    name_ (x.name_, f, this)
  {
  }

  Phenotype::
  Phenotype (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    restriction_ (this),
    max_killing_rate_ (this),
    IC50_ (this),
    slope_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Phenotype::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // restriction
      //
      if (n.name () == "restriction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< RestrictionType > r (
          RestrictionTraits::create (i, f, this));

        this->restriction_.push_back (::std::move (r));
        continue;
      }

      // max_killing_rate
      //
      if (n.name () == "max_killing_rate" && n.namespace_ ().empty ())
      {
        if (!max_killing_rate_.present ())
        {
          this->max_killing_rate_.set (Max_killing_rateTraits::create (i, f, this));
          continue;
        }
      }

      // IC50
      //
      if (n.name () == "IC50" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< IC50Type > r (
          IC50Traits::create (i, f, this));

        if (!IC50_.present ())
        {
          this->IC50_.set (::std::move (r));
          continue;
        }
      }

      // slope
      //
      if (n.name () == "slope" && n.namespace_ ().empty ())
      {
        if (!slope_.present ())
        {
          this->slope_.set (SlopeTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!max_killing_rate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "max_killing_rate",
        "");
    }

    if (!IC50_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "IC50",
        "");
    }

    if (!slope_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "slope",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  Phenotype* Phenotype::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Phenotype (*this, f, c);
  }

  Phenotype& Phenotype::
  operator= (const Phenotype& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->restriction_ = x.restriction_;
      this->max_killing_rate_ = x.max_killing_rate_;
      this->IC50_ = x.IC50_;
      this->slope_ = x.slope_;
      this->name_ = x.name_;
    }

    return *this;
  }

  Phenotype::
  ~Phenotype ()
  {
  }

  // Treatments
  //

  Treatments::
  Treatments ()
  : ::xml_schema::Type (),
    schedule_ (this),
    dosages_ (this)
  {
  }

  Treatments::
  Treatments (const Treatments& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    schedule_ (x.schedule_, f, this),
    dosages_ (x.dosages_, f, this)
  {
  }

  Treatments::
  Treatments (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    schedule_ (this),
    dosages_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Treatments::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // schedule
      //
      if (n.name () == "schedule" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ScheduleType > r (
          ScheduleTraits::create (i, f, this));

        this->schedule_.push_back (::std::move (r));
        continue;
      }

      // dosages
      //
      if (n.name () == "dosages" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DosagesType > r (
          DosagesTraits::create (i, f, this));

        this->dosages_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Treatments* Treatments::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Treatments (*this, f, c);
  }

  Treatments& Treatments::
  operator= (const Treatments& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->schedule_ = x.schedule_;
      this->dosages_ = x.dosages_;
    }

    return *this;
  }

  Treatments::
  ~Treatments ()
  {
  }

  // Drugs
  //

  Drugs::
  Drugs ()
  : ::xml_schema::Type (),
    drug_ (this)
  {
  }

  Drugs::
  Drugs (const Drugs& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    drug_ (x.drug_, f, this)
  {
  }

  Drugs::
  Drugs (const xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    drug_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Drugs::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // drug
      //
      if (n.name () == "drug" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DrugType > r (
          DrugTraits::create (i, f, this));

        this->drug_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Drugs* Drugs::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Drugs (*this, f, c);
  }

  Drugs& Drugs::
  operator= (const Drugs& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->drug_ = x.drug_;
    }

    return *this;
  }

  Drugs::
  ~Drugs ()
  {
  }

  // Multiply
  //

  Multiply::
  Multiply (const ByType& by)
  : ::xml_schema::Type (),
    by_ (by, this)
  {
  }

  Multiply::
  Multiply (const Multiply& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    by_ (x.by_, f, this)
  {
  }

  Multiply::
  Multiply (const xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    by_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Multiply::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "by" && n.namespace_ ().empty ())
      {
        this->by_.set (ByTraits::create (i, f, this));
        continue;
      }
    }

    if (!by_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "by",
        "");
    }
  }

  Multiply* Multiply::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Multiply (*this, f, c);
  }

  Multiply& Multiply::
  operator= (const Multiply& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->by_ = x.by_;
    }

    return *this;
  }

  Multiply::
  ~Multiply ()
  {
  }

  // PD
  //

  PD::
  PD ()
  : ::xml_schema::Type (),
    phenotype_ (this),
    locus_ (this)
  {
  }

  PD::
  PD (const PD& x,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    phenotype_ (x.phenotype_, f, this),
    locus_ (x.locus_, f, this)
  {
  }

  PD::
  PD (const xercesc::DOMElement& e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    phenotype_ (this),
    locus_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void PD::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // phenotype
      //
      if (n.name () == "phenotype" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PhenotypeType > r (
          PhenotypeTraits::create (i, f, this));

        this->phenotype_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "locus" && n.namespace_ ().empty ())
      {
        this->locus_.set (LocusTraits::create (i, f, this));
        continue;
      }
    }
  }

  PD* PD::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PD (*this, f, c);
  }

  PD& PD::
  operator= (const PD& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->phenotype_ = x.phenotype_;
      this->locus_ = x.locus_;
    }

    return *this;
  }

  PD::
  ~PD ()
  {
  }

  // PK
  //

  PK::
  PK (const Negligible_concentrationType& negligible_concentration,
      const Vol_distType& vol_dist)
  : ::xml_schema::Type (),
    negligible_concentration_ (negligible_concentration, this),
    half_life_ (this),
    k_ (this),
    m_exponent_ (this),
    k_a_ (this),
    conversion_ (this),
    vol_dist_ (vol_dist, this),
    compartment2_ (this),
    compartment3_ (this)
  {
  }

  PK::
  PK (const Negligible_concentrationType& negligible_concentration,
      ::std::unique_ptr< Vol_distType > vol_dist)
  : ::xml_schema::Type (),
    negligible_concentration_ (negligible_concentration, this),
    half_life_ (this),
    k_ (this),
    m_exponent_ (this),
    k_a_ (this),
    conversion_ (this),
    vol_dist_ (std::move (vol_dist), this),
    compartment2_ (this),
    compartment3_ (this)
  {
  }

  PK::
  PK (const PK& x,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    negligible_concentration_ (x.negligible_concentration_, f, this),
    half_life_ (x.half_life_, f, this),
    k_ (x.k_, f, this),
    m_exponent_ (x.m_exponent_, f, this),
    k_a_ (x.k_a_, f, this),
    conversion_ (x.conversion_, f, this),
    vol_dist_ (x.vol_dist_, f, this),
    compartment2_ (x.compartment2_, f, this),
    compartment3_ (x.compartment3_, f, this)
  {
  }

  PK::
  PK (const xercesc::DOMElement& e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    negligible_concentration_ (this),
    half_life_ (this),
    k_ (this),
    m_exponent_ (this),
    k_a_ (this),
    conversion_ (this),
    vol_dist_ (this),
    compartment2_ (this),
    compartment3_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void PK::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // negligible_concentration
      //
      if (n.name () == "negligible_concentration" && n.namespace_ ().empty ())
      {
        if (!negligible_concentration_.present ())
        {
          this->negligible_concentration_.set (Negligible_concentrationTraits::create (i, f, this));
          continue;
        }
      }

      // half_life
      //
      if (n.name () == "half_life" && n.namespace_ ().empty ())
      {
        if (!this->half_life_)
        {
          this->half_life_.set (Half_lifeTraits::create (i, f, this));
          continue;
        }
      }

      // k
      //
      if (n.name () == "k" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< KType > r (
          KTraits::create (i, f, this));

        if (!this->k_)
        {
          this->k_.set (::std::move (r));
          continue;
        }
      }

      // m_exponent
      //
      if (n.name () == "m_exponent" && n.namespace_ ().empty ())
      {
        if (!this->m_exponent_)
        {
          this->m_exponent_.set (M_exponentTraits::create (i, f, this));
          continue;
        }
      }

      // k_a
      //
      if (n.name () == "k_a" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< K_aType > r (
          K_aTraits::create (i, f, this));

        if (!this->k_a_)
        {
          this->k_a_.set (::std::move (r));
          continue;
        }
      }

      // conversion
      //
      if (n.name () == "conversion" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ConversionType > r (
          ConversionTraits::create (i, f, this));

        if (!this->conversion_)
        {
          this->conversion_.set (::std::move (r));
          continue;
        }
      }

      // vol_dist
      //
      if (n.name () == "vol_dist" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< Vol_distType > r (
          Vol_distTraits::create (i, f, this));

        if (!vol_dist_.present ())
        {
          this->vol_dist_.set (::std::move (r));
          continue;
        }
      }

      // compartment2
      //
      if (n.name () == "compartment2" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< Compartment2Type > r (
          Compartment2Traits::create (i, f, this));

        if (!this->compartment2_)
        {
          this->compartment2_.set (::std::move (r));
          continue;
        }
      }

      // compartment3
      //
      if (n.name () == "compartment3" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< Compartment3Type > r (
          Compartment3Traits::create (i, f, this));

        if (!this->compartment3_)
        {
          this->compartment3_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!negligible_concentration_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "negligible_concentration",
        "");
    }

    if (!vol_dist_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "vol_dist",
        "");
    }
  }

  PK* PK::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class PK (*this, f, c);
  }

  PK& PK::
  operator= (const PK& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->negligible_concentration_ = x.negligible_concentration_;
      this->half_life_ = x.half_life_;
      this->k_ = x.k_;
      this->m_exponent_ = x.m_exponent_;
      this->k_a_ = x.k_a_;
      this->conversion_ = x.conversion_;
      this->vol_dist_ = x.vol_dist_;
      this->compartment2_ = x.compartment2_;
      this->compartment3_ = x.compartment3_;
    }

    return *this;
  }

  PK::
  ~PK ()
  {
  }

  // Restriction
  //

  Restriction::
  Restriction (const OnLocusType& onLocus,
               const ToAlleleType& toAllele)
  : ::xml_schema::Type (),
    onLocus_ (onLocus, this),
    toAllele_ (toAllele, this)
  {
  }

  Restriction::
  Restriction (const Restriction& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    onLocus_ (x.onLocus_, f, this),
    toAllele_ (x.toAllele_, f, this)
  {
  }

  Restriction::
  Restriction (const xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    onLocus_ (this),
    toAllele_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Restriction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "onLocus" && n.namespace_ ().empty ())
      {
        this->onLocus_.set (OnLocusTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "toAllele" && n.namespace_ ().empty ())
      {
        this->toAllele_.set (ToAlleleTraits::create (i, f, this));
        continue;
      }
    }

    if (!onLocus_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "onLocus",
        "");
    }

    if (!toAllele_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "toAllele",
        "");
    }
  }

  Restriction* Restriction::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Restriction (*this, f, c);
  }

  Restriction& Restriction::
  operator= (const Restriction& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->onLocus_ = x.onLocus_;
      this->toAllele_ = x.toAllele_;
    }

    return *this;
  }

  Restriction::
  ~Restriction ()
  {
  }

  // IC50
  //

  IC50::
  IC50 (const ::xml_schema::Double& _xsd_Double_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (_xsd_Double_base),
    sigma_ (getSigmaDefaultValue (), this)
  {
  }

  IC50::
  IC50 (const IC50& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (x, f, c),
    sigma_ (x.sigma_, f, this)
  {
  }

  IC50::
  IC50 (const xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (e, f | ::xml_schema::Flags::base, c),
    sigma_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void IC50::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sigma" && n.namespace_ ().empty ())
      {
        this->sigma_.set (SigmaTraits::create (i, f, this));
        continue;
      }
    }

    if (!sigma_.present ())
    {
      this->sigma_.set (getSigmaDefaultValue ());
    }
  }

  IC50* IC50::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IC50 (*this, f, c);
  }

  IC50& IC50::
  operator= (const IC50& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >& > (*this) = x;
      this->sigma_ = x.sigma_;
    }

    return *this;
  }

  IC50::
  ~IC50 ()
  {
  }

  // By
  //

  By::
  By (const xercesc::DOMElement& e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_By_convert ();
  }

  By::
  By (const xercesc::DOMAttr& a,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_By_convert ();
  }

  By::
  By (const ::std::string& s,
      const xercesc::DOMElement* e,
      ::xml_schema::Flags f,
      ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_By_convert ();
  }

  By* By::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class By (*this, f, c);
  }

  By::Value By::
  _xsd_By_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_By_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_By_indexes_,
                      _xsd_By_indexes_ + 1,
                      *this,
                      c));

    if (i == _xsd_By_indexes_ + 1 || _xsd_By_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const By::
  _xsd_By_literals_[1] =
  {
    "kg"
  };

  const By::Value By::
  _xsd_By_indexes_[1] =
  {
    ::scnXml::By::kg
  };

  // Conversion
  //

  Conversion::
  Conversion (const MetaboliteType& metabolite,
              const RateType& rate,
              const MolRatioType& molRatio)
  : ::xml_schema::Type (),
    metabolite_ (metabolite, this),
    rate_ (rate, this),
    molRatio_ (molRatio, this)
  {
  }

  Conversion::
  Conversion (const MetaboliteType& metabolite,
              ::std::unique_ptr< RateType > rate,
              const MolRatioType& molRatio)
  : ::xml_schema::Type (),
    metabolite_ (metabolite, this),
    rate_ (std::move (rate), this),
    molRatio_ (molRatio, this)
  {
  }

  Conversion::
  Conversion (const Conversion& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    metabolite_ (x.metabolite_, f, this),
    rate_ (x.rate_, f, this),
    molRatio_ (x.molRatio_, f, this)
  {
  }

  Conversion::
  Conversion (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    metabolite_ (this),
    rate_ (this),
    molRatio_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Conversion::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // metabolite
      //
      if (n.name () == "metabolite" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MetaboliteType > r (
          MetaboliteTraits::create (i, f, this));

        if (!metabolite_.present ())
        {
          this->metabolite_.set (::std::move (r));
          continue;
        }
      }

      // rate
      //
      if (n.name () == "rate" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< RateType > r (
          RateTraits::create (i, f, this));

        if (!rate_.present ())
        {
          this->rate_.set (::std::move (r));
          continue;
        }
      }

      // molRatio
      //
      if (n.name () == "molRatio" && n.namespace_ ().empty ())
      {
        if (!molRatio_.present ())
        {
          this->molRatio_.set (MolRatioTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!metabolite_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "metabolite",
        "");
    }

    if (!rate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "rate",
        "");
    }

    if (!molRatio_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "molRatio",
        "");
    }
  }

  Conversion* Conversion::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Conversion (*this, f, c);
  }

  Conversion& Conversion::
  operator= (const Conversion& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->metabolite_ = x.metabolite_;
      this->rate_ = x.rate_;
      this->molRatio_ = x.molRatio_;
    }

    return *this;
  }

  Conversion::
  ~Conversion ()
  {
  }

  // Vol_dist
  //

  Vol_dist::
  Vol_dist (const ::xml_schema::Double& _xsd_Double_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (_xsd_Double_base),
    sigma_ (getSigmaDefaultValue (), this)
  {
  }

  Vol_dist::
  Vol_dist (const Vol_dist& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (x, f, c),
    sigma_ (x.sigma_, f, this)
  {
  }

  Vol_dist::
  Vol_dist (const xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (e, f | ::xml_schema::Flags::base, c),
    sigma_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Vol_dist::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "sigma" && n.namespace_ ().empty ())
      {
        this->sigma_.set (SigmaTraits::create (i, f, this));
        continue;
      }
    }

    if (!sigma_.present ())
    {
      this->sigma_.set (getSigmaDefaultValue ());
    }
  }

  Vol_dist* Vol_dist::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Vol_dist (*this, f, c);
  }

  Vol_dist& Vol_dist::
  operator= (const Vol_dist& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >& > (*this) = x;
      this->sigma_ = x.sigma_;
    }

    return *this;
  }

  Vol_dist::
  ~Vol_dist ()
  {
  }

  // Compartment2
  //

  Compartment2::
  Compartment2 (const A12Type& a12,
                const A21Type& a21)
  : ::xml_schema::Type (),
    a12_ (a12, this),
    a21_ (a21, this)
  {
  }

  Compartment2::
  Compartment2 (::std::unique_ptr< A12Type > a12,
                ::std::unique_ptr< A21Type > a21)
  : ::xml_schema::Type (),
    a12_ (std::move (a12), this),
    a21_ (std::move (a21), this)
  {
  }

  Compartment2::
  Compartment2 (const Compartment2& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    a12_ (x.a12_, f, this),
    a21_ (x.a21_, f, this)
  {
  }

  Compartment2::
  Compartment2 (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    a12_ (this),
    a21_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Compartment2::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // a12
      //
      if (n.name () == "a12" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< A12Type > r (
          A12Traits::create (i, f, this));

        if (!a12_.present ())
        {
          this->a12_.set (::std::move (r));
          continue;
        }
      }

      // a21
      //
      if (n.name () == "a21" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< A21Type > r (
          A21Traits::create (i, f, this));

        if (!a21_.present ())
        {
          this->a21_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!a12_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "a12",
        "");
    }

    if (!a21_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "a21",
        "");
    }
  }

  Compartment2* Compartment2::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Compartment2 (*this, f, c);
  }

  Compartment2& Compartment2::
  operator= (const Compartment2& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->a12_ = x.a12_;
      this->a21_ = x.a21_;
    }

    return *this;
  }

  Compartment2::
  ~Compartment2 ()
  {
  }

  // Compartment3
  //

  Compartment3::
  Compartment3 (const A13Type& a13,
                const A31Type& a31)
  : ::xml_schema::Type (),
    a13_ (a13, this),
    a31_ (a31, this)
  {
  }

  Compartment3::
  Compartment3 (::std::unique_ptr< A13Type > a13,
                ::std::unique_ptr< A31Type > a31)
  : ::xml_schema::Type (),
    a13_ (std::move (a13), this),
    a31_ (std::move (a31), this)
  {
  }

  Compartment3::
  Compartment3 (const Compartment3& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    a13_ (x.a13_, f, this),
    a31_ (x.a31_, f, this)
  {
  }

  Compartment3::
  Compartment3 (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    a13_ (this),
    a31_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Compartment3::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // a13
      //
      if (n.name () == "a13" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< A13Type > r (
          A13Traits::create (i, f, this));

        if (!a13_.present ())
        {
          this->a13_.set (::std::move (r));
          continue;
        }
      }

      // a31
      //
      if (n.name () == "a31" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< A31Type > r (
          A31Traits::create (i, f, this));

        if (!a31_.present ())
        {
          this->a31_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!a13_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "a13",
        "");
    }

    if (!a31_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "a31",
        "");
    }
  }

  Compartment3* Compartment3::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Compartment3 (*this, f, c);
  }

  Compartment3& Compartment3::
  operator= (const Compartment3& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->a13_ = x.a13_;
      this->a31_ = x.a31_;
    }

    return *this;
  }

  Compartment3::
  ~Compartment3 ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace scnXml
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


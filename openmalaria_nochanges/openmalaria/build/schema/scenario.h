// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from scenario.xsd.
 */

#ifndef CXX_CODE_OPENMALARIA_SCHEMA_SCENARIO_H
#define CXX_CODE_OPENMALARIA_SCHEMA_SCENARIO_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type Type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type Container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char Byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char UnsignedByte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short Short;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short UnsignedShort;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int Int;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int UnsignedInt;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long Long;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long UnsignedLong;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long Integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long NonPositiveInteger;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long NonNegativeInteger;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long PositiveInteger;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long NegativeInteger;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool Boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float Float;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double Double;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double Decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, Token > Name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, Token > Language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > Buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone TimeZone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags Flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity Severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > Error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > Exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > Bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > Parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace scnXml
{
  class Parameter;
  class Parameters;
  class Human;
  class Vivax;
  class HypnozoiteRelease;
  class HypnozoiteReleaseDistribution;
  class ClinicalEvents;
  class ProbVivaxEvent;
  class ParasiteGenetics;
  class ParasiteGenotype;
  class ParasiteLocus;
  class ParasiteAllele;
  class Diagnostics;
  class Diagnostic;
  class Scenario;
  class Weight;
  class BloodStageLengthDays;
  class NumberHypnozoites;
  class SamplingMode;
  class Deterministic;
  class Stochastic;
  class Units;
  class Model;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "demography.h"

#include "monitoring.h"

#include "interventions.h"

#include "healthSystem.h"

#include "pharmacology.h"

/**
 * @brief C++ namespace for the %http://openmalaria.org/schema/scenario_39
 * schema namespace.
 */
namespace scnXml
{
  /**
   * @brief Class corresponding to the %Parameter schema type.
   *
   * @nosubgrouping
   */
  class Parameter: public ::xml_schema::Type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * Name of parameter
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name number
     *
     * @brief Accessor and modifier functions for the %number
     * required attribute.
     *
     * Reference number of input parameter
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int NumberType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NumberType, char > NumberTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NumberType&
    getNumber () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NumberType&
    getNumber ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setNumber (const NumberType& x);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     *
     * Parameter value
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double ValueType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char, ::xsd::cxx::tree::schema_type::double_ > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValue (const ValueType& x);

    //@}

    /**
     * @name include
     *
     * @brief Accessor and modifier functions for the %include
     * optional attribute.
     *
     * True if parameter is to be sampled in optimization
     * runs. Not used in simulator app.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean IncludeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IncludeType > IncludeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IncludeType, char > IncludeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IncludeOptional&
    getInclude () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    IncludeOptional&
    getInclude ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInclude (const IncludeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setInclude (const IncludeOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Parameter (const NumberType&,
               const ValueType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Parameter (const xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Parameter (const Parameter& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Parameter*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Parameter&
    operator= (const Parameter& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Parameter ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NameOptional name_;
    ::xsd::cxx::tree::one< NumberType > number_;
    ::xsd::cxx::tree::one< ValueType > value_;
    IncludeOptional include_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Parameters schema type.
   *
   * @nosubgrouping
   */
  class Parameters: public ::xml_schema::Type
  {
    public:
    /**
     * @name parameter
     *
     * @brief Accessor and modifier functions for the %parameter
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Parameter ParameterType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ParameterType > ParameterSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< ParameterType >::iterator ParameterIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< ParameterType >::const_iterator ParameterConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParameterType, char > ParameterTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ParameterSequence&
    getParameter () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ParameterSequence&
    getParameter ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setParameter (const ParameterSequence& s);

    //@}

    /**
     * @name interval
     *
     * @brief Accessor and modifier functions for the %interval
     * required attribute.
     *
     * Simulation step
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int IntervalType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IntervalType, char > IntervalTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IntervalType&
    getInterval () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IntervalType&
    getInterval ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInterval (const IntervalType& x);

    //@}

    /**
     * @name iseed
     *
     * @brief Accessor and modifier functions for the %iseed
     * required attribute.
     *
     * Seed for RNG
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int IseedType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IseedType, char > IseedTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IseedType&
    getIseed () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IseedType&
    getIseed ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setIseed (const IseedType& x);

    //@}

    /**
     * @name latentp
     *
     * @brief Accessor and modifier functions for the %latentp
     * required attribute.
     *
     * Pre-erythrocytic latent period
     * 
     * Can be specified in steps (e.g. 3t) or days (e.g. 15d).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String LatentpType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LatentpType, char > LatentpTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const LatentpType&
    getLatentp () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    LatentpType&
    getLatentp ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLatentp (const LatentpType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLatentp (::std::unique_ptr< LatentpType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Parameters (const IntervalType&,
                const IseedType&,
                const LatentpType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Parameters (const xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Parameters (const Parameters& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Parameters*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Parameters&
    operator= (const Parameters& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Parameters ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ParameterSequence parameter_;
    ::xsd::cxx::tree::one< IntervalType > interval_;
    ::xsd::cxx::tree::one< IseedType > iseed_;
    ::xsd::cxx::tree::one< LatentpType > latentp_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Human schema type.
   *
   * Parameters of host models.
   *
   * @nosubgrouping
   */
  class Human: public ::xml_schema::Type
  {
    public:
    /**
     * @name availabilityToMosquitoes
     *
     * @brief Accessor and modifier functions for the %availabilityToMosquitoes
     * required element.
     *
     * Availability of humans to mosquitoes relative to an adult, categorized
     * by age group
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::AgeGroupValues AvailabilityToMosquitoesType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AvailabilityToMosquitoesType, char > AvailabilityToMosquitoesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AvailabilityToMosquitoesType&
    getAvailabilityToMosquitoes () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AvailabilityToMosquitoesType&
    getAvailabilityToMosquitoes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAvailabilityToMosquitoes (const AvailabilityToMosquitoesType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAvailabilityToMosquitoes (::std::unique_ptr< AvailabilityToMosquitoesType > p);

    //@}

    /**
     * @name weight
     *
     * @brief Accessor and modifier functions for the %weight
     * optional element.
     *
     * By age group data on human weight (mass).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Weight WeightType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< WeightType > WeightOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeightType, char > WeightTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const WeightOptional&
    getWeight () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    WeightOptional&
    getWeight ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setWeight (const WeightType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setWeight (const WeightOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setWeight (::std::unique_ptr< WeightType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Human (const AvailabilityToMosquitoesType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Human (::std::unique_ptr< AvailabilityToMosquitoesType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Human (const xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Human (const Human& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Human*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Human&
    operator= (const Human& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Human ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AvailabilityToMosquitoesType > availabilityToMosquitoes_;
    WeightOptional weight_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Vivax schema type.
   *
   * @nosubgrouping
   */
  class Vivax: public ::xml_schema::Type
  {
    public:
    /**
     * @name probBloodStageInfectiousToMosq
     *
     * @brief Accessor and modifier functions for the %probBloodStageInfectiousToMosq
     * required element.
     *
     * The chance of a feeding mosquito becoming infected, given that the
     * host is patent. (This may be adjusted by transmission-blocking
     * vaccines.)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue ProbBloodStageInfectiousToMosqType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ProbBloodStageInfectiousToMosqType, char > ProbBloodStageInfectiousToMosqTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ProbBloodStageInfectiousToMosqType&
    getProbBloodStageInfectiousToMosq () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ProbBloodStageInfectiousToMosqType&
    getProbBloodStageInfectiousToMosq ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setProbBloodStageInfectiousToMosq (const ProbBloodStageInfectiousToMosqType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setProbBloodStageInfectiousToMosq (::std::unique_ptr< ProbBloodStageInfectiousToMosqType > p);

    //@}

    /**
     * @name hypnozoiteRelease
     *
     * @brief Accessor and modifier functions for the %hypnozoiteRelease
     * required element.
     *
     * Describes the number and times of hypnozoite releases.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::HypnozoiteRelease HypnozoiteReleaseType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HypnozoiteReleaseType, char > HypnozoiteReleaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HypnozoiteReleaseType&
    getHypnozoiteRelease () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HypnozoiteReleaseType&
    getHypnozoiteRelease ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHypnozoiteRelease (const HypnozoiteReleaseType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHypnozoiteRelease (::std::unique_ptr< HypnozoiteReleaseType > p);

    //@}

    /**
     * @name bloodStageProtectionLatency
     *
     * @brief Accessor and modifier functions for the %bloodStageProtectionLatency
     * required element.
     *
     * The length of time after expiry of a blood-stage infection during
     * which relapses from the same brood are supressed by the immune
     * system.
     * 
     * This is rounded to the nearest time-step.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue BloodStageProtectionLatencyType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BloodStageProtectionLatencyType, char > BloodStageProtectionLatencyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const BloodStageProtectionLatencyType&
    getBloodStageProtectionLatency () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    BloodStageProtectionLatencyType&
    getBloodStageProtectionLatency ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBloodStageProtectionLatency (const BloodStageProtectionLatencyType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setBloodStageProtectionLatency (::std::unique_ptr< BloodStageProtectionLatencyType > p);

    //@}

    /**
     * @name bloodStageLengthDays
     *
     * @brief Accessor and modifier functions for the %bloodStageLengthDays
     * required element.
     *
     * Parameters used to sample the length of blood-stage infections from
     * a Weibull distribution (scale parameter lambda, shape parameter k).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::BloodStageLengthDays BloodStageLengthDaysType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BloodStageLengthDaysType, char > BloodStageLengthDaysTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const BloodStageLengthDaysType&
    getBloodStageLengthDays () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    BloodStageLengthDaysType&
    getBloodStageLengthDays ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBloodStageLengthDays (const BloodStageLengthDaysType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setBloodStageLengthDays (::std::unique_ptr< BloodStageLengthDaysType > p);

    //@}

    /**
     * @name clinicalEvents
     *
     * @brief Accessor and modifier functions for the %clinicalEvents
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ClinicalEvents ClinicalEventsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ClinicalEventsType, char > ClinicalEventsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ClinicalEventsType&
    getClinicalEvents () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ClinicalEventsType&
    getClinicalEvents ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setClinicalEvents (const ClinicalEventsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setClinicalEvents (::std::unique_ptr< ClinicalEventsType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Vivax (const ProbBloodStageInfectiousToMosqType&,
           const HypnozoiteReleaseType&,
           const BloodStageProtectionLatencyType&,
           const BloodStageLengthDaysType&,
           const ClinicalEventsType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Vivax (::std::unique_ptr< ProbBloodStageInfectiousToMosqType >,
           ::std::unique_ptr< HypnozoiteReleaseType >,
           ::std::unique_ptr< BloodStageProtectionLatencyType >,
           ::std::unique_ptr< BloodStageLengthDaysType >,
           ::std::unique_ptr< ClinicalEventsType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Vivax (const xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Vivax (const Vivax& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Vivax*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Vivax&
    operator= (const Vivax& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Vivax ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ProbBloodStageInfectiousToMosqType > probBloodStageInfectiousToMosq_;
    ::xsd::cxx::tree::one< HypnozoiteReleaseType > hypnozoiteRelease_;
    ::xsd::cxx::tree::one< BloodStageProtectionLatencyType > bloodStageProtectionLatency_;
    ::xsd::cxx::tree::one< BloodStageLengthDaysType > bloodStageLengthDays_;
    ::xsd::cxx::tree::one< ClinicalEventsType > clinicalEvents_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HypnozoiteRelease schema type.
   *
   * This element defines probabilites when and how many hypnozoites are
   * released from the liverstage into the blood.
   * 
   * The gap between the start of a new brood of hypnozoites and its
   * release are defined as follows:
   * 
   * latentP + latentRelapseDays + randomReleaseDelay
   * 
   * randomReleaseDelay is based on one or two lognormal distributions,
   * which are defined in firstRelease and optionally secondRelease.
   * 
   * You can define 2 release distributions, which get added together and
   * represent the probability of hypnozoites which get released before
   * winter (first release) or after (second release).
   * 
   * You can omit the secondRelease element if no release to the blood
   * happens after winter.
   *
   * @nosubgrouping
   */
  class HypnozoiteRelease: public ::xml_schema::Type
  {
    public:
    /**
     * @name numberHypnozoites
     *
     * @brief Accessor and modifier functions for the %numberHypnozoites
     * required element.
     *
     * numberHypnozoites calculates the number of hypnozoites in the liver
     * stage based on a base which is between 0 and 1.
     * 
     * This number is random based on the following distribution and
     * normalized:
     * 
     * max
     * ? (base ^ n)
     * n = 0
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::NumberHypnozoites NumberHypnozoitesType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NumberHypnozoitesType, char > NumberHypnozoitesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NumberHypnozoitesType&
    getNumberHypnozoites () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NumberHypnozoitesType&
    getNumberHypnozoites ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNumberHypnozoites (const NumberHypnozoitesType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNumberHypnozoites (::std::unique_ptr< NumberHypnozoitesType > p);

    //@}

    /**
     * @name firstRelease
     *
     * @brief Accessor and modifier functions for the %firstRelease
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::HypnozoiteReleaseDistribution FirstReleaseType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FirstReleaseType, char > FirstReleaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FirstReleaseType&
    getFirstRelease () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FirstReleaseType&
    getFirstRelease ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFirstRelease (const FirstReleaseType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setFirstRelease (::std::unique_ptr< FirstReleaseType > p);

    //@}

    /**
     * @name secondRelease
     *
     * @brief Accessor and modifier functions for the %secondRelease
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::HypnozoiteReleaseDistribution SecondReleaseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SecondReleaseType > SecondReleaseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SecondReleaseType, char > SecondReleaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SecondReleaseOptional&
    getSecondRelease () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SecondReleaseOptional&
    getSecondRelease ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSecondRelease (const SecondReleaseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSecondRelease (const SecondReleaseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSecondRelease (::std::unique_ptr< SecondReleaseType > p);

    //@}

    /**
     * @name pSecondRelease
     *
     * @brief Accessor and modifier functions for the %pSecondRelease
     * optional attribute with a default value.
     *
     * Probability of a second release. If undefined it is zero.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double PSecondReleaseType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PSecondReleaseType, char, ::xsd::cxx::tree::schema_type::double_ > PSecondReleaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const PSecondReleaseType&
    getPSecondRelease () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    PSecondReleaseType&
    getPSecondRelease ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setPSecondRelease (const PSecondReleaseType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static PSecondReleaseType
    getPSecondReleaseDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HypnozoiteRelease (const NumberHypnozoitesType&,
                       const FirstReleaseType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    HypnozoiteRelease (::std::unique_ptr< NumberHypnozoitesType >,
                       ::std::unique_ptr< FirstReleaseType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HypnozoiteRelease (const xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HypnozoiteRelease (const HypnozoiteRelease& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HypnozoiteRelease*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HypnozoiteRelease&
    operator= (const HypnozoiteRelease& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HypnozoiteRelease ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NumberHypnozoitesType > numberHypnozoites_;
    ::xsd::cxx::tree::one< FirstReleaseType > firstRelease_;
    SecondReleaseOptional secondRelease_;
    ::xsd::cxx::tree::one< PSecondReleaseType > pSecondRelease_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HypnozoiteReleaseDistribution schema type.
   *
   * @nosubgrouping
   */
  class HypnozoiteReleaseDistribution: public ::scnXml::NormalSample
  {
    public:
    /**
     * @name latentRelapseDays
     *
     * @brief Accessor and modifier functions for the %latentRelapseDays
     * required attribute.
     *
     * Usually 15 days or 10 days (3 or 2 5-day timesteps).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int LatentRelapseDaysType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LatentRelapseDaysType, char > LatentRelapseDaysTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const LatentRelapseDaysType&
    getLatentRelapseDays () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    LatentRelapseDaysType&
    getLatentRelapseDays ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLatentRelapseDays (const LatentRelapseDaysType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HypnozoiteReleaseDistribution (const MuType&,
                                   const SigmaType&,
                                   const LatentRelapseDaysType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HypnozoiteReleaseDistribution (const xercesc::DOMElement& e,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HypnozoiteReleaseDistribution (const HypnozoiteReleaseDistribution& x,
                                   ::xml_schema::Flags f = 0,
                                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HypnozoiteReleaseDistribution*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HypnozoiteReleaseDistribution&
    operator= (const HypnozoiteReleaseDistribution& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HypnozoiteReleaseDistribution ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LatentRelapseDaysType > latentRelapseDays_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ClinicalEvents schema type.
   *
   * This elements holds all information about probabilites for clinical
   * events from infections and relapses.
   *
   * @nosubgrouping
   */
  class ClinicalEvents: public ::xml_schema::Type
  {
    public:
    /**
     * @name pPrimaryInfection
     *
     * @brief Accessor and modifier functions for the %pPrimaryInfection
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ProbVivaxEvent PPrimaryInfectionType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PPrimaryInfectionType, char > PPrimaryInfectionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PPrimaryInfectionType&
    getPPrimaryInfection () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PPrimaryInfectionType&
    getPPrimaryInfection ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPPrimaryInfection (const PPrimaryInfectionType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPPrimaryInfection (::std::unique_ptr< PPrimaryInfectionType > p);

    //@}

    /**
     * @name pRelapseOne
     *
     * @brief Accessor and modifier functions for the %pRelapseOne
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ProbVivaxEvent PRelapseOneType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PRelapseOneType, char > PRelapseOneTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PRelapseOneType&
    getPRelapseOne () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PRelapseOneType&
    getPRelapseOne ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPRelapseOne (const PRelapseOneType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPRelapseOne (::std::unique_ptr< PRelapseOneType > p);

    //@}

    /**
     * @name pRelapseTwoPlus
     *
     * @brief Accessor and modifier functions for the %pRelapseTwoPlus
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ProbVivaxEvent PRelapseTwoPlusType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PRelapseTwoPlusType, char > PRelapseTwoPlusTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PRelapseTwoPlusType&
    getPRelapseTwoPlus () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PRelapseTwoPlusType&
    getPRelapseTwoPlus ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPRelapseTwoPlus (const PRelapseTwoPlusType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPRelapseTwoPlus (::std::unique_ptr< PRelapseTwoPlusType > p);

    //@}

    /**
     * @name pEventIsSevere
     *
     * @brief Accessor and modifier functions for the %pEventIsSevere
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue PEventIsSevereType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PEventIsSevereType, char > PEventIsSevereTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PEventIsSevereType&
    getPEventIsSevere () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PEventIsSevereType&
    getPEventIsSevere ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPEventIsSevere (const PEventIsSevereType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPEventIsSevere (::std::unique_ptr< PEventIsSevereType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ClinicalEvents (const PPrimaryInfectionType&,
                    const PRelapseOneType&,
                    const PRelapseTwoPlusType&,
                    const PEventIsSevereType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ClinicalEvents (::std::unique_ptr< PPrimaryInfectionType >,
                    ::std::unique_ptr< PRelapseOneType >,
                    ::std::unique_ptr< PRelapseTwoPlusType >,
                    ::std::unique_ptr< PEventIsSevereType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ClinicalEvents (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClinicalEvents (const ClinicalEvents& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ClinicalEvents*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClinicalEvents&
    operator= (const ClinicalEvents& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ClinicalEvents ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PPrimaryInfectionType > pPrimaryInfection_;
    ::xsd::cxx::tree::one< PRelapseOneType > pRelapseOne_;
    ::xsd::cxx::tree::one< PRelapseTwoPlusType > pRelapseTwoPlus_;
    ::xsd::cxx::tree::one< PEventIsSevereType > pEventIsSevere_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ProbVivaxEvent schema type.
   *
   * @nosubgrouping
   */
  class ProbVivaxEvent: public ::xml_schema::Type
  {
    public:
    /**
     * @name a
     *
     * @brief Accessor and modifier functions for the %a
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double AType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< AType, char, ::xsd::cxx::tree::schema_type::double_ > ATraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const AType&
    getA () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    AType&
    getA ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setA (const AType& x);

    //@}

    /**
     * @name b
     *
     * @brief Accessor and modifier functions for the %b
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double BType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< BType, char, ::xsd::cxx::tree::schema_type::double_ > BTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const BType&
    getB () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    BType&
    getB ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setB (const BType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ProbVivaxEvent (const AType&,
                    const BType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ProbVivaxEvent (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ProbVivaxEvent (const ProbVivaxEvent& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ProbVivaxEvent*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ProbVivaxEvent&
    operator= (const ProbVivaxEvent& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ProbVivaxEvent ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< AType > a_;
    ::xsd::cxx::tree::one< BType > b_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParasiteGenetics schema type.
   *
   * @nosubgrouping
   */
  class ParasiteGenetics: public ::xml_schema::Type
  {
    public:
    /**
     * @name locus
     *
     * @brief Accessor and modifier functions for the %locus
     * sequence element.
     *
     * Describes a locus, or a point at which an infection may
     * vary. The genotype of an infection is determined by
     * choosing one allele at each locus. Initial frequencies of
     * alleles are specified independently for each locus, but
     * subsequent infections are selected according to success of
     * genotypes.
     * 
     * Alleles at loci can affect fitness and resistance to any
     * number of drugs.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ParasiteLocus LocusType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< LocusType > LocusSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< LocusType >::iterator LocusIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< LocusType >::const_iterator LocusConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LocusType, char > LocusTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const LocusSequence&
    getLocus () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    LocusSequence&
    getLocus ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setLocus (const LocusSequence& s);

    //@}

    /**
     * @name samplingMode
     *
     * @brief Accessor and modifier functions for the %samplingMode
     * required attribute.
     *
     * This controls how genotypes are determined for new infections during
     * the intervention period. Prior to this (in initialisation phases),
     * genotypes are always sampled using the specified initial frequencies.
     * 
     * Mode "initial" continues to sample genotypes using initial
     * frequencies (i.e. independent of the success of parent generations of
     * parasites).
     * 
     * Mode "tracking" samples genotypes based on the success parent
     * generations of parasites have in infecting mosquitoes, tracked per
     * genotype.
     * 
     * It is possible that in the future a recombination option will be
     * added to this list, however designing a suitable model is not
     * trivial.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::scnXml::SamplingMode SamplingModeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SamplingModeType, char > SamplingModeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const SamplingModeType&
    getSamplingMode () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    SamplingModeType&
    getSamplingMode ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSamplingMode (const SamplingModeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSamplingMode (::std::unique_ptr< SamplingModeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParasiteGenetics (const SamplingModeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParasiteGenetics (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParasiteGenetics (const ParasiteGenetics& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParasiteGenetics*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParasiteGenetics&
    operator= (const ParasiteGenetics& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParasiteGenetics ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    LocusSequence locus_;
    ::xsd::cxx::tree::one< SamplingModeType > samplingMode_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParasiteGenotype schema type.
   *
   * @nosubgrouping
   */
  class ParasiteGenotype: public ::xml_schema::Type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     *
     * Name of the genotype; used to refer to it elsewhere.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name initialFrequency
     *
     * @brief Accessor and modifier functions for the %initialFrequency
     * required attribute.
     *
     * Specification of how commonly this genotype occurs during
     * initialisation phases of the simulation relative to other genotypes.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double InitialFrequencyType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InitialFrequencyType, char, ::xsd::cxx::tree::schema_type::double_ > InitialFrequencyTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const InitialFrequencyType&
    getInitialFrequency () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    InitialFrequencyType&
    getInitialFrequency ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInitialFrequency (const InitialFrequencyType& x);

    //@}

    /**
     * @name fitness
     *
     * @brief Accessor and modifier functions for the %fitness
     * required attribute.
     *
     * Fitness factor of the genotype. This is multiplication factor used to
     * speed up or slow down replication of parasites.
     * 
     * For example, if a genotype has a fitness factor of 0.8, then the
     * parasites with this genotype will replicate 20% slower in the host
     * than the baseline.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double FitnessType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< FitnessType, char, ::xsd::cxx::tree::schema_type::double_ > FitnessTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const FitnessType&
    getFitness () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    FitnessType&
    getFitness ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setFitness (const FitnessType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParasiteGenotype (const NameType&,
                      const InitialFrequencyType&,
                      const FitnessType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParasiteGenotype (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParasiteGenotype (const ParasiteGenotype& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParasiteGenotype*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParasiteGenotype&
    operator= (const ParasiteGenotype& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParasiteGenotype ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    ::xsd::cxx::tree::one< InitialFrequencyType > initialFrequency_;
    ::xsd::cxx::tree::one< FitnessType > fitness_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParasiteLocus schema type.
   *
   * @nosubgrouping
   */
  class ParasiteLocus: public ::xml_schema::Type
  {
    public:
    /**
     * @name allele
     *
     * @brief Accessor and modifier functions for the %allele
     * sequence element.
     *
     * Describes an allele, or one possible genetic option
     * of multiple at one point of variance.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ParasiteAllele AlleleType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< AlleleType > AlleleSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< AlleleType >::iterator AlleleIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< AlleleType >::const_iterator AlleleConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AlleleType, char > AlleleTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const AlleleSequence&
    getAllele () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    AlleleSequence&
    getAllele ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setAllele (const AlleleSequence& s);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     *
     * Name of the Locus
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParasiteLocus (const NameType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParasiteLocus (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParasiteLocus (const ParasiteLocus& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParasiteLocus*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParasiteLocus&
    operator= (const ParasiteLocus& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParasiteLocus ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AlleleSequence allele_;
    ::xsd::cxx::tree::one< NameType > name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ParasiteAllele schema type.
   *
   * @nosubgrouping
   */
  class ParasiteAllele: public ::xml_schema::Type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     *
     * Name of the allele; used to refer to it elsewhere.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name initialFrequency
     *
     * @brief Accessor and modifier functions for the %initialFrequency
     * required attribute.
     *
     * Specification of how commonly this allele occurs during warmup
     * relative to other alleles of the same locus.
     * 
     * During the simulation's initialisation phases, the frequency at which
     * each allele of each locus occurs is fixed. After the initialisation
     * phase, frequency of alleles is modelled as an emergent property of
     * the success of genotypes.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double InitialFrequencyType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InitialFrequencyType, char, ::xsd::cxx::tree::schema_type::double_ > InitialFrequencyTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const InitialFrequencyType&
    getInitialFrequency () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    InitialFrequencyType&
    getInitialFrequency ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInitialFrequency (const InitialFrequencyType& x);

    //@}

    /**
     * @name fitness
     *
     * @brief Accessor and modifier functions for the %fitness
     * required attribute.
     *
     * Fitness factor of the allele. This is multiplication factor used to
     * speed up or slow down replication of parasites.
     * 
     * For example, if a genotype has an allele with a fitness factor of 1
     * at one locus and another allele with a fitness factor of 0.8 at a
     * second locus, then the parasites with the genotype will replicate 20%
     * slower than the baseline.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double FitnessType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< FitnessType, char, ::xsd::cxx::tree::schema_type::double_ > FitnessTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const FitnessType&
    getFitness () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    FitnessType&
    getFitness ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setFitness (const FitnessType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ParasiteAllele (const NameType&,
                    const InitialFrequencyType&,
                    const FitnessType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ParasiteAllele (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParasiteAllele (const ParasiteAllele& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ParasiteAllele*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ParasiteAllele&
    operator= (const ParasiteAllele& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ParasiteAllele ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    ::xsd::cxx::tree::one< InitialFrequencyType > initialFrequency_;
    ::xsd::cxx::tree::one< FitnessType > fitness_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Diagnostics schema type.
   *
   * @nosubgrouping
   */
  class Diagnostics: public ::xml_schema::Type
  {
    public:
    /**
     * @name diagnostic
     *
     * @brief Accessor and modifier functions for the %diagnostic
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Diagnostic DiagnosticType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DiagnosticType > DiagnosticSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< DiagnosticType >::iterator DiagnosticIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< DiagnosticType >::const_iterator DiagnosticConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DiagnosticType, char > DiagnosticTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DiagnosticSequence&
    getDiagnostic () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DiagnosticSequence&
    getDiagnostic ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDiagnostic (const DiagnosticSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Diagnostics ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Diagnostics (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Diagnostics (const Diagnostics& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Diagnostics*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Diagnostics&
    operator= (const Diagnostics& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Diagnostics ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DiagnosticSequence diagnostic_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Diagnostic schema type.
   *
   * @nosubgrouping
   */
  class Diagnostic: public ::xml_schema::Type
  {
    public:
    /**
     * @name deterministic
     *
     * @brief Accessor and modifier functions for the %deterministic
     * optional element.
     *
     * Specify that an artificial deterministic test is used: outcome is
     * positive if parasite density is at least the minimum given.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Deterministic DeterministicType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeterministicType > DeterministicOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeterministicType, char > DeterministicTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeterministicOptional&
    getDeterministic () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DeterministicOptional&
    getDeterministic ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeterministic (const DeterministicType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDeterministic (const DeterministicOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeterministic (::std::unique_ptr< DeterministicType > p);

    //@}

    /**
     * @name stochastic
     *
     * @brief Accessor and modifier functions for the %stochastic
     * optional element.
     *
     * An improved model of detection which is non-deterministic, including
     * false positive results as well as false negatives.
     * 
     * The probability of a positive outcome is modelled as 1 + s?(x/(x+d) -
     * 1)
     * where x is the parasite density, d is the density at which the test
     * outcome
     * has a 50% chance of being positive, and s is the probability of a
     * positive
     * outcome given no parasites (the specificity).
     * 
     * Some parameterisations:
     * 
     * Microscopy sensitivity/specificity data in Africa;
     * Source: expert opinion ? Allan Schapira
     * dens_50 = 20.0
     * specificity = .75
     * 
     * RDT sensitivity/specificity for Plasmodium falciparum in Africa
     * Source: Murray et al (Clinical Microbiological Reviews, Jan. 2008)
     * dens_50 = 50.0;
     * specificity = .942;
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Stochastic StochasticType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StochasticType > StochasticOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< StochasticType, char > StochasticTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StochasticOptional&
    getStochastic () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    StochasticOptional&
    getStochastic ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setStochastic (const StochasticType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setStochastic (const StochasticOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStochastic (::std::unique_ptr< StochasticType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     *
     * Name of this diagnostic (parameterisation). May be used elsewhere in
     * the XML document to refer to this set of diagnostic parameters.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name units
     *
     * @brief Accessor and modifier functions for the %units
     * optional attribute.
     *
     * Parasite densities, as estimated according to standard microscopy
     * methods, the Garki method, and as derived from Malariatherapy data
     * are not equivalent. Internally, a "bias" factor is used to convert
     * values estimated by one methods to values comparable with another
     * (see AJTMHv75 supplement 2 pp20-21).
     * 
     * This option allows specification of which methodology the density
     * given in the diagnostic specification is measured with. Values
     * allowed are: Malariatherapy, Garki and Other. If not specified,
     * Other is assumed, unless the GARKI_DENSITY_BIAS model option is used,
     * in which case this option must be specified.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::scnXml::Units UnitsType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UnitsType > UnitsOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< UnitsType, char > UnitsTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UnitsOptional&
    getUnits () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    UnitsOptional&
    getUnits ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setUnits (const UnitsType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setUnits (const UnitsOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUnits (::std::unique_ptr< UnitsType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Diagnostic (const NameType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Diagnostic (const xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Diagnostic (const Diagnostic& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Diagnostic*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Diagnostic&
    operator= (const Diagnostic& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Diagnostic ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DeterministicOptional deterministic_;
    StochasticOptional stochastic_;
    ::xsd::cxx::tree::one< NameType > name_;
    UnitsOptional units_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %scenario schema type.
   *
   * @nosubgrouping
   */
  class Scenario: public ::xml_schema::Type
  {
    public:
    /**
     * @name demography
     *
     * @brief Accessor and modifier functions for the %demography
     * required element.
     *
     * Description of demography
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Demography DemographyType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DemographyType, char > DemographyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DemographyType&
    getDemography () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DemographyType&
    getDemography ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDemography (const DemographyType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDemography (::std::unique_ptr< DemographyType > p);

    //@}

    /**
     * @name monitoring
     *
     * @brief Accessor and modifier functions for the %monitoring
     * required element.
     *
     * Description of surveys
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Monitoring MonitoringType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MonitoringType, char > MonitoringTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const MonitoringType&
    getMonitoring () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    MonitoringType&
    getMonitoring ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMonitoring (const MonitoringType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMonitoring (::std::unique_ptr< MonitoringType > p);

    //@}

    /**
     * @name interventions
     *
     * @brief Accessor and modifier functions for the %interventions
     * required element.
     *
     * List of interventions. Generally these are either point-time
     * distributions of something to some subset of the population, or
     * continuous-time distribution targetting individuals when they
     * reach a certain age.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Interventions InterventionsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InterventionsType, char > InterventionsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InterventionsType&
    getInterventions () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InterventionsType&
    getInterventions ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInterventions (const InterventionsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInterventions (::std::unique_ptr< InterventionsType > p);

    //@}

    /**
     * @name healthSystem
     *
     * @brief Accessor and modifier functions for the %healthSystem
     * required element.
     *
     * Description of health system.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::HealthSystem HealthSystemType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HealthSystemType, char > HealthSystemTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HealthSystemType&
    getHealthSystem () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HealthSystemType&
    getHealthSystem ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHealthSystem (const HealthSystemType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHealthSystem (::std::unique_ptr< HealthSystemType > p);

    //@}

    /**
     * @name entomology
     *
     * @brief Accessor and modifier functions for the %entomology
     * required element.
     *
     * Description of entomological data
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Entomology EntomologyType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EntomologyType, char > EntomologyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EntomologyType&
    getEntomology () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EntomologyType&
    getEntomology ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEntomology (const EntomologyType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEntomology (::std::unique_ptr< EntomologyType > p);

    //@}

    /**
     * @name parasiteGenetics
     *
     * @brief Accessor and modifier functions for the %parasiteGenetics
     * optional element.
     *
     * A specification of genotypes of infection parasites.
     * 
     * May be omitted; in this case there is no modelling of genetic
     * differences of infections (resistance, fitness).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ParasiteGenetics ParasiteGeneticsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ParasiteGeneticsType > ParasiteGeneticsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParasiteGeneticsType, char > ParasiteGeneticsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ParasiteGeneticsOptional&
    getParasiteGenetics () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ParasiteGeneticsOptional&
    getParasiteGenetics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParasiteGenetics (const ParasiteGeneticsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setParasiteGenetics (const ParasiteGeneticsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setParasiteGenetics (::std::unique_ptr< ParasiteGeneticsType > p);

    //@}

    /**
     * @name pharmacology
     *
     * @brief Accessor and modifier functions for the %pharmacology
     * optional element.
     *
     * Drug model parameters and drug usage parameters
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Pharmacology PharmacologyType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PharmacologyType > PharmacologyOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PharmacologyType, char > PharmacologyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PharmacologyOptional&
    getPharmacology () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PharmacologyOptional&
    getPharmacology ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPharmacology (const PharmacologyType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPharmacology (const PharmacologyOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPharmacology (::std::unique_ptr< PharmacologyType > p);

    //@}

    /**
     * @name diagnostics
     *
     * @brief Accessor and modifier functions for the %diagnostics
     * optional element.
     *
     * Diagnostic model parameters
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Diagnostics DiagnosticsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DiagnosticsType > DiagnosticsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DiagnosticsType, char > DiagnosticsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DiagnosticsOptional&
    getDiagnostics () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DiagnosticsOptional&
    getDiagnostics ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDiagnostics (const DiagnosticsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDiagnostics (const DiagnosticsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDiagnostics (::std::unique_ptr< DiagnosticsType > p);

    //@}

    /**
     * @name model
     *
     * @brief Accessor and modifier functions for the %model
     * required element.
     *
     * Encapsulation of all parameters which describe the model according
     * to which fitting is done.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Model ModelType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModelType, char > ModelTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ModelType&
    getModel () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ModelType&
    getModel ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setModel (const ModelType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setModel (::std::unique_ptr< ModelType > p);

    //@}

    /**
     * @name schemaVersion
     *
     * @brief Accessor and modifier functions for the %schemaVersion
     * required attribute.
     *
     * Version of xml schema. If not equal to the current version
     * an error is thrown. Use SchemaTranslator to update xml files.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int SchemaVersionType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SchemaVersionType, char > SchemaVersionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const SchemaVersionType&
    getSchemaVersion () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    SchemaVersionType&
    getSchemaVersion ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSchemaVersion (const SchemaVersionType& x);

    //@}

    /**
     * @name analysisNo
     *
     * @brief Accessor and modifier functions for the %analysisNo
     * optional attribute.
     *
     * Unique identifier of scenario
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int AnalysisNoType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AnalysisNoType > AnalysisNoOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< AnalysisNoType, char > AnalysisNoTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AnalysisNoOptional&
    getAnalysisNo () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    AnalysisNoOptional&
    getAnalysisNo ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setAnalysisNo (const AnalysisNoType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setAnalysisNo (const AnalysisNoOptional& x);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     *
     * Name of intervention
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name wuID
     *
     * @brief Accessor and modifier functions for the %wuID
     * optional attribute.
     *
     * Work unit ID. Obselete and no longer required.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int WuIDType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< WuIDType > WuIDOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< WuIDType, char > WuIDTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const WuIDOptional&
    getWuID () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    WuIDOptional&
    getWuID ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setWuID (const WuIDType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setWuID (const WuIDOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Scenario (const DemographyType&,
              const MonitoringType&,
              const InterventionsType&,
              const HealthSystemType&,
              const EntomologyType&,
              const ModelType&,
              const SchemaVersionType&,
              const NameType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Scenario (::std::unique_ptr< DemographyType >,
              ::std::unique_ptr< MonitoringType >,
              ::std::unique_ptr< InterventionsType >,
              ::std::unique_ptr< HealthSystemType >,
              ::std::unique_ptr< EntomologyType >,
              ::std::unique_ptr< ModelType >,
              const SchemaVersionType&,
              const NameType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Scenario (const xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Scenario (const Scenario& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Scenario*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Scenario&
    operator= (const Scenario& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Scenario ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DemographyType > demography_;
    ::xsd::cxx::tree::one< MonitoringType > monitoring_;
    ::xsd::cxx::tree::one< InterventionsType > interventions_;
    ::xsd::cxx::tree::one< HealthSystemType > healthSystem_;
    ::xsd::cxx::tree::one< EntomologyType > entomology_;
    ParasiteGeneticsOptional parasiteGenetics_;
    PharmacologyOptional pharmacology_;
    DiagnosticsOptional diagnostics_;
    ::xsd::cxx::tree::one< ModelType > model_;
    ::xsd::cxx::tree::one< SchemaVersionType > schemaVersion_;
    AnalysisNoOptional analysisNo_;
    ::xsd::cxx::tree::one< NameType > name_;
    WuIDOptional wuID_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %weight schema type.
   *
   * @nosubgrouping
   */
  class Weight: public ::scnXml::AgeGroupValues
  {
    public:
    /**
     * @name multStdDev
     *
     * @brief Accessor and modifier functions for the %multStdDev
     * required attribute.
     *
     * Each human is assigned a weight multiplier from a normal distribution
     * with mean 1 and this standard deviation at birth. His/her weight
     * is this multiplier times the mean from age distribution.
     * A standard deviation of zero for no heterogeneity is valid; a rough
     * value from Tanzanian data is 0.14.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MultStdDevType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MultStdDevType, char, ::xsd::cxx::tree::schema_type::double_ > MultStdDevTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MultStdDevType&
    getMultStdDev () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MultStdDevType&
    getMultStdDev ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMultStdDev (const MultStdDevType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Weight (const MultStdDevType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Weight (const xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Weight (const Weight& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Weight*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Weight&
    operator= (const Weight& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Weight ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MultStdDevType > multStdDev_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %bloodStageLengthDays schema type.
   *
   * @nosubgrouping
   */
  class BloodStageLengthDays: public ::xml_schema::Type
  {
    public:
    /**
     * @name weibullScale
     *
     * @brief Accessor and modifier functions for the %weibullScale
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double WeibullScaleType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeibullScaleType, char, ::xsd::cxx::tree::schema_type::double_ > WeibullScaleTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const WeibullScaleType&
    getWeibullScale () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    WeibullScaleType&
    getWeibullScale ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setWeibullScale (const WeibullScaleType& x);

    //@}

    /**
     * @name weibullShape
     *
     * @brief Accessor and modifier functions for the %weibullShape
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double WeibullShapeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< WeibullShapeType, char, ::xsd::cxx::tree::schema_type::double_ > WeibullShapeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const WeibullShapeType&
    getWeibullShape () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    WeibullShapeType&
    getWeibullShape ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setWeibullShape (const WeibullShapeType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BloodStageLengthDays (const WeibullScaleType&,
                          const WeibullShapeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BloodStageLengthDays (const xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BloodStageLengthDays (const BloodStageLengthDays& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BloodStageLengthDays*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BloodStageLengthDays&
    operator= (const BloodStageLengthDays& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BloodStageLengthDays ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< WeibullScaleType > weibullScale_;
    ::xsd::cxx::tree::one< WeibullShapeType > weibullShape_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %numberHypnozoites schema type.
   *
   * @nosubgrouping
   */
  class NumberHypnozoites: public ::xml_schema::Type
  {
    public:
    /**
     * @name max
     *
     * @brief Accessor and modifier functions for the %max
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int MaxType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxType, char > MaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MaxType&
    getMax () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MaxType&
    getMax ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMax (const MaxType& x);

    //@}

    /**
     * @name base
     *
     * @brief Accessor and modifier functions for the %base
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double BaseType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< BaseType, char, ::xsd::cxx::tree::schema_type::double_ > BaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const BaseType&
    getBase () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    BaseType&
    getBase ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setBase (const BaseType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NumberHypnozoites (const MaxType&,
                       const BaseType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NumberHypnozoites (const xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NumberHypnozoites (const NumberHypnozoites& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NumberHypnozoites*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NumberHypnozoites&
    operator= (const NumberHypnozoites& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NumberHypnozoites ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MaxType > max_;
    ::xsd::cxx::tree::one< BaseType > base_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %samplingMode
   * schema type.
   */
  class SamplingMode: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      initial,
      tracking
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    SamplingMode (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    SamplingMode (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    SamplingMode (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    SamplingMode (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SamplingMode (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SamplingMode (const xercesc::DOMAttr& a,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SamplingMode (const ::std::string& s,
                  const xercesc::DOMElement* e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SamplingMode (const SamplingMode& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SamplingMode*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    SamplingMode&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_SamplingMode_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_SamplingMode_convert () const;

    public:
    static const char* const _xsd_SamplingMode_literals_[2];
    static const Value _xsd_SamplingMode_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %deterministic schema type.
   *
   * @nosubgrouping
   */
  class Deterministic: public ::xml_schema::Type
  {
    public:
    /**
     * @name minDensity
     *
     * @brief Accessor and modifier functions for the %minDensity
     * required attribute.
     *
     * The minimum density at which parasites can be detected. If 0,
     * the test outcome is always positive.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MinDensityType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MinDensityType, char, ::xsd::cxx::tree::schema_type::double_ > MinDensityTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MinDensityType&
    getMinDensity () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MinDensityType&
    getMinDensity ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMinDensity (const MinDensityType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Deterministic (const MinDensityType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Deterministic (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Deterministic (const Deterministic& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Deterministic*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Deterministic&
    operator= (const Deterministic& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Deterministic ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MinDensityType > minDensity_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %stochastic schema type.
   *
   * @nosubgrouping
   */
  class Stochastic: public ::xml_schema::Type
  {
    public:
    /**
     * @name dens_50
     *
     * @brief Accessor and modifier functions for the %dens_50
     * required attribute.
     *
     * The density at which the test outcome has a 50% chance of being
     * positive.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Dens_50Type;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Dens_50Type, char, ::xsd::cxx::tree::schema_type::double_ > Dens_50Traits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const Dens_50Type&
    getDens_50 () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    Dens_50Type&
    getDens_50 ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDens_50 (const Dens_50Type& x);

    //@}

    /**
     * @name specificity
     *
     * @brief Accessor and modifier functions for the %specificity
     * required attribute.
     *
     * The probability of a positive test outcome in the absense of
    parasites. */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double SpecificityType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SpecificityType, char, ::xsd::cxx::tree::schema_type::double_ > SpecificityTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const SpecificityType&
    getSpecificity () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    SpecificityType&
    getSpecificity ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSpecificity (const SpecificityType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Stochastic (const Dens_50Type&,
                const SpecificityType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Stochastic (const xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Stochastic (const Stochastic& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Stochastic*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Stochastic&
    operator= (const Stochastic& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Stochastic ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< Dens_50Type > dens_50_;
    ::xsd::cxx::tree::one< SpecificityType > specificity_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %units
   * schema type.
   */
  class Units: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      Other,
      Garki,
      Malariatherapy
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Units (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Units (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Units (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Units (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Units (const xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Units (const xercesc::DOMAttr& a,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Units (const ::std::string& s,
           const xercesc::DOMElement* e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Units (const Units& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Units*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Units&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Units_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Units_convert () const;

    public:
    static const char* const _xsd_Units_literals_[3];
    static const Value _xsd_Units_indexes_[3];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %model schema type.
   *
   * @nosubgrouping
   */
  class Model: public ::xml_schema::Type
  {
    public:
    /**
     * @name ModelOptions
     *
     * @brief Accessor and modifier functions for the %ModelOptions
     * required element.
     *
     * All model options (bug fixes, choices between models, etc.).          
     * 
     * The list of recognised options can be found in the code at:
     * model/util/ModelOptions.h and should also be in the wiki.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::OptionSet ModelOptionsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ModelOptionsType, char > ModelOptionsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ModelOptionsType&
    getModelOptions () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ModelOptionsType&
    getModelOptions ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setModelOptions (const ModelOptionsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setModelOptions (::std::unique_ptr< ModelOptionsType > p);

    //@}

    /**
     * @name clinical
     *
     * @brief Accessor and modifier functions for the %clinical
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Clinical ClinicalType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ClinicalType, char > ClinicalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ClinicalType&
    getClinical () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ClinicalType&
    getClinical ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setClinical (const ClinicalType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setClinical (::std::unique_ptr< ClinicalType > p);

    //@}

    /**
     * @name human
     *
     * @brief Accessor and modifier functions for the %human
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Human HumanType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HumanType, char > HumanTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HumanType&
    getHuman () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HumanType&
    getHuman ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHuman (const HumanType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHuman (::std::unique_ptr< HumanType > p);

    //@}

    /**
     * @name vivax
     *
     * @brief Accessor and modifier functions for the %vivax
     * optional element.
     *
     * This describes Vivax model parameters, and is required when using the
     * VIVAX_SIMPLE_MODEL model option.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Vivax VivaxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< VivaxType > VivaxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VivaxType, char > VivaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const VivaxOptional&
    getVivax () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    VivaxOptional&
    getVivax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVivax (const VivaxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setVivax (const VivaxOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setVivax (::std::unique_ptr< VivaxType > p);

    //@}

    /**
     * @name parameters
     *
     * @brief Accessor and modifier functions for the %parameters
     * required element.
     *
     * Parameters of the epidemiological model
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Parameters ParametersType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ParametersType, char > ParametersTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ParametersType&
    getParameters () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ParametersType&
    getParameters ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setParameters (const ParametersType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setParameters (::std::unique_ptr< ParametersType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Model (const ModelOptionsType&,
           const ClinicalType&,
           const HumanType&,
           const ParametersType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Model (::std::unique_ptr< ModelOptionsType >,
           ::std::unique_ptr< ClinicalType >,
           ::std::unique_ptr< HumanType >,
           ::std::unique_ptr< ParametersType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Model (const xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Model (const Model& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Model*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Model&
    operator= (const Model& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Model ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ModelOptionsType > ModelOptions_;
    ::xsd::cxx::tree::one< ClinicalType > clinical_;
    ::xsd::cxx::tree::one< HumanType > human_;
    VivaxOptional vivax_;
    ::xsd::cxx::tree::one< ParametersType > parameters_;

    //@endcond
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace scnXml
{
  /**
   * @name Parsing functions for the %scenario document root.
   *
   * Description of scenario
   */
  //@{

  /**
   * @brief Parse a URI or a local file.
   *
   * @param uri A URI or a local file name.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (const ::std::string& uri,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a URI or a local file with an error handler.
   *
   * @param uri A URI or a local file name.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (const ::std::string& uri,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a URI or a local file with a Xerces-C++ DOM error
   * handler.
   *
   * @param uri A URI or a local file name.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (const ::std::string& uri,
                 xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream.
   *
   * @param is A standrad input stream.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::std::istream& is,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with an error handler.
   *
   * @param is A standrad input stream.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::std::istream& is,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a Xerces-C++ DOM error
   * handler.
   *
   * @param is A standrad input stream.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::std::istream& is,
                 xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id and an
   * error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::std::istream& is,
                 const ::std::string& id,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a standard input stream with a resource id and a
   * Xerces-C++ DOM error handler.
   *
   * @param is A standrad input stream.
   * @param id A resource id.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * The resource id is used to identify the document being parsed in
   * diagnostics as well as to resolve relative paths.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::std::istream& is,
                 const ::std::string& id,
                 xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source.
   *
   * @param is A Xerces-C++ input source.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function uses exceptions to report parsing errors.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (xercesc::InputSource& is,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source with an error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh An error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (xercesc::InputSource& is,
                 ::xml_schema::ErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
   * error handler.
   *
   * @param is A Xerces-C++ input source.
   * @param eh A Xerces-C++ DOM error handler.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function reports parsing errors by calling the error handler.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (xercesc::InputSource& is,
                 xercesc::DOMErrorHandler& eh,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (const xercesc::DOMDocument& d,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  /**
   * @brief Parse a Xerces-C++ DOM document.
   *
   * @param d A pointer to the Xerces-C++ DOM document.
   * @param f Parsing flags.
   * @param p Parsing properties. 
   * @return A pointer to the root of the object model.
   *
   * This function is normally used together with the keep_dom and
   * own_dom parsing flags to assign ownership of the DOM document
   * to the object model.
   */
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::xml_schema::dom::unique_ptr< xercesc::DOMDocument > d,
                 ::xml_schema::Flags f = 0,
                 const ::xml_schema::Properties& p = ::xml_schema::Properties ());

  //@}
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_CODE_OPENMALARIA_SCHEMA_SCENARIO_H

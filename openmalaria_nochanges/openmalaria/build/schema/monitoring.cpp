// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "monitoring.h"

namespace scnXml
{
  // Monitoring
  // 

  const Monitoring::ContinuousOptional& Monitoring::
  getContinuous () const
  {
    return this->continuous_;
  }

  Monitoring::ContinuousOptional& Monitoring::
  getContinuous ()
  {
    return this->continuous_;
  }

  void Monitoring::
  setContinuous (const ContinuousType& x)
  {
    this->continuous_.set (x);
  }

  void Monitoring::
  setContinuous (const ContinuousOptional& x)
  {
    this->continuous_ = x;
  }

  void Monitoring::
  setContinuous (::std::unique_ptr< ContinuousType > x)
  {
    this->continuous_.set (std::move (x));
  }

  const Monitoring::SurveyOptionsType& Monitoring::
  getSurveyOptions () const
  {
    return this->SurveyOptions_.get ();
  }

  Monitoring::SurveyOptionsType& Monitoring::
  getSurveyOptions ()
  {
    return this->SurveyOptions_.get ();
  }

  void Monitoring::
  setSurveyOptions (const SurveyOptionsType& x)
  {
    this->SurveyOptions_.set (x);
  }

  void Monitoring::
  setSurveyOptions (::std::unique_ptr< SurveyOptionsType > x)
  {
    this->SurveyOptions_.set (std::move (x));
  }

  const Monitoring::SurveysType& Monitoring::
  getSurveys () const
  {
    return this->surveys_.get ();
  }

  Monitoring::SurveysType& Monitoring::
  getSurveys ()
  {
    return this->surveys_.get ();
  }

  void Monitoring::
  setSurveys (const SurveysType& x)
  {
    this->surveys_.set (x);
  }

  void Monitoring::
  setSurveys (::std::unique_ptr< SurveysType > x)
  {
    this->surveys_.set (std::move (x));
  }

  const Monitoring::AgeGroupType& Monitoring::
  getAgeGroup () const
  {
    return this->ageGroup_.get ();
  }

  Monitoring::AgeGroupType& Monitoring::
  getAgeGroup ()
  {
    return this->ageGroup_.get ();
  }

  void Monitoring::
  setAgeGroup (const AgeGroupType& x)
  {
    this->ageGroup_.set (x);
  }

  void Monitoring::
  setAgeGroup (::std::unique_ptr< AgeGroupType > x)
  {
    this->ageGroup_.set (std::move (x));
  }

  const Monitoring::CohortsOptional& Monitoring::
  getCohorts () const
  {
    return this->cohorts_;
  }

  Monitoring::CohortsOptional& Monitoring::
  getCohorts ()
  {
    return this->cohorts_;
  }

  void Monitoring::
  setCohorts (const CohortsType& x)
  {
    this->cohorts_.set (x);
  }

  void Monitoring::
  setCohorts (const CohortsOptional& x)
  {
    this->cohorts_ = x;
  }

  void Monitoring::
  setCohorts (::std::unique_ptr< CohortsType > x)
  {
    this->cohorts_.set (std::move (x));
  }

  const Monitoring::NameType& Monitoring::
  getName () const
  {
    return this->name_.get ();
  }

  Monitoring::NameType& Monitoring::
  getName ()
  {
    return this->name_.get ();
  }

  void Monitoring::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Monitoring::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const Monitoring::StartDateOptional& Monitoring::
  getStartDate () const
  {
    return this->startDate_;
  }

  Monitoring::StartDateOptional& Monitoring::
  getStartDate ()
  {
    return this->startDate_;
  }

  void Monitoring::
  setStartDate (const StartDateType& x)
  {
    this->startDate_.set (x);
  }

  void Monitoring::
  setStartDate (const StartDateOptional& x)
  {
    this->startDate_ = x;
  }

  void Monitoring::
  setStartDate (::std::unique_ptr< StartDateType > x)
  {
    this->startDate_.set (std::move (x));
  }


  // MonAgeGroup
  // 

  const MonAgeGroup::GroupSequence& MonAgeGroup::
  getGroup () const
  {
    return this->group_;
  }

  MonAgeGroup::GroupSequence& MonAgeGroup::
  getGroup ()
  {
    return this->group_;
  }

  void MonAgeGroup::
  setGroup (const GroupSequence& s)
  {
    this->group_ = s;
  }

  const MonAgeGroup::LowerboundType& MonAgeGroup::
  getLowerbound () const
  {
    return this->lowerbound_.get ();
  }

  MonAgeGroup::LowerboundType& MonAgeGroup::
  getLowerbound ()
  {
    return this->lowerbound_.get ();
  }

  void MonAgeGroup::
  setLowerbound (const LowerboundType& x)
  {
    this->lowerbound_.set (x);
  }


  // MonGroupBounds
  // 

  const MonGroupBounds::UpperboundType& MonGroupBounds::
  getUpperbound () const
  {
    return this->upperbound_.get ();
  }

  MonGroupBounds::UpperboundType& MonGroupBounds::
  getUpperbound ()
  {
    return this->upperbound_.get ();
  }

  void MonGroupBounds::
  setUpperbound (const UpperboundType& x)
  {
    this->upperbound_.set (x);
  }


  // Cohorts
  // 

  const Cohorts::SubPopSequence& Cohorts::
  getSubPop () const
  {
    return this->subPop_;
  }

  Cohorts::SubPopSequence& Cohorts::
  getSubPop ()
  {
    return this->subPop_;
  }

  void Cohorts::
  setSubPop (const SubPopSequence& s)
  {
    this->subPop_ = s;
  }


  // CohortSubPop
  // 

  const CohortSubPop::IdType& CohortSubPop::
  getId () const
  {
    return this->id_.get ();
  }

  CohortSubPop::IdType& CohortSubPop::
  getId ()
  {
    return this->id_.get ();
  }

  void CohortSubPop::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void CohortSubPop::
  setId (::std::unique_ptr< IdType > x)
  {
    this->id_.set (std::move (x));
  }

  const CohortSubPop::NumberType& CohortSubPop::
  getNumber () const
  {
    return this->number_.get ();
  }

  CohortSubPop::NumberType& CohortSubPop::
  getNumber ()
  {
    return this->number_.get ();
  }

  void CohortSubPop::
  setNumber (const NumberType& x)
  {
    this->number_.set (x);
  }


  // MonitoringOptions
  // 

  const MonitoringOptions::OptionSequence& MonitoringOptions::
  getOption () const
  {
    return this->option_;
  }

  MonitoringOptions::OptionSequence& MonitoringOptions::
  getOption ()
  {
    return this->option_;
  }

  void MonitoringOptions::
  setOption (const OptionSequence& s)
  {
    this->option_ = s;
  }

  const MonitoringOptions::OnlyNewEpisodeType& MonitoringOptions::
  getOnlyNewEpisode () const
  {
    return this->onlyNewEpisode_.get ();
  }

  MonitoringOptions::OnlyNewEpisodeType& MonitoringOptions::
  getOnlyNewEpisode ()
  {
    return this->onlyNewEpisode_.get ();
  }

  void MonitoringOptions::
  setOnlyNewEpisode (const OnlyNewEpisodeType& x)
  {
    this->onlyNewEpisode_.set (x);
  }

  MonitoringOptions::OnlyNewEpisodeType MonitoringOptions::
  getOnlyNewEpisodeDefaultValue ()
  {
    return OnlyNewEpisodeType (false);
  }


  // MonitoringOption
  // 

  const MonitoringOption::OutputNumberOptional& MonitoringOption::
  getOutputNumber () const
  {
    return this->outputNumber_;
  }

  MonitoringOption::OutputNumberOptional& MonitoringOption::
  getOutputNumber ()
  {
    return this->outputNumber_;
  }

  void MonitoringOption::
  setOutputNumber (const OutputNumberType& x)
  {
    this->outputNumber_.set (x);
  }

  void MonitoringOption::
  setOutputNumber (const OutputNumberOptional& x)
  {
    this->outputNumber_ = x;
  }

  const MonitoringOption::ByAgeOptional& MonitoringOption::
  getByAge () const
  {
    return this->byAge_;
  }

  MonitoringOption::ByAgeOptional& MonitoringOption::
  getByAge ()
  {
    return this->byAge_;
  }

  void MonitoringOption::
  setByAge (const ByAgeType& x)
  {
    this->byAge_.set (x);
  }

  void MonitoringOption::
  setByAge (const ByAgeOptional& x)
  {
    this->byAge_ = x;
  }

  const MonitoringOption::ByCohortOptional& MonitoringOption::
  getByCohort () const
  {
    return this->byCohort_;
  }

  MonitoringOption::ByCohortOptional& MonitoringOption::
  getByCohort ()
  {
    return this->byCohort_;
  }

  void MonitoringOption::
  setByCohort (const ByCohortType& x)
  {
    this->byCohort_.set (x);
  }

  void MonitoringOption::
  setByCohort (const ByCohortOptional& x)
  {
    this->byCohort_ = x;
  }

  const MonitoringOption::BySpeciesOptional& MonitoringOption::
  getBySpecies () const
  {
    return this->bySpecies_;
  }

  MonitoringOption::BySpeciesOptional& MonitoringOption::
  getBySpecies ()
  {
    return this->bySpecies_;
  }

  void MonitoringOption::
  setBySpecies (const BySpeciesType& x)
  {
    this->bySpecies_.set (x);
  }

  void MonitoringOption::
  setBySpecies (const BySpeciesOptional& x)
  {
    this->bySpecies_ = x;
  }

  const MonitoringOption::ByGenotypeOptional& MonitoringOption::
  getByGenotype () const
  {
    return this->byGenotype_;
  }

  MonitoringOption::ByGenotypeOptional& MonitoringOption::
  getByGenotype ()
  {
    return this->byGenotype_;
  }

  void MonitoringOption::
  setByGenotype (const ByGenotypeType& x)
  {
    this->byGenotype_.set (x);
  }

  void MonitoringOption::
  setByGenotype (const ByGenotypeOptional& x)
  {
    this->byGenotype_ = x;
  }

  const MonitoringOption::ByDrugTypeOptional& MonitoringOption::
  getByDrugType () const
  {
    return this->byDrugType_;
  }

  MonitoringOption::ByDrugTypeOptional& MonitoringOption::
  getByDrugType ()
  {
    return this->byDrugType_;
  }

  void MonitoringOption::
  setByDrugType (const ByDrugTypeType& x)
  {
    this->byDrugType_.set (x);
  }

  void MonitoringOption::
  setByDrugType (const ByDrugTypeOptional& x)
  {
    this->byDrugType_ = x;
  }


  // Continuous
  // 

  const Continuous::PeriodType& Continuous::
  getPeriod () const
  {
    return this->period_.get ();
  }

  Continuous::PeriodType& Continuous::
  getPeriod ()
  {
    return this->period_.get ();
  }

  void Continuous::
  setPeriod (const PeriodType& x)
  {
    this->period_.set (x);
  }

  void Continuous::
  setPeriod (::std::unique_ptr< PeriodType > x)
  {
    this->period_.set (std::move (x));
  }

  const Continuous::DuringInitOptional& Continuous::
  getDuringInit () const
  {
    return this->duringInit_;
  }

  Continuous::DuringInitOptional& Continuous::
  getDuringInit ()
  {
    return this->duringInit_;
  }

  void Continuous::
  setDuringInit (const DuringInitType& x)
  {
    this->duringInit_.set (x);
  }

  void Continuous::
  setDuringInit (const DuringInitOptional& x)
  {
    this->duringInit_ = x;
  }


  // Surveys
  // 

  const Surveys::SurveyTimeSequence& Surveys::
  getSurveyTime () const
  {
    return this->surveyTime_;
  }

  Surveys::SurveyTimeSequence& Surveys::
  getSurveyTime ()
  {
    return this->surveyTime_;
  }

  void Surveys::
  setSurveyTime (const SurveyTimeSequence& s)
  {
    this->surveyTime_ = s;
  }

  const Surveys::DetectionLimitOptional& Surveys::
  getDetectionLimit () const
  {
    return this->detectionLimit_;
  }

  Surveys::DetectionLimitOptional& Surveys::
  getDetectionLimit ()
  {
    return this->detectionLimit_;
  }

  void Surveys::
  setDetectionLimit (const DetectionLimitType& x)
  {
    this->detectionLimit_.set (x);
  }

  void Surveys::
  setDetectionLimit (const DetectionLimitOptional& x)
  {
    this->detectionLimit_ = x;
  }

  const Surveys::DiagnosticOptional& Surveys::
  getDiagnostic () const
  {
    return this->diagnostic_;
  }

  Surveys::DiagnosticOptional& Surveys::
  getDiagnostic ()
  {
    return this->diagnostic_;
  }

  void Surveys::
  setDiagnostic (const DiagnosticType& x)
  {
    this->diagnostic_.set (x);
  }

  void Surveys::
  setDiagnostic (const DiagnosticOptional& x)
  {
    this->diagnostic_ = x;
  }

  void Surveys::
  setDiagnostic (::std::unique_ptr< DiagnosticType > x)
  {
    this->diagnostic_.set (std::move (x));
  }


  // SurveyTime
  // 

  const SurveyTime::RepeatStepOptional& SurveyTime::
  getRepeatStep () const
  {
    return this->repeatStep_;
  }

  SurveyTime::RepeatStepOptional& SurveyTime::
  getRepeatStep ()
  {
    return this->repeatStep_;
  }

  void SurveyTime::
  setRepeatStep (const RepeatStepType& x)
  {
    this->repeatStep_.set (x);
  }

  void SurveyTime::
  setRepeatStep (const RepeatStepOptional& x)
  {
    this->repeatStep_ = x;
  }

  void SurveyTime::
  setRepeatStep (::std::unique_ptr< RepeatStepType > x)
  {
    this->repeatStep_.set (std::move (x));
  }

  const SurveyTime::RepeatEndOptional& SurveyTime::
  getRepeatEnd () const
  {
    return this->repeatEnd_;
  }

  SurveyTime::RepeatEndOptional& SurveyTime::
  getRepeatEnd ()
  {
    return this->repeatEnd_;
  }

  void SurveyTime::
  setRepeatEnd (const RepeatEndType& x)
  {
    this->repeatEnd_.set (x);
  }

  void SurveyTime::
  setRepeatEnd (const RepeatEndOptional& x)
  {
    this->repeatEnd_ = x;
  }

  void SurveyTime::
  setRepeatEnd (::std::unique_ptr< RepeatEndType > x)
  {
    this->repeatEnd_.set (std::move (x));
  }

  const SurveyTime::ReportedType& SurveyTime::
  getReported () const
  {
    return this->reported_.get ();
  }

  SurveyTime::ReportedType& SurveyTime::
  getReported ()
  {
    return this->reported_.get ();
  }

  void SurveyTime::
  setReported (const ReportedType& x)
  {
    this->reported_.set (x);
  }

  SurveyTime::ReportedType SurveyTime::
  getReportedDefaultValue ()
  {
    return ReportedType (true);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace scnXml
{
  // Monitoring
  //

  Monitoring::
  Monitoring (const SurveyOptionsType& SurveyOptions,
              const SurveysType& surveys,
              const AgeGroupType& ageGroup,
              const NameType& name)
  : ::xml_schema::Type (),
    continuous_ (this),
    SurveyOptions_ (SurveyOptions, this),
    surveys_ (surveys, this),
    ageGroup_ (ageGroup, this),
    cohorts_ (this),
    name_ (name, this),
    startDate_ (this)
  {
  }

  Monitoring::
  Monitoring (::std::unique_ptr< SurveyOptionsType > SurveyOptions,
              ::std::unique_ptr< SurveysType > surveys,
              ::std::unique_ptr< AgeGroupType > ageGroup,
              const NameType& name)
  : ::xml_schema::Type (),
    continuous_ (this),
    SurveyOptions_ (std::move (SurveyOptions), this),
    surveys_ (std::move (surveys), this),
    ageGroup_ (std::move (ageGroup), this),
    cohorts_ (this),
    name_ (name, this),
    startDate_ (this)
  {
  }

  Monitoring::
  Monitoring (const Monitoring& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    continuous_ (x.continuous_, f, this),
    SurveyOptions_ (x.SurveyOptions_, f, this),
    surveys_ (x.surveys_, f, this),
    ageGroup_ (x.ageGroup_, f, this),
    cohorts_ (x.cohorts_, f, this),
    name_ (x.name_, f, this),
    startDate_ (x.startDate_, f, this)
  {
  }

  Monitoring::
  Monitoring (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    continuous_ (this),
    SurveyOptions_ (this),
    surveys_ (this),
    ageGroup_ (this),
    cohorts_ (this),
    name_ (this),
    startDate_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Monitoring::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // continuous
      //
      if (n.name () == "continuous" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ContinuousType > r (
          ContinuousTraits::create (i, f, this));

        if (!this->continuous_)
        {
          this->continuous_.set (::std::move (r));
          continue;
        }
      }

      // SurveyOptions
      //
      if (n.name () == "SurveyOptions" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SurveyOptionsType > r (
          SurveyOptionsTraits::create (i, f, this));

        if (!SurveyOptions_.present ())
        {
          this->SurveyOptions_.set (::std::move (r));
          continue;
        }
      }

      // surveys
      //
      if (n.name () == "surveys" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SurveysType > r (
          SurveysTraits::create (i, f, this));

        if (!surveys_.present ())
        {
          this->surveys_.set (::std::move (r));
          continue;
        }
      }

      // ageGroup
      //
      if (n.name () == "ageGroup" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AgeGroupType > r (
          AgeGroupTraits::create (i, f, this));

        if (!ageGroup_.present ())
        {
          this->ageGroup_.set (::std::move (r));
          continue;
        }
      }

      // cohorts
      //
      if (n.name () == "cohorts" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< CohortsType > r (
          CohortsTraits::create (i, f, this));

        if (!this->cohorts_)
        {
          this->cohorts_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!SurveyOptions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "SurveyOptions",
        "");
    }

    if (!surveys_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "surveys",
        "");
    }

    if (!ageGroup_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ageGroup",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "startDate" && n.namespace_ ().empty ())
      {
        this->startDate_.set (StartDateTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  Monitoring* Monitoring::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Monitoring (*this, f, c);
  }

  Monitoring& Monitoring::
  operator= (const Monitoring& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->continuous_ = x.continuous_;
      this->SurveyOptions_ = x.SurveyOptions_;
      this->surveys_ = x.surveys_;
      this->ageGroup_ = x.ageGroup_;
      this->cohorts_ = x.cohorts_;
      this->name_ = x.name_;
      this->startDate_ = x.startDate_;
    }

    return *this;
  }

  Monitoring::
  ~Monitoring ()
  {
  }

  // MonAgeGroup
  //

  MonAgeGroup::
  MonAgeGroup (const LowerboundType& lowerbound)
  : ::xml_schema::Type (),
    group_ (this),
    lowerbound_ (lowerbound, this)
  {
  }

  MonAgeGroup::
  MonAgeGroup (const MonAgeGroup& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    group_ (x.group_, f, this),
    lowerbound_ (x.lowerbound_, f, this)
  {
  }

  MonAgeGroup::
  MonAgeGroup (const xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    group_ (this),
    lowerbound_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MonAgeGroup::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // group
      //
      if (n.name () == "group" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< GroupType > r (
          GroupTraits::create (i, f, this));

        this->group_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lowerbound" && n.namespace_ ().empty ())
      {
        this->lowerbound_.set (LowerboundTraits::create (i, f, this));
        continue;
      }
    }

    if (!lowerbound_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lowerbound",
        "");
    }
  }

  MonAgeGroup* MonAgeGroup::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MonAgeGroup (*this, f, c);
  }

  MonAgeGroup& MonAgeGroup::
  operator= (const MonAgeGroup& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->group_ = x.group_;
      this->lowerbound_ = x.lowerbound_;
    }

    return *this;
  }

  MonAgeGroup::
  ~MonAgeGroup ()
  {
  }

  // MonGroupBounds
  //

  MonGroupBounds::
  MonGroupBounds (const UpperboundType& upperbound)
  : ::xml_schema::Type (),
    upperbound_ (upperbound, this)
  {
  }

  MonGroupBounds::
  MonGroupBounds (const MonGroupBounds& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    upperbound_ (x.upperbound_, f, this)
  {
  }

  MonGroupBounds::
  MonGroupBounds (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    upperbound_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void MonGroupBounds::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "upperbound" && n.namespace_ ().empty ())
      {
        this->upperbound_.set (UpperboundTraits::create (i, f, this));
        continue;
      }
    }

    if (!upperbound_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "upperbound",
        "");
    }
  }

  MonGroupBounds* MonGroupBounds::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MonGroupBounds (*this, f, c);
  }

  MonGroupBounds& MonGroupBounds::
  operator= (const MonGroupBounds& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->upperbound_ = x.upperbound_;
    }

    return *this;
  }

  MonGroupBounds::
  ~MonGroupBounds ()
  {
  }

  // Cohorts
  //

  Cohorts::
  Cohorts ()
  : ::xml_schema::Type (),
    subPop_ (this)
  {
  }

  Cohorts::
  Cohorts (const Cohorts& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    subPop_ (x.subPop_, f, this)
  {
  }

  Cohorts::
  Cohorts (const xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    subPop_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Cohorts::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // subPop
      //
      if (n.name () == "subPop" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SubPopType > r (
          SubPopTraits::create (i, f, this));

        this->subPop_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Cohorts* Cohorts::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Cohorts (*this, f, c);
  }

  Cohorts& Cohorts::
  operator= (const Cohorts& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->subPop_ = x.subPop_;
    }

    return *this;
  }

  Cohorts::
  ~Cohorts ()
  {
  }

  // CohortSubPop
  //

  CohortSubPop::
  CohortSubPop (const IdType& id,
                const NumberType& number)
  : ::xml_schema::Type (),
    id_ (id, this),
    number_ (number, this)
  {
  }

  CohortSubPop::
  CohortSubPop (const CohortSubPop& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    id_ (x.id_, f, this),
    number_ (x.number_, f, this)
  {
  }

  CohortSubPop::
  CohortSubPop (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    id_ (this),
    number_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CohortSubPop::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (IdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (NumberTraits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "number",
        "");
    }
  }

  CohortSubPop* CohortSubPop::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CohortSubPop (*this, f, c);
  }

  CohortSubPop& CohortSubPop::
  operator= (const CohortSubPop& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->id_ = x.id_;
      this->number_ = x.number_;
    }

    return *this;
  }

  CohortSubPop::
  ~CohortSubPop ()
  {
  }

  // MonitoringOptions
  //

  MonitoringOptions::
  MonitoringOptions ()
  : ::xml_schema::Type (),
    option_ (this),
    onlyNewEpisode_ (getOnlyNewEpisodeDefaultValue (), this)
  {
  }

  MonitoringOptions::
  MonitoringOptions (const MonitoringOptions& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    option_ (x.option_, f, this),
    onlyNewEpisode_ (x.onlyNewEpisode_, f, this)
  {
  }

  MonitoringOptions::
  MonitoringOptions (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    option_ (this),
    onlyNewEpisode_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MonitoringOptions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // option
      //
      if (n.name () == "option" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< OptionType > r (
          OptionTraits::create (i, f, this));

        this->option_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "onlyNewEpisode" && n.namespace_ ().empty ())
      {
        this->onlyNewEpisode_.set (OnlyNewEpisodeTraits::create (i, f, this));
        continue;
      }
    }

    if (!onlyNewEpisode_.present ())
    {
      this->onlyNewEpisode_.set (getOnlyNewEpisodeDefaultValue ());
    }
  }

  MonitoringOptions* MonitoringOptions::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MonitoringOptions (*this, f, c);
  }

  MonitoringOptions& MonitoringOptions::
  operator= (const MonitoringOptions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->option_ = x.option_;
      this->onlyNewEpisode_ = x.onlyNewEpisode_;
    }

    return *this;
  }

  MonitoringOptions::
  ~MonitoringOptions ()
  {
  }

  // MonitoringOption
  //

  MonitoringOption::
  MonitoringOption (const NameType& name)
  : ::scnXml::Option (name),
    outputNumber_ (this),
    byAge_ (this),
    byCohort_ (this),
    bySpecies_ (this),
    byGenotype_ (this),
    byDrugType_ (this)
  {
  }

  MonitoringOption::
  MonitoringOption (const MonitoringOption& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::scnXml::Option (x, f, c),
    outputNumber_ (x.outputNumber_, f, this),
    byAge_ (x.byAge_, f, this),
    byCohort_ (x.byCohort_, f, this),
    bySpecies_ (x.bySpecies_, f, this),
    byGenotype_ (x.byGenotype_, f, this),
    byDrugType_ (x.byDrugType_, f, this)
  {
  }

  MonitoringOption::
  MonitoringOption (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::scnXml::Option (e, f | ::xml_schema::Flags::base, c),
    outputNumber_ (this),
    byAge_ (this),
    byCohort_ (this),
    bySpecies_ (this),
    byGenotype_ (this),
    byDrugType_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void MonitoringOption::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::Option::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "outputNumber" && n.namespace_ ().empty ())
      {
        this->outputNumber_.set (OutputNumberTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "byAge" && n.namespace_ ().empty ())
      {
        this->byAge_.set (ByAgeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "byCohort" && n.namespace_ ().empty ())
      {
        this->byCohort_.set (ByCohortTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "bySpecies" && n.namespace_ ().empty ())
      {
        this->bySpecies_.set (BySpeciesTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "byGenotype" && n.namespace_ ().empty ())
      {
        this->byGenotype_.set (ByGenotypeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "byDrugType" && n.namespace_ ().empty ())
      {
        this->byDrugType_.set (ByDrugTypeTraits::create (i, f, this));
        continue;
      }
    }
  }

  MonitoringOption* MonitoringOption::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MonitoringOption (*this, f, c);
  }

  MonitoringOption& MonitoringOption::
  operator= (const MonitoringOption& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::Option& > (*this) = x;
      this->outputNumber_ = x.outputNumber_;
      this->byAge_ = x.byAge_;
      this->byCohort_ = x.byCohort_;
      this->bySpecies_ = x.bySpecies_;
      this->byGenotype_ = x.byGenotype_;
      this->byDrugType_ = x.byDrugType_;
    }

    return *this;
  }

  MonitoringOption::
  ~MonitoringOption ()
  {
  }

  // Continuous
  //

  Continuous::
  Continuous (const PeriodType& period)
  : ::scnXml::OptionSet (),
    period_ (period, this),
    duringInit_ (this)
  {
  }

  Continuous::
  Continuous (const Continuous& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::scnXml::OptionSet (x, f, c),
    period_ (x.period_, f, this),
    duringInit_ (x.duringInit_, f, this)
  {
  }

  Continuous::
  Continuous (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::scnXml::OptionSet (e, f | ::xml_schema::Flags::base, c),
    period_ (this),
    duringInit_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Continuous::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::OptionSet::parse (p, f);

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        this->period_.set (PeriodTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "duringInit" && n.namespace_ ().empty ())
      {
        this->duringInit_.set (DuringInitTraits::create (i, f, this));
        continue;
      }
    }

    if (!period_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "period",
        "");
    }
  }

  Continuous* Continuous::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Continuous (*this, f, c);
  }

  Continuous& Continuous::
  operator= (const Continuous& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::OptionSet& > (*this) = x;
      this->period_ = x.period_;
      this->duringInit_ = x.duringInit_;
    }

    return *this;
  }

  Continuous::
  ~Continuous ()
  {
  }

  // Surveys
  //

  Surveys::
  Surveys ()
  : ::xml_schema::Type (),
    surveyTime_ (this),
    detectionLimit_ (this),
    diagnostic_ (this)
  {
  }

  Surveys::
  Surveys (const Surveys& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    surveyTime_ (x.surveyTime_, f, this),
    detectionLimit_ (x.detectionLimit_, f, this),
    diagnostic_ (x.diagnostic_, f, this)
  {
  }

  Surveys::
  Surveys (const xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    surveyTime_ (this),
    detectionLimit_ (this),
    diagnostic_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Surveys::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // surveyTime
      //
      if (n.name () == "surveyTime" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SurveyTimeType > r (
          SurveyTimeTraits::create (i, f, this));

        this->surveyTime_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "detectionLimit" && n.namespace_ ().empty ())
      {
        this->detectionLimit_.set (DetectionLimitTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "diagnostic" && n.namespace_ ().empty ())
      {
        this->diagnostic_.set (DiagnosticTraits::create (i, f, this));
        continue;
      }
    }
  }

  Surveys* Surveys::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Surveys (*this, f, c);
  }

  Surveys& Surveys::
  operator= (const Surveys& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->surveyTime_ = x.surveyTime_;
      this->detectionLimit_ = x.detectionLimit_;
      this->diagnostic_ = x.diagnostic_;
    }

    return *this;
  }

  Surveys::
  ~Surveys ()
  {
  }

  // SurveyTime
  //

  SurveyTime::
  SurveyTime ()
  : ::xml_schema::String (),
    repeatStep_ (this),
    repeatEnd_ (this),
    reported_ (getReportedDefaultValue (), this)
  {
  }

  SurveyTime::
  SurveyTime (const char* _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    repeatStep_ (this),
    repeatEnd_ (this),
    reported_ (getReportedDefaultValue (), this)
  {
  }

  SurveyTime::
  SurveyTime (const ::std::string& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    repeatStep_ (this),
    repeatEnd_ (this),
    reported_ (getReportedDefaultValue (), this)
  {
  }

  SurveyTime::
  SurveyTime (const ::xml_schema::String& _xsd_String_base)
  : ::xml_schema::String (_xsd_String_base),
    repeatStep_ (this),
    repeatEnd_ (this),
    reported_ (getReportedDefaultValue (), this)
  {
  }

  SurveyTime::
  SurveyTime (const SurveyTime& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (x, f, c),
    repeatStep_ (x.repeatStep_, f, this),
    repeatEnd_ (x.repeatEnd_, f, this),
    reported_ (x.reported_, f, this)
  {
  }

  SurveyTime::
  SurveyTime (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::String (e, f | ::xml_schema::Flags::base, c),
    repeatStep_ (this),
    repeatEnd_ (this),
    reported_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SurveyTime::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "repeatStep" && n.namespace_ ().empty ())
      {
        this->repeatStep_.set (RepeatStepTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "repeatEnd" && n.namespace_ ().empty ())
      {
        this->repeatEnd_.set (RepeatEndTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "reported" && n.namespace_ ().empty ())
      {
        this->reported_.set (ReportedTraits::create (i, f, this));
        continue;
      }
    }

    if (!reported_.present ())
    {
      this->reported_.set (getReportedDefaultValue ());
    }
  }

  SurveyTime* SurveyTime::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SurveyTime (*this, f, c);
  }

  SurveyTime& SurveyTime::
  operator= (const SurveyTime& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::String& > (*this) = x;
      this->repeatStep_ = x.repeatStep_;
      this->repeatEnd_ = x.repeatEnd_;
      this->reported_ = x.reported_;
    }

    return *this;
  }

  SurveyTime::
  ~SurveyTime ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace scnXml
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


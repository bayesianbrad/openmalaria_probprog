// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from interventions.xsd.
 */

#ifndef CXX_CODE_OPENMALARIA_SCHEMA_INTERVENTIONS_H
#define CXX_CODE_OPENMALARIA_SCHEMA_INTERVENTIONS_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type Type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type Container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char Byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char UnsignedByte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short Short;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short UnsignedShort;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int Int;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int UnsignedInt;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long Long;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long UnsignedLong;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long Integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long NonPositiveInteger;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long NonNegativeInteger;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long PositiveInteger;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long NegativeInteger;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool Boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float Float;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double Double;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double Decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, Token > Name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, Token > Language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > Buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone TimeZone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags Flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity Severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > Error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > Exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > Bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > Parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace scnXml
{
  class Interventions;
  class HumanInterventions;
  class HumanInterventionComponent;
  class SubPopRemoval;
  class Screen;
  class VectorIntervention;
  class VectorTrap;
  class TimedBase;
  class DeploymentBase;
  class MassDeployment;
  class ContinuousList;
  class ContinuousDeployment;
  class TimedBaseList;
  class MassListWithCum;
  class RestrictToSubPop;
  class VaccineDescription;
  class ITNDescription;
  class GVIDescription;
  class IRSDescription;
  class IRSDeterrency;
  class ITNEnteringDeterrencyLogit;
  class IRSKillingEffect;
  class ITNDeterrency;
  class ITNKillingEffect;
  class ITNEffectLogit;
  class VectorSpeciesIntervention;
  class ChangeHS;
  class ChangeEIR;
  class ImportedInfections;
  class InsertR_0Case;
  class UninfectVectors;
  class VectorPop;
  class VectorTrap1;
  class Deployment;
  class RecruitmentOnly;
  class ClearImmunity;
  class Description;
  class Description1;
  class Timed;
  class CumulativeCoverage;
  class AnophelesParams1;
  class AnophelesParams11;
  class AnophelesParams2;
  class SeekingDeathRateIncrease;
  class ProbDeathOvipositing;
  class EmergenceReduction;
  class TimedDeployment;
  class TimedDeployment1;
  class Timed1;
  class TimedDeployment2;
  class Condition;
  class Deploy1;
  class TwoStageDeterrency;
  class Rate;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "healthSystem.h"

#include "entomology.h"

#include "util.h"

/**
 * @brief C++ namespace for the %http://openmalaria.org/schema/scenario_39
 * schema namespace.
 */
namespace scnXml
{
  /**
   * @brief Class corresponding to the %Interventions schema type.
   *
   * @nosubgrouping
   */
  class Interventions: public ::xml_schema::Type
  {
    public:
    /**
     * @name changeHS
     *
     * @brief Accessor and modifier functions for the %changeHS
     * optional element.
     *
     * Changes to the health system
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ChangeHS ChangeHSType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ChangeHSType > ChangeHSOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ChangeHSType, char > ChangeHSTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ChangeHSOptional&
    getChangeHS () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ChangeHSOptional&
    getChangeHS ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setChangeHS (const ChangeHSType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setChangeHS (const ChangeHSOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setChangeHS (::std::unique_ptr< ChangeHSType > p);

    //@}

    /**
     * @name changeEIR
     *
     * @brief Accessor and modifier functions for the %changeEIR
     * optional element.
     *
     * New description of transmission level for models not
     * supporting vector control interventions. Use of this overrides
     * previous transmission levels such that human infectiousness no
     * longer has any feedback effect on transmission. Supplied EIR
     * data must last until end of simulation.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ChangeEIR ChangeEIRType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ChangeEIRType > ChangeEIROptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ChangeEIRType, char > ChangeEIRTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ChangeEIROptional&
    getChangeEIR () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ChangeEIROptional&
    getChangeEIR ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setChangeEIR (const ChangeEIRType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setChangeEIR (const ChangeEIROptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setChangeEIR (::std::unique_ptr< ChangeEIRType > p);

    //@}

    /**
     * @name importedInfections
     *
     * @brief Accessor and modifier functions for the %importedInfections
     * optional element.
     *
     * Models importation of P. falciparum infections directly into humans
     * from an external source. This is infections, not inoculations or
     * EIR being imported.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ImportedInfections ImportedInfectionsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ImportedInfectionsType > ImportedInfectionsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ImportedInfectionsType, char > ImportedInfectionsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ImportedInfectionsOptional&
    getImportedInfections () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ImportedInfectionsOptional&
    getImportedInfections ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setImportedInfections (const ImportedInfectionsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setImportedInfections (const ImportedInfectionsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setImportedInfections (::std::unique_ptr< ImportedInfectionsType > p);

    //@}

    /**
     * @name insertR_0Case
     *
     * @brief Accessor and modifier functions for the %insertR_0Case
     * optional element.
     *
     * Used to simulate R_0. First, infections should be eliminated,
     * immunity removed, and the population given an effective transmission-
     * blocking vaccine (not done by this intervention). Then this
     * intervention may be used to: pick one human, infect him, administer
     * a fully effective Preerythrocytic vaccine and remove
     * transmission-blocking vaccine effect on this human. Thus only this
     * one human will be a source of infections in an unprotected population,
     * and will not reinfected himself.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::InsertR_0Case InsertR_0CaseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InsertR_0CaseType > InsertR_0CaseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InsertR_0CaseType, char > InsertR_0CaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InsertR_0CaseOptional&
    getInsertR_0Case () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    InsertR_0CaseOptional&
    getInsertR_0Case ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInsertR_0Case (const InsertR_0CaseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setInsertR_0Case (const InsertR_0CaseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setInsertR_0Case (::std::unique_ptr< InsertR_0CaseType > p);

    //@}

    /**
     * @name uninfectVectors
     *
     * @brief Accessor and modifier functions for the %uninfectVectors
     * optional element.
     *
     * Removes all infections from mosquitoes -- resulting in zero EIR to
     * humans, until such time that mosquitoes are re-infected and become
     * infectious. Only efficacious in dynamic EIR mode (when changeEIR was
     * not used).
     * 
     * Hypothetical, but potentially useful to simulate a setting starting
     * from no infections, but with enough mosquitoes to reach a set
     * equilibrium of exposure.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::UninfectVectors UninfectVectorsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UninfectVectorsType > UninfectVectorsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UninfectVectorsType, char > UninfectVectorsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UninfectVectorsOptional&
    getUninfectVectors () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UninfectVectorsOptional&
    getUninfectVectors ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUninfectVectors (const UninfectVectorsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUninfectVectors (const UninfectVectorsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUninfectVectors (::std::unique_ptr< UninfectVectorsType > p);

    //@}

    /**
     * @name vectorPop
     *
     * @brief Accessor and modifier functions for the %vectorPop
     * optional element.
     *
     * A list of parameterisations of generic vector host-inspecific
     * interventions.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::VectorPop VectorPopType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< VectorPopType > VectorPopOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VectorPopType, char > VectorPopTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const VectorPopOptional&
    getVectorPop () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    VectorPopOptional&
    getVectorPop ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVectorPop (const VectorPopType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setVectorPop (const VectorPopOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setVectorPop (::std::unique_ptr< VectorPopType > p);

    //@}

    /**
     * @name vectorTrap
     *
     * @brief Accessor and modifier functions for the %vectorTrap
     * optional element.
     *
     * Traps attract and kill mosquitoes. They are modelled as a
     * non-human-host where the probability of mosquitoes surviving
     * feeding is zero (since otherwise the simulator would assume
     * surviving mosquitoes have had a blood meal), and where this
     * "host" is initially not present.
     * 
     * Model: each type of trap has has an initial availability
     * relative to a human and a decay in availability. Each
     * deployment has a fixed maximum lifespan, after which the
     * traps from that deployment are removed (it is up to the
     * user whether this is after availability is effectively zero
     * or sooner, either coinciding with a redeployment or
     * causing a reduction in overall effectiveness of traps).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::VectorTrap1 VectorTrapType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< VectorTrapType > VectorTrapOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< VectorTrapType, char > VectorTrapTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const VectorTrapOptional&
    getVectorTrap () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    VectorTrapOptional&
    getVectorTrap ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setVectorTrap (const VectorTrapType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setVectorTrap (const VectorTrapOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setVectorTrap (::std::unique_ptr< VectorTrapType > p);

    //@}

    /**
     * @name human
     *
     * @brief Accessor and modifier functions for the %human
     * optional element.
     *
     * Encapsulates all interventions whose effects are specific to the
     * human host: any interventions where target humans may be selected
     * via population-coverage, age limits and sub-population membership.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::HumanInterventions HumanType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HumanType > HumanOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HumanType, char > HumanTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HumanOptional&
    getHuman () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HumanOptional&
    getHuman ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHuman (const HumanType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHuman (const HumanOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHuman (::std::unique_ptr< HumanType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     *
     * Name of set of interventions
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Interventions (const NameType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Interventions (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Interventions (const Interventions& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Interventions*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Interventions&
    operator= (const Interventions& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Interventions ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ChangeHSOptional changeHS_;
    ChangeEIROptional changeEIR_;
    ImportedInfectionsOptional importedInfections_;
    InsertR_0CaseOptional insertR_0Case_;
    UninfectVectorsOptional uninfectVectors_;
    VectorPopOptional vectorPop_;
    VectorTrapOptional vectorTrap_;
    HumanOptional human_;
    ::xsd::cxx::tree::one< NameType > name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HumanInterventions schema type.
   *
   * @nosubgrouping
   */
  class HumanInterventions: public ::xml_schema::Type
  {
    public:
    /**
     * @name component
     *
     * @brief Accessor and modifier functions for the %component
     * sequence element.
     *
     * A parameterisation of an effect achieved by one component of an
     * intervention. (An intervention is described as the effects of a set
     * of components plus deployments of those components. This describes
     * the components individually, not deployments or which components
     * comprise an intervention.)
     * 
     * Each element describes one component: its effects, decay of the(se)
     * effect(s), and related stuff (e.g. description of indirect decay
     * and of usage levels).
     * 
     * Different interventions can deploy the same component to the same
     * perso. In most cases this will just deploy a fresh instance (e.g. a
     * new bed net will replace the old (nobody uses multiple bed nets),
     * or a new drug dose will act on top of previous doses, or in the
     * case of a vaccine, effect depends on the total number of previous
     * inoculations (including from other interventions).
     * 
     * Where multiple components of the same type (but with different ids)
     * are deployed (whether within a single intervention or by multiple
     * interventions), they act independently (e.g. two bed nets deployed
     * to a single host would act to reduce attractiveness or survival of
     * mosquitoes biting that host twice ? this may be useful to simulate
     * some novel vector intervention since the two nets may have separate
     * parameters).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::HumanInterventionComponent ComponentType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ComponentType > ComponentSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< ComponentType >::iterator ComponentIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< ComponentType >::const_iterator ComponentConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComponentType, char > ComponentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ComponentSequence&
    getComponent () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ComponentSequence&
    getComponent ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setComponent (const ComponentSequence& s);

    //@}

    /**
     * @name deployment
     *
     * @brief Accessor and modifier functions for the %deployment
     * sequence element.
     *
     * This element describes deployment of an intervention: which
     * components are deployed, how humans are selected for deployment
     * (via timed or age-based deployment) as well as a few additional
     * restrictions (e.g. vaccine dosing restrictions).
     * 
     * All components deployed by this intervention are deployed to the
     * same people (each timed or continuous deployment selects recipients
     * and then gives each recipient all components of the intervention).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Deployment DeploymentType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DeploymentType > DeploymentSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeploymentType >::iterator DeploymentIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeploymentType >::const_iterator DeploymentConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeploymentType, char > DeploymentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DeploymentSequence&
    getDeployment () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DeploymentSequence&
    getDeployment ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDeployment (const DeploymentSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HumanInterventions ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HumanInterventions (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HumanInterventions (const HumanInterventions& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HumanInterventions*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HumanInterventions&
    operator= (const HumanInterventions& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HumanInterventions ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ComponentSequence component_;
    DeploymentSequence deployment_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HumanInterventionComponent schema type.
   *
   * @nosubgrouping
   */
  class HumanInterventionComponent: public ::xml_schema::Type
  {
    public:
    /**
     * @name screen
     *
     * @brief Accessor and modifier functions for the %screen
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Screen ScreenType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ScreenType > ScreenOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ScreenType, char > ScreenTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ScreenOptional&
    getScreen () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ScreenOptional&
    getScreen ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setScreen (const ScreenType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setScreen (const ScreenOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setScreen (::std::unique_ptr< ScreenType > p);

    //@}

    /**
     * @name treatSimple
     *
     * @brief Accessor and modifier functions for the %treatSimple
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTTreatSimple TreatSimpleType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TreatSimpleType > TreatSimpleOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreatSimpleType, char > TreatSimpleTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TreatSimpleOptional&
    getTreatSimple () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TreatSimpleOptional&
    getTreatSimple ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreatSimple (const TreatSimpleType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTreatSimple (const TreatSimpleOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTreatSimple (::std::unique_ptr< TreatSimpleType > p);

    //@}

    /**
     * @name treatPKPD
     *
     * @brief Accessor and modifier functions for the %treatPKPD
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTTreatPKPD TreatPKPDType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TreatPKPDType > TreatPKPDOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreatPKPDType, char > TreatPKPDTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TreatPKPDOptional&
    getTreatPKPD () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TreatPKPDOptional&
    getTreatPKPD ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreatPKPD (const TreatPKPDType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTreatPKPD (const TreatPKPDOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTreatPKPD (::std::unique_ptr< TreatPKPDType > p);

    //@}

    /**
     * @name decisionTree
     *
     * @brief Accessor and modifier functions for the %decisionTree
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecisionTree DecisionTreeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DecisionTreeType > DecisionTreeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DecisionTreeType, char > DecisionTreeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DecisionTreeOptional&
    getDecisionTree () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DecisionTreeOptional&
    getDecisionTree ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDecisionTree (const DecisionTreeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDecisionTree (const DecisionTreeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDecisionTree (::std::unique_ptr< DecisionTreeType > p);

    //@}

    /**
     * @name PEV
     *
     * @brief Accessor and modifier functions for the %PEV
     * optional element.
     *
     * Pre-erythrocytic vaccine (PEV): prevents a proportion of infections
     * from commencing.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::VaccineDescription PEVType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PEVType > PEVOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PEVType, char > PEVTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PEVOptional&
    getPEV () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PEVOptional&
    getPEV ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPEV (const PEVType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPEV (const PEVOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPEV (::std::unique_ptr< PEVType > p);

    //@}

    /**
     * @name BSV
     *
     * @brief Accessor and modifier functions for the %BSV
     * optional element.
     *
     * Blood-stage vaccine (BSV): acts as a killing factor on blood-stage
     * parasites. Exact action depends on the within host model.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::VaccineDescription BSVType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BSVType > BSVOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< BSVType, char > BSVTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BSVOptional&
    getBSV () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    BSVOptional&
    getBSV ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setBSV (const BSVType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setBSV (const BSVOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBSV (::std::unique_ptr< BSVType > p);

    //@}

    /**
     * @name TBV
     *
     * @brief Accessor and modifier functions for the %TBV
     * optional element.
     *
     * Transmission-blocking vaccine (TBV): one minus this scales the
     * probability of transmission to mosquitoes
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::VaccineDescription TBVType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TBVType > TBVOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TBVType, char > TBVTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TBVOptional&
    getTBV () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TBVOptional&
    getTBV ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTBV (const TBVType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTBV (const TBVOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTBV (::std::unique_ptr< TBVType > p);

    //@}

    /**
     * @name ITN
     *
     * @brief Accessor and modifier functions for the %ITN
     * optional element.
     *
     * Description of bed-net interventions (ITNs, LLINs).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ITNDescription ITNType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ITNType > ITNOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ITNType, char > ITNTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ITNOptional&
    getITN () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ITNOptional&
    getITN ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setITN (const ITNType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setITN (const ITNOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setITN (::std::unique_ptr< ITNType > p);

    //@}

    /**
     * @name IRS
     *
     * @brief Accessor and modifier functions for the %IRS
     * optional element.
     *
     * Description of indoor residual spraying interventions.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::IRSDescription IRSType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IRSType > IRSOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IRSType, char > IRSTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IRSOptional&
    getIRS () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    IRSOptional&
    getIRS ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIRS (const IRSType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setIRS (const IRSOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setIRS (::std::unique_ptr< IRSType > p);

    //@}

    /**
     * @name GVI
     *
     * @brief Accessor and modifier functions for the %GVI
     * optional element.
     *
     * Low-level description of intervention effects on vectors (i.e.
     * mosquitoes). Can be used to describe simple ITN or IRS
     * interventions (though more complex models are available for these
     * interventions) or other interventions such as mosquito repellant
     * or ivermectin.
     * 
     * Note that all actions of this intervention component will decay
     * according to a single decay function. If independant decay is
     * wanted, a separate component can be used for each action.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::GVIDescription GVIType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< GVIType > GVIOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< GVIType, char > GVITraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const GVIOptional&
    getGVI () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    GVIOptional&
    getGVI ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setGVI (const GVIType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setGVI (const GVIOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setGVI (::std::unique_ptr< GVIType > p);

    //@}

    /**
     * @name recruitmentOnly
     *
     * @brief Accessor and modifier functions for the %recruitmentOnly
     * optional element.
     *
     * Recruitment of a host into a sub-population.
     * 
     * All human-targeting intervention deployments recruit simulated
     * humans into a sub-population which can be used for the purposes
     * of cumulative deployment, deployment only to a sub-population and
     * defining a cohort. This pseudo-intervention can be used to define
     * a sub-population without also deploying some intervention.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::RecruitmentOnly RecruitmentOnlyType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RecruitmentOnlyType > RecruitmentOnlyOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RecruitmentOnlyType, char > RecruitmentOnlyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RecruitmentOnlyOptional&
    getRecruitmentOnly () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RecruitmentOnlyOptional&
    getRecruitmentOnly ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRecruitmentOnly (const RecruitmentOnlyType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRecruitmentOnly (const RecruitmentOnlyOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRecruitmentOnly (::std::unique_ptr< RecruitmentOnlyType > p);

    //@}

    /**
     * @name clearImmunity
     *
     * @brief Accessor and modifier functions for the %clearImmunity
     * optional element.
     *
     * Removes all exposure-related immunitsy gained over time by hosts
     * without removing infections (or affecting the ability to gain
     * immunity through exposure).
     * 
     * Hypothetical, but potentially useful to simulate scenarios with
     * unprotected humans.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ClearImmunity ClearImmunityType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ClearImmunityType > ClearImmunityOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ClearImmunityType, char > ClearImmunityTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ClearImmunityOptional&
    getClearImmunity () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ClearImmunityOptional&
    getClearImmunity ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setClearImmunity (const ClearImmunityType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setClearImmunity (const ClearImmunityOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setClearImmunity (::std::unique_ptr< ClearImmunityType > p);

    //@}

    /**
     * @name subPopRemoval
     *
     * @brief Accessor and modifier functions for the %subPopRemoval
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::SubPopRemoval SubPopRemovalType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SubPopRemovalType > SubPopRemovalOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SubPopRemovalType, char > SubPopRemovalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SubPopRemovalOptional&
    getSubPopRemoval () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SubPopRemovalOptional&
    getSubPopRemoval ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSubPopRemoval (const SubPopRemovalType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSubPopRemoval (const SubPopRemovalOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSubPopRemoval (::std::unique_ptr< SubPopRemovalType > p);

    //@}

    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     *
     * A short name or code identifying the intervention component
     * (used to refer to this component when describing an intervention).
     * Also the id of the sub-population defined as those hosts who have
     * received this intervention and who haven't subsequently been removed
     * from the sub-population.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::unique_ptr< IdType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * An informal name/description for the component
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HumanInterventionComponent (const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HumanInterventionComponent (const xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HumanInterventionComponent (const HumanInterventionComponent& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HumanInterventionComponent*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HumanInterventionComponent&
    operator= (const HumanInterventionComponent& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HumanInterventionComponent ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ScreenOptional screen_;
    TreatSimpleOptional treatSimple_;
    TreatPKPDOptional treatPKPD_;
    DecisionTreeOptional decisionTree_;
    PEVOptional PEV_;
    BSVOptional BSV_;
    TBVOptional TBV_;
    ITNOptional ITN_;
    IRSOptional IRS_;
    GVIOptional GVI_;
    RecruitmentOnlyOptional recruitmentOnly_;
    ClearImmunityOptional clearImmunity_;
    SubPopRemovalOptional subPopRemoval_;
    ::xsd::cxx::tree::one< IdType > id_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SubPopRemoval schema type.
   *
   * Each human intervention component corresponds to a sub-population:
   * those who have received or are considered to be protected by the
   * intervention component. Humans automatically become members of this
   * sub-population when receiving an intervention component; this element
   * controls how humans are removed from the sub-population.
   * 
   * ITN attrition also removes humans from sub-populations.
   * 
   * Note that sub-populations do not directly correspond to an
   * intervention's effects: lack of effectiveness does not imply removal
   * from the sub-population (except as explicitly configured here) and
   * removal from the sub-population does not halt an intervention's
   * effects.
   * 
   * Sub-populations may be used to define a cohort, to restrict deployment
   * of other interventions and to use cumulative deployment mode. A sub-
   * population may or may not correspond (roughly) to humans protected by
   * some intervention.
   *
   * @nosubgrouping
   */
  class SubPopRemoval: public ::xml_schema::Type
  {
    public:
    /**
     * @name onFirstBout
     *
     * @brief Accessor and modifier functions for the %onFirstBout
     * optional attribute with a default value.
     *
     * If true, remove individuals from the sub-population at the start of
     * the first episode (start of a clinical bout) since they were
     * recruited into the sub-population. This is intended for cohort
     * studies which measure time to the first episode, using active
     * case detection.
     * 
     * Reports delayed due to health-system memory are forced out when this
     * occurs. Note that this can increase the number of uncomplicated cases
     * reported across the entire population; for this reason reports are
     * not forced on recruitment or most removal options.
     * 
     * This does not prevent re-recruitment in the case that recruitment
     * settings could conceivably recruit the same individual twice.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean OnFirstBoutType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< OnFirstBoutType, char > OnFirstBoutTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const OnFirstBoutType&
    getOnFirstBout () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    OnFirstBoutType&
    getOnFirstBout ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setOnFirstBout (const OnFirstBoutType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static OnFirstBoutType
    getOnFirstBoutDefaultValue ();

    //@}

    /**
     * @name onFirstTreatment
     *
     * @brief Accessor and modifier functions for the %onFirstTreatment
     * optional attribute with a default value.
     *
     * If true, remove individuals from the sub-population when they first
     * seektreatment since they were recruited into the sub-population. This
     * is intended for cohort studies which measure the time to first
     * episode, using passive case detection.
     * 
     * Reports delayed due to health-system memory are forced out when this
     * occurs. Note that this can increase the number of uncomplicated cases
     * reported across the entire population; for this reason reports are
     * not forced on recruitment or most removal options.
     * 
     * This does not prevent re-recruitment in the case that recruitment
     * settings could conceivably recruit the same individual twice.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean OnFirstTreatmentType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< OnFirstTreatmentType, char > OnFirstTreatmentTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const OnFirstTreatmentType&
    getOnFirstTreatment () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    OnFirstTreatmentType&
    getOnFirstTreatment ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setOnFirstTreatment (const OnFirstTreatmentType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static OnFirstTreatmentType
    getOnFirstTreatmentDefaultValue ();

    //@}

    /**
     * @name onFirstInfection
     *
     * @brief Accessor and modifier functions for the %onFirstInfection
     * optional attribute with a default value.
     *
     * If true, remove individuals from the sub-population at completion of
     * the first survey in which they present with a patent infection since
     * they were recruited into the sub-population. This intended for cohort
     * studies which measure time to the first infection, using active
     * case detection.
     * 
     * Reports delayed due to health-system memory are forced out when this
     * occurs. Note that this can increase the number of uncomplicated cases
     * reported across the entire population; for this reason reports are
     * not forced on recruitment or most removal options.
     * 
     * This does not prevent re-recruitment in the case that recruitment
     * settings could
     * conceivably recruit the same individual twice.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean OnFirstInfectionType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< OnFirstInfectionType, char > OnFirstInfectionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const OnFirstInfectionType&
    getOnFirstInfection () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    OnFirstInfectionType&
    getOnFirstInfection ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setOnFirstInfection (const OnFirstInfectionType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static OnFirstInfectionType
    getOnFirstInfectionDefaultValue ();

    //@}

    /**
     * @name afterYears
     *
     * @brief Accessor and modifier functions for the %afterYears
     * optional attribute.
     *
     * If given, membership to the sub-population of humans who have
     * received this intervention component expires after the given number of
     * years. Note that future deployments renew membership (e.g. if this
     * parameter is 4 years and the intervention is redeployed 3 years from
     * now, expiry happens after 7 years).
     * 
     * This provides a crude way of modelling a cohort protected by some
     * intervention. A few interventions provide more detailed ways of
     * modelling expiry of protection. In any case, "expiry of protection"
     * is an abstract concept and does not imply that all protection has
     * ceased, even in the simulator.
     * 
     * This may also be useful for cumulative deployment.
     * 
     * Minimum duration is zero, which implies the human is effectively
     * never a member of the sub-population; a duration of one timestep
     * implies the human is a member of the sub-population while any futher
     * interventions are deployed on the same time as this human becomes a
     * member and on the next update of the human (including transmission
     * and health system events) but not beyond that. If this attribute is
     * not given, the simulated human is a member until death or some other
     * option triggers removal.
     * 
     * Input is rounded to the nearest time step.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double AfterYearsType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AfterYearsType > AfterYearsOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< AfterYearsType, char, ::xsd::cxx::tree::schema_type::double_ > AfterYearsTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AfterYearsOptional&
    getAfterYears () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    AfterYearsOptional&
    getAfterYears ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setAfterYears (const AfterYearsType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setAfterYears (const AfterYearsOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SubPopRemoval ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SubPopRemoval (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SubPopRemoval (const SubPopRemoval& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SubPopRemoval*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SubPopRemoval&
    operator= (const SubPopRemoval& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SubPopRemoval ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< OnFirstBoutType > onFirstBout_;
    ::xsd::cxx::tree::one< OnFirstTreatmentType > onFirstTreatment_;
    ::xsd::cxx::tree::one< OnFirstInfectionType > onFirstInfection_;
    AfterYearsOptional afterYears_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Screen schema type.
   *
   * This can be combined with MDA to achieve mass screen and treat (MSAT)
   * or other types of mass screening intervention.
   * 
   * When deployed to a host, this simulates a test of patent malaria
   * (microscopy, RDT or some such), then triggers deployment of whichever
   * intervention components are configured (deployments for both positive
   * and negative test outcomes can be configured).
   * 
   * The use of the screening itself is reported (if enabled), but not the
   * outcome. Deployment of interventions triggered by the screening may
   * be reported, however.
   *
   * @nosubgrouping
   */
  class Screen: public ::xml_schema::Type
  {
    public:
    /**
     * @name positive
     *
     * @brief Accessor and modifier functions for the %positive
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Component PositiveType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< PositiveType > PositiveSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< PositiveType >::iterator PositiveIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< PositiveType >::const_iterator PositiveConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PositiveType, char > PositiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const PositiveSequence&
    getPositive () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    PositiveSequence&
    getPositive ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setPositive (const PositiveSequence& s);

    //@}

    /**
     * @name negative
     *
     * @brief Accessor and modifier functions for the %negative
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Component NegativeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< NegativeType > NegativeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< NegativeType >::iterator NegativeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< NegativeType >::const_iterator NegativeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NegativeType, char > NegativeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const NegativeSequence&
    getNegative () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    NegativeSequence&
    getNegative ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setNegative (const NegativeSequence& s);

    //@}

    /**
     * @name diagnostic
     *
     * @brief Accessor and modifier functions for the %diagnostic
     * required attribute.
     *
     * Name of a parameterised diagnostic (see scenario/diagnostics).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String DiagnosticType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DiagnosticType, char > DiagnosticTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const DiagnosticType&
    getDiagnostic () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    DiagnosticType&
    getDiagnostic ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDiagnostic (const DiagnosticType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDiagnostic (::std::unique_ptr< DiagnosticType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Screen (const DiagnosticType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Screen (const xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Screen (const Screen& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Screen*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Screen&
    operator= (const Screen& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Screen ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    PositiveSequence positive_;
    NegativeSequence negative_;
    ::xsd::cxx::tree::one< DiagnosticType > diagnostic_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %VectorIntervention schema type.
   *
   * An intervention which may have various effects on the vector
   * populations as a whole. (Not host specific.)
   * 
   * Multiple instances of this intervention class are allowed (multiple
   * parameterisations, not just deployments).
   * 
   * Each instance may have multiple deployments. In this case the effects
   * of each instance
   * are independent (effects are combined) but the effects of multiple
   * deployments of a single
   * instance are not independent (only the latest deployment has any
   * effect).
   *
   * @nosubgrouping
   */
  class VectorIntervention: public ::xml_schema::Type
  {
    public:
    /**
     * @name description
     *
     * @brief Accessor and modifier functions for the %description
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Description DescriptionType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DescriptionType&
    getDescription () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DescriptionType&
    getDescription ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDescription (const DescriptionType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDescription (::std::unique_ptr< DescriptionType > p);

    //@}

    /**
     * @name timed
     *
     * @brief Accessor and modifier functions for the %timed
     * optional element.
     *
     * List of timed vector population intervention deployment
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TimedBaseList TimedType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TimedType > TimedOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimedType, char > TimedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TimedOptional&
    getTimed () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TimedOptional&
    getTimed ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTimed (const TimedType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTimed (const TimedOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTimed (::std::unique_ptr< TimedType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     *
     * Name of intervention (e.g. larviciding, sugar bait).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VectorIntervention (const DescriptionType&,
                        const NameType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    VectorIntervention (::std::unique_ptr< DescriptionType >,
                        const NameType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VectorIntervention (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VectorIntervention (const VectorIntervention& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VectorIntervention*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VectorIntervention&
    operator= (const VectorIntervention& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VectorIntervention ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DescriptionType > description_;
    TimedOptional timed_;
    ::xsd::cxx::tree::one< NameType > name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %VectorTrap schema type.
   *
   * Parameters and deployment of one type of trap. In case multiple types
   * of trap are needed simultaneously, multiple elements can be used. Note
   * that different types of trap do not interact except that all will
   * attract mosquitoes.
   *
   * @nosubgrouping
   */
  class VectorTrap: public ::xml_schema::Type
  {
    public:
    /**
     * @name description
     *
     * @brief Accessor and modifier functions for the %description
     * sequence element.
     *
     * Parameters associated with a vector trap intervention, per
     * mosquito species.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Description1 DescriptionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DescriptionType > DescriptionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< DescriptionType >::iterator DescriptionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< DescriptionType >::const_iterator DescriptionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DescriptionType, char > DescriptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DescriptionSequence&
    getDescription () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DescriptionSequence&
    getDescription ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDescription (const DescriptionSequence& s);

    //@}

    /**
     * @name timed
     *
     * @brief Accessor and modifier functions for the %timed
     * optional element.
     *
     * List of timed vector trap intervention deployment
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Timed TimedType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TimedType > TimedOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimedType, char > TimedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TimedOptional&
    getTimed () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TimedOptional&
    getTimed ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTimed (const TimedType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTimed (const TimedOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTimed (::std::unique_ptr< TimedType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * Optional name for this type of trap
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VectorTrap ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VectorTrap (const xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VectorTrap (const VectorTrap& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VectorTrap*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VectorTrap&
    operator= (const VectorTrap& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VectorTrap ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DescriptionSequence description_;
    TimedOptional timed_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TimedBase schema type.
   *
   * @nosubgrouping
   */
  class TimedBase: public ::xml_schema::Type
  {
    public:
    /**
     * @name time
     *
     * @brief Accessor and modifier functions for the %time
     * required attribute.
     *
     * Time at which this deployment occurs.
     * 
     * See doc on intervention period and on monitoring/startDate for
     * details of how times work. Can be specified in steps, days,
     * years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String TimeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeType, char > TimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const TimeType&
    getTime () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    TimeType&
    getTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTime (const TimeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTime (::std::unique_ptr< TimeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimedBase (const TimeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimedBase (const xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimedBase (const TimedBase& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimedBase*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimedBase&
    operator= (const TimedBase& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimedBase ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TimeType > time_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DeploymentBase schema type.
   *
   * @nosubgrouping
   */
  class DeploymentBase: public ::xml_schema::Type
  {
    public:
    /**
     * @name coverage
     *
     * @brief Accessor and modifier functions for the %coverage
     * required attribute.
     *
     * Proportion of otherwise eligible individuals who will receive this
     * deployment.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double CoverageType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CoverageType, char, ::xsd::cxx::tree::schema_type::double_ > CoverageTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const CoverageType&
    getCoverage () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    CoverageType&
    getCoverage ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setCoverage (const CoverageType& x);

    //@}

    /**
     * @name vaccMinPrevDoses
     *
     * @brief Accessor and modifier functions for the %vaccMinPrevDoses
     * optional attribute.
     *
     * Applies to vaccines only: vaccine doses are only deployed by this
     * deployment if the previous number of doses (for the component
     * deployed) is at least this number.
     * 
     * For example, if this is the second deployment opportunity for this
     * vaccine and this value is 1, then this deployment cannot deploy the
     * vaccine to individuals who did not receive the first deployment.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int VaccMinPrevDosesType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< VaccMinPrevDosesType > VaccMinPrevDosesOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< VaccMinPrevDosesType, char > VaccMinPrevDosesTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const VaccMinPrevDosesOptional&
    getVaccMinPrevDoses () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    VaccMinPrevDosesOptional&
    getVaccMinPrevDoses ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setVaccMinPrevDoses (const VaccMinPrevDosesType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setVaccMinPrevDoses (const VaccMinPrevDosesOptional& x);

    //@}

    /**
     * @name vaccMaxCumDoses
     *
     * @brief Accessor and modifier functions for the %vaccMaxCumDoses
     * optional attribute.
     *
     * Applies to vaccines only: vaccine doses are only deployed by this
     * deployment if the previous number of doses (for the component
     * deployed) is less than this number.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int VaccMaxCumDosesType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< VaccMaxCumDosesType > VaccMaxCumDosesOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< VaccMaxCumDosesType, char > VaccMaxCumDosesTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const VaccMaxCumDosesOptional&
    getVaccMaxCumDoses () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    VaccMaxCumDosesOptional&
    getVaccMaxCumDoses ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setVaccMaxCumDoses (const VaccMaxCumDosesType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setVaccMaxCumDoses (const VaccMaxCumDosesOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DeploymentBase (const CoverageType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DeploymentBase (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DeploymentBase (const DeploymentBase& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DeploymentBase*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DeploymentBase&
    operator= (const DeploymentBase& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DeploymentBase ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< CoverageType > coverage_;
    VaccMinPrevDosesOptional vaccMinPrevDoses_;
    VaccMaxCumDosesOptional vaccMaxCumDoses_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MassDeployment schema type.
   *
   * @nosubgrouping
   */
  class MassDeployment: public ::scnXml::DeploymentBase
  {
    public:
    /**
     * @name time
     *
     * @brief Accessor and modifier functions for the %time
     * required attribute.
     *
     * Time at which this deployment occurs.
     * 
     * See doc on intervention period and on monitoring/startDate for
     * details of how times work. Can be specified in steps, days,
     * years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String TimeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeType, char > TimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const TimeType&
    getTime () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    TimeType&
    getTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTime (const TimeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTime (::std::unique_ptr< TimeType > p);

    //@}

    /**
     * @name maxAge
     *
     * @brief Accessor and modifier functions for the %maxAge
     * optional attribute.
     *
     * Maximum age of eligible individuals (defaults to no limit).
     * 
     * Input is rounded to the nearest time step.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxAgeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxAgeType > MaxAgeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxAgeType, char, ::xsd::cxx::tree::schema_type::double_ > MaxAgeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxAgeOptional&
    getMaxAge () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxAgeOptional&
    getMaxAge ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxAge (const MaxAgeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxAge (const MaxAgeOptional& x);

    //@}

    /**
     * @name minAge
     *
     * @brief Accessor and modifier functions for the %minAge
     * optional attribute with a default value.
     *
     * Minimum age of eligible individuals (defaults to 0).
     * 
     * Input is rounded to the nearest time step.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MinAgeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MinAgeType, char, ::xsd::cxx::tree::schema_type::double_ > MinAgeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MinAgeType&
    getMinAge () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MinAgeType&
    getMinAge ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMinAge (const MinAgeType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static MinAgeType
    getMinAgeDefaultValue ();

    //@}

    /**
     * @name repeatStep
     *
     * @brief Accessor and modifier functions for the %repeatStep
     * optional attribute.
     *
     * See repeatEnd's documentation.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String RepeatStepType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RepeatStepType > RepeatStepOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RepeatStepType, char > RepeatStepTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RepeatStepOptional&
    getRepeatStep () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    RepeatStepOptional&
    getRepeatStep ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRepeatStep (const RepeatStepType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setRepeatStep (const RepeatStepOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRepeatStep (::std::unique_ptr< RepeatStepType > p);

    //@}

    /**
     * @name repeatEnd
     *
     * @brief Accessor and modifier functions for the %repeatEnd
     * optional attribute.
     *
     * Either both repeatStep and repeatEnd should be present
     * or neither. If present, the deployment is repeated every
     * repeatStep timesteps (i.e. if t0 is the initial time
     * and x is repeatStep, depolyments are done at times t0,
     * t0+x, t0+2*x, ...), ending before repeatEnd
     * (final repetition is the one before repeatEnd).
     * 
     * Note that repeatEnd may be specified as a date but
     * repeatStep must be a duration (days, steps or years).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String RepeatEndType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RepeatEndType > RepeatEndOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RepeatEndType, char > RepeatEndTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RepeatEndOptional&
    getRepeatEnd () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    RepeatEndOptional&
    getRepeatEnd ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRepeatEnd (const RepeatEndType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setRepeatEnd (const RepeatEndOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRepeatEnd (::std::unique_ptr< RepeatEndType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MassDeployment (const CoverageType&,
                    const TimeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MassDeployment (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MassDeployment (const MassDeployment& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MassDeployment*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MassDeployment&
    operator= (const MassDeployment& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MassDeployment ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TimeType > time_;
    MaxAgeOptional maxAge_;
    ::xsd::cxx::tree::one< MinAgeType > minAge_;
    RepeatStepOptional repeatStep_;
    RepeatEndOptional repeatEnd_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ContinuousList schema type.
   *
   * @nosubgrouping
   */
  class ContinuousList: public ::xml_schema::Type
  {
    public:
    /**
     * @name restrictToSubPop
     *
     * @brief Accessor and modifier functions for the %restrictToSubPop
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::RestrictToSubPop RestrictToSubPopType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RestrictToSubPopType > RestrictToSubPopOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RestrictToSubPopType, char > RestrictToSubPopTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RestrictToSubPopOptional&
    getRestrictToSubPop () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RestrictToSubPopOptional&
    getRestrictToSubPop ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRestrictToSubPop (const RestrictToSubPopType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRestrictToSubPop (const RestrictToSubPopOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRestrictToSubPop (::std::unique_ptr< RestrictToSubPopType > p);

    //@}

    /**
     * @name deploy
     *
     * @brief Accessor and modifier functions for the %deploy
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ContinuousDeployment DeployType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DeployType > DeploySequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::iterator DeployIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::const_iterator DeployConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeployType, char > DeployTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DeploySequence&
    getDeploy () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DeploySequence&
    getDeploy ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDeploy (const DeploySequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ContinuousList ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ContinuousList (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContinuousList (const ContinuousList& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ContinuousList*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContinuousList&
    operator= (const ContinuousList& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ContinuousList ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RestrictToSubPopOptional restrictToSubPop_;
    DeploySequence deploy_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ContinuousDeployment schema type.
   *
   * @nosubgrouping
   */
  class ContinuousDeployment: public ::scnXml::DeploymentBase
  {
    public:
    /**
     * @name targetAgeYrs
     *
     * @brief Accessor and modifier functions for the %targetAgeYrs
     * required attribute.
     *
     * Target age of intervention.
     * 
     * Input is rounded to the nearest time step.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double TargetAgeYrsType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TargetAgeYrsType, char, ::xsd::cxx::tree::schema_type::double_ > TargetAgeYrsTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const TargetAgeYrsType&
    getTargetAgeYrs () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    TargetAgeYrsType&
    getTargetAgeYrs ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTargetAgeYrs (const TargetAgeYrsType& x);

    //@}

    /**
     * @name begin
     *
     * @brief Accessor and modifier functions for the %begin
     * optional attribute.
     *
     * First time at which this deployment is active. If not specified,
     * deployment starts at the beginning of the intervention period.
     * 
     * See doc on intervention period and on monitoring/startDate for
     * details of how times work. Can be specified in steps, days,
     * years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String BeginType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BeginType > BeginOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< BeginType, char > BeginTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BeginOptional&
    getBegin () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    BeginOptional&
    getBegin ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setBegin (const BeginType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setBegin (const BeginOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setBegin (::std::unique_ptr< BeginType > p);

    //@}

    /**
     * @name end
     *
     * @brief Accessor and modifier functions for the %end
     * optional attribute.
     *
     * End of the period during which the intervention is active (to be
     * exact, the first step of the intervention period at which the
     * item becomes inactive). If not specified, deployment never
     * ceases after starting during the simulation.
     * 
     * See doc on intervention period and on monitoring/startDate for
     * details of how times work. Can be specified in steps, days,
     * years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String EndType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EndType > EndOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< EndType, char > EndTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EndOptional&
    getEnd () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    EndOptional&
    getEnd ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setEnd (const EndType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setEnd (const EndOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEnd (::std::unique_ptr< EndType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ContinuousDeployment (const CoverageType&,
                          const TargetAgeYrsType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ContinuousDeployment (const xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContinuousDeployment (const ContinuousDeployment& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ContinuousDeployment*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ContinuousDeployment&
    operator= (const ContinuousDeployment& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ContinuousDeployment ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TargetAgeYrsType > targetAgeYrs_;
    BeginOptional begin_;
    EndOptional end_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TimedBaseList schema type.
   *
   * @nosubgrouping
   */
  class TimedBaseList: public ::xml_schema::Type
  {
    public:
    /**
     * @name deploy
     *
     * @brief Accessor and modifier functions for the %deploy
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TimedBase DeployType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DeployType > DeploySequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::iterator DeployIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::const_iterator DeployConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeployType, char > DeployTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DeploySequence&
    getDeploy () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DeploySequence&
    getDeploy ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDeploy (const DeploySequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimedBaseList ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimedBaseList (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimedBaseList (const TimedBaseList& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimedBaseList*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimedBaseList&
    operator= (const TimedBaseList& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimedBaseList ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DeploySequence deploy_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MassListWithCum schema type.
   *
   * @nosubgrouping
   */
  class MassListWithCum: public ::xml_schema::Type
  {
    public:
    /**
     * @name restrictToSubPop
     *
     * @brief Accessor and modifier functions for the %restrictToSubPop
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::RestrictToSubPop RestrictToSubPopType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RestrictToSubPopType > RestrictToSubPopOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RestrictToSubPopType, char > RestrictToSubPopTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RestrictToSubPopOptional&
    getRestrictToSubPop () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RestrictToSubPopOptional&
    getRestrictToSubPop ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRestrictToSubPop (const RestrictToSubPopType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRestrictToSubPop (const RestrictToSubPopOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRestrictToSubPop (::std::unique_ptr< RestrictToSubPopType > p);

    //@}

    /**
     * @name cumulativeCoverage
     *
     * @brief Accessor and modifier functions for the %cumulativeCoverage
     * optional element.
     *
     * If this element is not specified, standard deployment occurs, where
     * a portion of the population as given by the coverage property of this
     * campaign is selected, and interventions are deployed to all of
     * these people (regardless of previous coverage).
     * 
     * If this attribute is specified, instead, the population is divided
     * into two sets: those who are a member of a certain sub-population and
     * those who are not (see "subPopRemoval" element).
     * If the proportion of people in the
     * first set is less than the desired coverage, then the proportion of
     * people from the second set needed to increase total coverage to the
     * desired coverage is calculated. This proportion is then used as the
     * probablity of selection from the second set into a third set of
     * people who then receive all interventions deployed by this campaign.
     * 
     * Note that selection is stochastic so the final coverage level may not
     * be exactly that desired. Note also that the component used when
     * selecting people need not actually be one of the components deployed
     * by this intervention, although that is the intended use case.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::CumulativeCoverage CumulativeCoverageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CumulativeCoverageType > CumulativeCoverageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CumulativeCoverageType, char > CumulativeCoverageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CumulativeCoverageOptional&
    getCumulativeCoverage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CumulativeCoverageOptional&
    getCumulativeCoverage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCumulativeCoverage (const CumulativeCoverageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCumulativeCoverage (const CumulativeCoverageOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCumulativeCoverage (::std::unique_ptr< CumulativeCoverageType > p);

    //@}

    /**
     * @name deploy
     *
     * @brief Accessor and modifier functions for the %deploy
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::MassDeployment DeployType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DeployType > DeploySequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::iterator DeployIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::const_iterator DeployConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeployType, char > DeployTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DeploySequence&
    getDeploy () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DeploySequence&
    getDeploy ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDeploy (const DeploySequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MassListWithCum ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MassListWithCum (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MassListWithCum (const MassListWithCum& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MassListWithCum*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MassListWithCum&
    operator= (const MassListWithCum& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MassListWithCum ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RestrictToSubPopOptional restrictToSubPop_;
    CumulativeCoverageOptional cumulativeCoverage_;
    DeploySequence deploy_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %RestrictToSubPop schema type.
   *
   * If this element is specified, deployment is restricted to some
   * sub-population (specified via the "id" attribute); otherwise the
   * target population is the entire simulated population. Either way,
   * other
   * deployment restrictions (age, time, number of vaccine doeses) still
   * apply.
   *
   * @nosubgrouping
   */
  class RestrictToSubPop: public ::xml_schema::Type
  {
    public:
    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     *
     * The identifier (short name) of the sub-population (i.e. the "id" of
     * some intervention component). Also see the "complement" attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::unique_ptr< IdType > p);

    //@}

    /**
     * @name complement
     *
     * @brief Accessor and modifier functions for the %complement
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean ComplementType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComplementType, char > ComplementTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ComplementType&
    getComplement () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ComplementType&
    getComplement ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setComplement (const ComplementType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static ComplementType
    getComplementDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RestrictToSubPop (const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RestrictToSubPop (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RestrictToSubPop (const RestrictToSubPop& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RestrictToSubPop*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RestrictToSubPop&
    operator= (const RestrictToSubPop& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RestrictToSubPop ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IdType > id_;
    ::xsd::cxx::tree::one< ComplementType > complement_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %VaccineDescription schema type.
   *
   * Description of a vaccine's effect
   *
   * @nosubgrouping
   */
  class VaccineDescription: public ::xml_schema::Type
  {
    public:
    /**
     * @name decay
     *
     * @brief Accessor and modifier functions for the %decay
     * required element.
     *
     * Specification of decay of efficacy. Documentation: see DecayFunction
     * type
     * or https://github.com/SwissTPH/openmalaria/wiki/ModelDecayFunctions
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecayFunction DecayType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DecayType, char > DecayTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DecayType&
    getDecay () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DecayType&
    getDecay ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDecay (const DecayType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDecay (::std::unique_ptr< DecayType > p);

    //@}

    /**
     * @name efficacyB
     *
     * @brief Accessor and modifier functions for the %efficacyB
     * required element.
     *
     * Measure of variation in vaccine efficacy: efficacy is sampled from
     * a beta distribution with efficacyB its beta parameter and its alpha
     * parameter fixed such that the mean is that given by initialEfficacy.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue EfficacyBType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EfficacyBType, char > EfficacyBTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EfficacyBType&
    getEfficacyB () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EfficacyBType&
    getEfficacyB ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEfficacyB (const EfficacyBType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEfficacyB (::std::unique_ptr< EfficacyBType > p);

    //@}

    /**
     * @name initialEfficacy
     *
     * @brief Accessor and modifier functions for the %initialEfficacy
     * sequence element.
     *
     * Mean efficacy values before decay (see efficacyB and decay parameter
     * descriptions for sampling and decay). The i-th value in this list
     * is used for the efficacy of the vaccine after the i-th dose. Where
     * more doses are given than there are values in this list, the last
     * value is repeated.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue InitialEfficacyType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< InitialEfficacyType > InitialEfficacySequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< InitialEfficacyType >::iterator InitialEfficacyIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< InitialEfficacyType >::const_iterator InitialEfficacyConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InitialEfficacyType, char > InitialEfficacyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const InitialEfficacySequence&
    getInitialEfficacy () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    InitialEfficacySequence&
    getInitialEfficacy ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setInitialEfficacy (const InitialEfficacySequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VaccineDescription (const DecayType&,
                        const EfficacyBType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    VaccineDescription (::std::unique_ptr< DecayType >,
                        ::std::unique_ptr< EfficacyBType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VaccineDescription (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VaccineDescription (const VaccineDescription& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VaccineDescription*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VaccineDescription&
    operator= (const VaccineDescription& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VaccineDescription ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DecayType > decay_;
    ::xsd::cxx::tree::one< EfficacyBType > efficacyB_;
    InitialEfficacySequence initialEfficacy_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ITNDescription schema type.
   *
   * @nosubgrouping
   */
  class ITNDescription: public ::xml_schema::Type
  {
    public:
    /**
     * @name usage
     *
     * @brief Accessor and modifier functions for the %usage
     * optional element.
     *
     * Usage of nets by humans, from 0 to 1.
     * 
     * At the moment this is constant across humans and deterministic:
     * relative attractiveness and survival factors are
     * base*(1-usage*propActing) + intervention_factor*usage*propActing.
     * 
     * See also "propActing" (proportion of bits for which net acts).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue UsageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UsageType > UsageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UsageType, char > UsageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UsageOptional&
    getUsage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UsageOptional&
    getUsage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUsage (const UsageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUsage (const UsageOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUsage (::std::unique_ptr< UsageType > p);

    //@}

    /**
     * @name holeRate
     *
     * @brief Accessor and modifier functions for the %holeRate
     * required element.
     *
     * The rate at which new holes are made in nets.
     * 
     * nHoles(t) = nHoles(t-1) + X where X~Pois(R/T) where T is the number
     * of time-steps per year. R is sampled from
     * log-normal: R ~ log N( log(mean)-sigma?/2, sigma? ) and is covariant
     * with ripRate and insecticideDecay. (To be exact, a single Gaussian
     * sample is taken, adjusted for each sigma then exponentiated.)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::LognormalSample HoleRateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HoleRateType, char > HoleRateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const HoleRateType&
    getHoleRate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    HoleRateType&
    getHoleRate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHoleRate (const HoleRateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHoleRate (::std::unique_ptr< HoleRateType > p);

    //@}

    /**
     * @name ripRate
     *
     * @brief Accessor and modifier functions for the %ripRate
     * required element.
     *
     * Each existing hole has a probability of being ripped bigger according
     * to a Poisson process with this rate as (only) parameter.
     * 
     * New rips occur in a net at rate X~Pois(h?R/T) where h is the number
     * of existing holes and T the number of time-steps per year. R is
     * sampled from log-normal: R ~ log N( log(mean)-sigma?/2, sigma? )
     * and is covariant with holeRate and insecticideDecay. (To be exact, a
     * single Gaussian sample is taken, adjusted for the each and sigma
     * then exponentiated.)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::LognormalSample RipRateType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RipRateType, char > RipRateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RipRateType&
    getRipRate () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RipRateType&
    getRipRate ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRipRate (const RipRateType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRipRate (::std::unique_ptr< RipRateType > p);

    //@}

    /**
     * @name ripFactor
     *
     * @brief Accessor and modifier functions for the %ripFactor
     * required element.
     *
     * This factor expresses how important rips are in increasing the hole.
     * 
     * The hole index of a net is h + F?x where h and x are the total numbers
     * of holes and rips respectively and F is the rip factor.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue RipFactorType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RipFactorType, char > RipFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RipFactorType&
    getRipFactor () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RipFactorType&
    getRipFactor ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRipFactor (const RipFactorType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRipFactor (::std::unique_ptr< RipFactorType > p);

    //@}

    /**
     * @name initialInsecticide
     *
     * @brief Accessor and modifier functions for the %initialInsecticide
     * required element.
     *
     * The insecticide concentration of new nets is Gaussian distributed with
     * mean "mu" and a standard deviation "sigma". The standard deviation
     * should be small relative to the mean to avoid negative initial
     * concentration. Any negative values sampled are set to 0.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::NormalSample InitialInsecticideType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InitialInsecticideType, char > InitialInsecticideTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InitialInsecticideType&
    getInitialInsecticide () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InitialInsecticideType&
    getInitialInsecticide ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInitialInsecticide (const InitialInsecticideType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInitialInsecticide (::std::unique_ptr< InitialInsecticideType > p);

    //@}

    /**
     * @name insecticideDecay
     *
     * @brief Accessor and modifier functions for the %insecticideDecay
     * required element.
     *
     * Decay curve for insecticide content of nets. Documentation: see
     * DecayFunction
     * type or
     * https://github.com/SwissTPH/openmalaria/wiki/ModelDecayFunctions
     * 
     * The distribution of decay rates over nets is covariant with the
     * distribution of ripRate and holeRate over nets. This distribution is
     * generated by taking one sample per net from a Gaussian distribution
     * with mean 0 and standard deviation 1. For each variable, the sample
     * is multiplied by the respective sigma and a constant added such that,
     * once exponentiated, the mean of the variable over nets is 1. The
     * variable is then exponentiated and multiplied by the required mean
     * rate for the respective variable.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecayFunction InsecticideDecayType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InsecticideDecayType, char > InsecticideDecayTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InsecticideDecayType&
    getInsecticideDecay () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InsecticideDecayType&
    getInsecticideDecay ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInsecticideDecay (const InsecticideDecayType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInsecticideDecay (::std::unique_ptr< InsecticideDecayType > p);

    //@}

    /**
     * @name attritionOfNets
     *
     * @brief Accessor and modifier functions for the %attritionOfNets
     * required element.
     *
     * Specifies the rate at which nets are disposed of over time.
     * Documentation: see DecayFunction type or
     * https://github.com/SwissTPH/openmalaria/wiki/ModelDecayFunctions
     * 
     * In the current model, nets are disposed of randomly (no correlation
     * with state of decay) such that the chance of each net surviving until
     * age t is the value of this decay function at time t. Equivalently
     * (where a large number of nets are distributed at the same time), the
     * proportion of nets remaining in use should match this decay function
     * over time.
     * 
     * Humans are removed from the intervention component's sub-population
     * on disposal (attrition) of their nets. Currently this event is not 
     * reported.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecayFunction AttritionOfNetsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AttritionOfNetsType, char > AttritionOfNetsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AttritionOfNetsType&
    getAttritionOfNets () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AttritionOfNetsType&
    getAttritionOfNets ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAttritionOfNets (const AttritionOfNetsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAttritionOfNets (::std::unique_ptr< AttritionOfNetsType > p);

    //@}

    /**
     * @name anophelesParams
     *
     * @brief Accessor and modifier functions for the %anophelesParams
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::AnophelesParams1 AnophelesParamsType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< AnophelesParamsType > AnophelesParamsSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< AnophelesParamsType >::iterator AnophelesParamsIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< AnophelesParamsType >::const_iterator AnophelesParamsConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AnophelesParamsType, char > AnophelesParamsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const AnophelesParamsSequence&
    getAnophelesParams () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    AnophelesParamsSequence&
    getAnophelesParams ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setAnophelesParams (const AnophelesParamsSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ITNDescription (const HoleRateType&,
                    const RipRateType&,
                    const RipFactorType&,
                    const InitialInsecticideType&,
                    const InsecticideDecayType&,
                    const AttritionOfNetsType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ITNDescription (::std::unique_ptr< HoleRateType >,
                    ::std::unique_ptr< RipRateType >,
                    ::std::unique_ptr< RipFactorType >,
                    ::std::unique_ptr< InitialInsecticideType >,
                    ::std::unique_ptr< InsecticideDecayType >,
                    ::std::unique_ptr< AttritionOfNetsType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ITNDescription (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ITNDescription (const ITNDescription& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ITNDescription*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ITNDescription&
    operator= (const ITNDescription& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ITNDescription ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    UsageOptional usage_;
    ::xsd::cxx::tree::one< HoleRateType > holeRate_;
    ::xsd::cxx::tree::one< RipRateType > ripRate_;
    ::xsd::cxx::tree::one< RipFactorType > ripFactor_;
    ::xsd::cxx::tree::one< InitialInsecticideType > initialInsecticide_;
    ::xsd::cxx::tree::one< InsecticideDecayType > insecticideDecay_;
    ::xsd::cxx::tree::one< AttritionOfNetsType > attritionOfNets_;
    AnophelesParamsSequence anophelesParams_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %GVIDescription schema type.
   *
   * @nosubgrouping
   */
  class GVIDescription: public ::xml_schema::Type
  {
    public:
    /**
     * @name usage
     *
     * @brief Accessor and modifier functions for the %usage
     * optional element.
     *
     * Usage of Generic vector interventions, from 0 to 1.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue UsageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UsageType > UsageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UsageType, char > UsageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UsageOptional&
    getUsage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UsageOptional&
    getUsage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUsage (const UsageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUsage (const UsageOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUsage (::std::unique_ptr< UsageType > p);

    //@}

    /**
     * @name decay
     *
     * @brief Accessor and modifier functions for the %decay
     * required element.
     *
     * Description of decay of all intervention effects.
     * Documentation: see DecayFunction type or
     * https://github.com/SwissTPH/openmalaria/wiki/ModelDecayFunctions
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecayFunction DecayType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DecayType, char > DecayTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DecayType&
    getDecay () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DecayType&
    getDecay ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDecay (const DecayType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDecay (::std::unique_ptr< DecayType > p);

    //@}

    /**
     * @name anophelesParams
     *
     * @brief Accessor and modifier functions for the %anophelesParams
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::AnophelesParams11 AnophelesParamsType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< AnophelesParamsType > AnophelesParamsSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< AnophelesParamsType >::iterator AnophelesParamsIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< AnophelesParamsType >::const_iterator AnophelesParamsConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AnophelesParamsType, char > AnophelesParamsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const AnophelesParamsSequence&
    getAnophelesParams () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    AnophelesParamsSequence&
    getAnophelesParams ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setAnophelesParams (const AnophelesParamsSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    GVIDescription (const DecayType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    GVIDescription (::std::unique_ptr< DecayType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    GVIDescription (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GVIDescription (const GVIDescription& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual GVIDescription*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    GVIDescription&
    operator= (const GVIDescription& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~GVIDescription ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    UsageOptional usage_;
    ::xsd::cxx::tree::one< DecayType > decay_;
    AnophelesParamsSequence anophelesParams_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IRSDescription schema type.
   *
   * Description of effect for the more complex and probably more realistic
   * Briet model: IRS has three effects, whos strength is calculated as a
   * function of surviving insecticide content.
   *
   * @nosubgrouping
   */
  class IRSDescription: public ::xml_schema::Type
  {
    public:
    /**
     * @name usage
     *
     * @brief Accessor and modifier functions for the %usage
     * optional element.
     *
     * Usage of Indoor residual spraying (IRS) interventions, from 0 to 1.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue UsageType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< UsageType > UsageOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UsageType, char > UsageTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const UsageOptional&
    getUsage () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    UsageOptional&
    getUsage ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUsage (const UsageType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setUsage (const UsageOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setUsage (::std::unique_ptr< UsageType > p);

    //@}

    /**
     * @name initialInsecticide
     *
     * @brief Accessor and modifier functions for the %initialInsecticide
     * required element.
     *
     * The insecticide concentration of IRS (at time of spraying) is
     * Gaussian distributed with mean "mu" and a standard deviation "sigma".
     * The standard deviation should be small relative to the mean to avoid
     * negative initial concentration. Any negative values sampled are set
     * to 0.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::NormalSample InitialInsecticideType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InitialInsecticideType, char > InitialInsecticideTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InitialInsecticideType&
    getInitialInsecticide () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InitialInsecticideType&
    getInitialInsecticide ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInitialInsecticide (const InitialInsecticideType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInitialInsecticide (::std::unique_ptr< InitialInsecticideType > p);

    //@}

    /**
     * @name insecticideDecay
     *
     * @brief Accessor and modifier functions for the %insecticideDecay
     * required element.
     *
     * Decay curve for insecticide content of IRS. Documentation: see
     * DecayFunction
     * type or
     * https://github.com/SwissTPH/openmalaria/wiki/ModelDecayFunctions
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecayFunction InsecticideDecayType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InsecticideDecayType, char > InsecticideDecayTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InsecticideDecayType&
    getInsecticideDecay () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InsecticideDecayType&
    getInsecticideDecay ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInsecticideDecay (const InsecticideDecayType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInsecticideDecay (::std::unique_ptr< InsecticideDecayType > p);

    //@}

    /**
     * @name anophelesParams
     *
     * @brief Accessor and modifier functions for the %anophelesParams
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::AnophelesParams2 AnophelesParamsType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< AnophelesParamsType > AnophelesParamsSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< AnophelesParamsType >::iterator AnophelesParamsIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< AnophelesParamsType >::const_iterator AnophelesParamsConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AnophelesParamsType, char > AnophelesParamsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const AnophelesParamsSequence&
    getAnophelesParams () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    AnophelesParamsSequence&
    getAnophelesParams ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setAnophelesParams (const AnophelesParamsSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IRSDescription (const InitialInsecticideType&,
                    const InsecticideDecayType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    IRSDescription (::std::unique_ptr< InitialInsecticideType >,
                    ::std::unique_ptr< InsecticideDecayType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IRSDescription (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IRSDescription (const IRSDescription& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IRSDescription*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IRSDescription&
    operator= (const IRSDescription& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IRSDescription ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    UsageOptional usage_;
    ::xsd::cxx::tree::one< InitialInsecticideType > initialInsecticide_;
    ::xsd::cxx::tree::one< InsecticideDecayType > insecticideDecay_;
    AnophelesParamsSequence anophelesParams_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IRSDeterrency schema type.
   *
   * @nosubgrouping
   */
  class IRSDeterrency: public ::xml_schema::Type
  {
    public:
    /**
     * @name insecticideFactor
     *
     * @brief Accessor and modifier functions for the %insecticideFactor
     * required attribute.
     *
     * Value expected to be at least 0. Negative values are not
     * necessarily invalid, but allow nets to increase transmission.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double InsecticideFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InsecticideFactorType, char, ::xsd::cxx::tree::schema_type::double_ > InsecticideFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const InsecticideFactorType&
    getInsecticideFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    InsecticideFactorType&
    getInsecticideFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInsecticideFactor (const InsecticideFactorType& x);

    //@}

    /**
     * @name insecticideScalingFactor
     *
     * @brief Accessor and modifier functions for the %insecticideScalingFactor
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double InsecticideScalingFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InsecticideScalingFactorType, char, ::xsd::cxx::tree::schema_type::double_ > InsecticideScalingFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const InsecticideScalingFactorType&
    getInsecticideScalingFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    InsecticideScalingFactorType&
    getInsecticideScalingFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInsecticideScalingFactor (const InsecticideScalingFactorType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IRSDeterrency (const InsecticideFactorType&,
                   const InsecticideScalingFactorType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IRSDeterrency (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IRSDeterrency (const IRSDeterrency& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IRSDeterrency*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IRSDeterrency&
    operator= (const IRSDeterrency& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IRSDeterrency ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< InsecticideFactorType > insecticideFactor_;
    ::xsd::cxx::tree::one< InsecticideScalingFactorType > insecticideScalingFactor_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ITNEnteringDeterrencyLogit schema type.
   *
   * @nosubgrouping
   */
  class ITNEnteringDeterrencyLogit: public ::xml_schema::Type
  {
    public:
    /**
     * @name baseFactor
     *
     * @brief Accessor and modifier functions for the %baseFactor
     * required attribute.
     *
     * See parent element documentation
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double BaseFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< BaseFactorType, char, ::xsd::cxx::tree::schema_type::double_ > BaseFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const BaseFactorType&
    getBaseFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    BaseFactorType&
    getBaseFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setBaseFactor (const BaseFactorType& x);

    //@}

    /**
     * @name insecticideFactor
     *
     * @brief Accessor and modifier functions for the %insecticideFactor
     * required attribute.
     *
     * See parent element documentation
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double InsecticideFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InsecticideFactorType, char, ::xsd::cxx::tree::schema_type::double_ > InsecticideFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const InsecticideFactorType&
    getInsecticideFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    InsecticideFactorType&
    getInsecticideFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInsecticideFactor (const InsecticideFactorType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ITNEnteringDeterrencyLogit (const BaseFactorType&,
                                const InsecticideFactorType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ITNEnteringDeterrencyLogit (const xercesc::DOMElement& e,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ITNEnteringDeterrencyLogit (const ITNEnteringDeterrencyLogit& x,
                                ::xml_schema::Flags f = 0,
                                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ITNEnteringDeterrencyLogit*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ITNEnteringDeterrencyLogit&
    operator= (const ITNEnteringDeterrencyLogit& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ITNEnteringDeterrencyLogit ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< BaseFactorType > baseFactor_;
    ::xsd::cxx::tree::one< InsecticideFactorType > insecticideFactor_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IRSKillingEffect schema type.
   *
   * @nosubgrouping
   */
  class IRSKillingEffect: public ::scnXml::IRSDeterrency
  {
    public:
    /**
     * @name baseFactor
     *
     * @brief Accessor and modifier functions for the %baseFactor
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double BaseFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< BaseFactorType, char, ::xsd::cxx::tree::schema_type::double_ > BaseFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const BaseFactorType&
    getBaseFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    BaseFactorType&
    getBaseFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setBaseFactor (const BaseFactorType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IRSKillingEffect (const InsecticideFactorType&,
                      const InsecticideScalingFactorType&,
                      const BaseFactorType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IRSKillingEffect (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IRSKillingEffect (const IRSKillingEffect& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IRSKillingEffect*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IRSKillingEffect&
    operator= (const IRSKillingEffect& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IRSKillingEffect ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< BaseFactorType > baseFactor_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ITNDeterrency schema type.
   *
   * @nosubgrouping
   */
  class ITNDeterrency: public ::scnXml::IRSDeterrency
  {
    public:
    /**
     * @name holeFactor
     *
     * @brief Accessor and modifier functions for the %holeFactor
     * required attribute.
     *
     * Value expected to be at least 0. Negative values are not
     * necessarily invalid, but allow nets to increase transmission.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double HoleFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< HoleFactorType, char, ::xsd::cxx::tree::schema_type::double_ > HoleFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const HoleFactorType&
    getHoleFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    HoleFactorType&
    getHoleFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHoleFactor (const HoleFactorType& x);

    //@}

    /**
     * @name interactionFactor
     *
     * @brief Accessor and modifier functions for the %interactionFactor
     * required attribute.
     *
     * holeFactor + insecticideFactor + interactionFactor must not be greater
     * than 1, and is expected to be at least 0. A negative value is not
     * necessarily invalid, but allows nets to increase transmission.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double InteractionFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InteractionFactorType, char, ::xsd::cxx::tree::schema_type::double_ > InteractionFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const InteractionFactorType&
    getInteractionFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    InteractionFactorType&
    getInteractionFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInteractionFactor (const InteractionFactorType& x);

    //@}

    /**
     * @name holeScalingFactor
     *
     * @brief Accessor and modifier functions for the %holeScalingFactor
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double HoleScalingFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< HoleScalingFactorType, char, ::xsd::cxx::tree::schema_type::double_ > HoleScalingFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const HoleScalingFactorType&
    getHoleScalingFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    HoleScalingFactorType&
    getHoleScalingFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHoleScalingFactor (const HoleScalingFactorType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ITNDeterrency (const InsecticideFactorType&,
                   const InsecticideScalingFactorType&,
                   const HoleFactorType&,
                   const InteractionFactorType&,
                   const HoleScalingFactorType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ITNDeterrency (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ITNDeterrency (const ITNDeterrency& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ITNDeterrency*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ITNDeterrency&
    operator= (const ITNDeterrency& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ITNDeterrency ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< HoleFactorType > holeFactor_;
    ::xsd::cxx::tree::one< InteractionFactorType > interactionFactor_;
    ::xsd::cxx::tree::one< HoleScalingFactorType > holeScalingFactor_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ITNKillingEffect schema type.
   *
   * @nosubgrouping
   */
  class ITNKillingEffect: public ::scnXml::ITNDeterrency
  {
    public:
    /**
     * @name baseFactor
     *
     * @brief Accessor and modifier functions for the %baseFactor
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double BaseFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< BaseFactorType, char, ::xsd::cxx::tree::schema_type::double_ > BaseFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const BaseFactorType&
    getBaseFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    BaseFactorType&
    getBaseFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setBaseFactor (const BaseFactorType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ITNKillingEffect (const InsecticideFactorType&,
                      const InsecticideScalingFactorType&,
                      const HoleFactorType&,
                      const InteractionFactorType&,
                      const HoleScalingFactorType&,
                      const BaseFactorType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ITNKillingEffect (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ITNKillingEffect (const ITNKillingEffect& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ITNKillingEffect*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ITNKillingEffect&
    operator= (const ITNKillingEffect& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ITNKillingEffect ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< BaseFactorType > baseFactor_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ITNEffectLogit schema type.
   *
   * @nosubgrouping
   */
  class ITNEffectLogit: public ::xml_schema::Type
  {
    public:
    /**
     * @name baseFactor
     *
     * @brief Accessor and modifier functions for the %baseFactor
     * required attribute.
     *
     * Logit of the probability (e.g. of death, of entry, of attacking)
     * without intervention.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double BaseFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< BaseFactorType, char, ::xsd::cxx::tree::schema_type::double_ > BaseFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const BaseFactorType&
    getBaseFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    BaseFactorType&
    getBaseFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setBaseFactor (const BaseFactorType& x);

    //@}

    /**
     * @name insecticideFactor
     *
     * @brief Accessor and modifier functions for the %insecticideFactor
     * required attribute.
     *
     * Coefficient of log(insecticide content+1) in a generalized linear
     * model with logit link
     * function.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double InsecticideFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InsecticideFactorType, char, ::xsd::cxx::tree::schema_type::double_ > InsecticideFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const InsecticideFactorType&
    getInsecticideFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    InsecticideFactorType&
    getInsecticideFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInsecticideFactor (const InsecticideFactorType& x);

    //@}

    /**
     * @name holeFactor
     *
     * @brief Accessor and modifier functions for the %holeFactor
     * required attribute.
     *
     * Coefficient of log(total holed surface area (in cm2) +1) in a
     * generalized linear model
     * with logit link function.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double HoleFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< HoleFactorType, char, ::xsd::cxx::tree::schema_type::double_ > HoleFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const HoleFactorType&
    getHoleFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    HoleFactorType&
    getHoleFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHoleFactor (const HoleFactorType& x);

    //@}

    /**
     * @name interactionFactor
     *
     * @brief Accessor and modifier functions for the %interactionFactor
     * required attribute.
     *
     * Coefficient of the interaction term of log(total holed surface area
     * (in cm2) +1) with
     * log(insecticide content+1) in a generalized linear model with logit
     * link function.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double InteractionFactorType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InteractionFactorType, char, ::xsd::cxx::tree::schema_type::double_ > InteractionFactorTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const InteractionFactorType&
    getInteractionFactor () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    InteractionFactorType&
    getInteractionFactor ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInteractionFactor (const InteractionFactorType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ITNEffectLogit (const BaseFactorType&,
                    const InsecticideFactorType&,
                    const HoleFactorType&,
                    const InteractionFactorType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ITNEffectLogit (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ITNEffectLogit (const ITNEffectLogit& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ITNEffectLogit*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ITNEffectLogit&
    operator= (const ITNEffectLogit& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ITNEffectLogit ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< BaseFactorType > baseFactor_;
    ::xsd::cxx::tree::one< InsecticideFactorType > insecticideFactor_;
    ::xsd::cxx::tree::one< HoleFactorType > holeFactor_;
    ::xsd::cxx::tree::one< InteractionFactorType > interactionFactor_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %VectorSpeciesIntervention schema type.
   *
   * Descriptions of the effects of vector interventions with per-species
   * effects.
   *
   * @nosubgrouping
   */
  class VectorSpeciesIntervention: public ::xml_schema::Type
  {
    public:
    /**
     * @name seekingDeathRateIncrease
     *
     * @brief Accessor and modifier functions for the %seekingDeathRateIncrease
     * optional element.
     *
     * Describe an effect on the increase in the death rate while host
     * seeking (mu_vA) due to this intervention.
     * 
     * Enter the rate increase (i.e. if rate increases to 120% of normal,
     * give 0.2). New death rate while seeking is old ? (1 + increase)
     * where increase is this factor given. Must have increas ? -1.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::SeekingDeathRateIncrease SeekingDeathRateIncreaseType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SeekingDeathRateIncreaseType > SeekingDeathRateIncreaseOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SeekingDeathRateIncreaseType, char > SeekingDeathRateIncreaseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SeekingDeathRateIncreaseOptional&
    getSeekingDeathRateIncrease () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SeekingDeathRateIncreaseOptional&
    getSeekingDeathRateIncrease ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSeekingDeathRateIncrease (const SeekingDeathRateIncreaseType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSeekingDeathRateIncrease (const SeekingDeathRateIncreaseOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSeekingDeathRateIncrease (::std::unique_ptr< SeekingDeathRateIncreaseType > p);

    //@}

    /**
     * @name probDeathOvipositing
     *
     * @brief Accessor and modifier functions for the %probDeathOvipositing
     * optional element.
     *
     * Describe an effect of increased mortality while ovipositing
     * due to this intervention. Enter the probability of dying due to
     * this intervention.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ProbDeathOvipositing ProbDeathOvipositingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ProbDeathOvipositingType > ProbDeathOvipositingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ProbDeathOvipositingType, char > ProbDeathOvipositingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ProbDeathOvipositingOptional&
    getProbDeathOvipositing () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ProbDeathOvipositingOptional&
    getProbDeathOvipositing ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setProbDeathOvipositing (const ProbDeathOvipositingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setProbDeathOvipositing (const ProbDeathOvipositingOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setProbDeathOvipositing (::std::unique_ptr< ProbDeathOvipositingType > p);

    //@}

    /**
     * @name emergenceReduction
     *
     * @brief Accessor and modifier functions for the %emergenceReduction
     * optional element.
     *
     * Describe an effect on emergence of pupa into adults: this value is the
     * proportion of emerging pupa which are killed by this intervention.
     * 
     * This can be used as a crude way of modelling larviciding. It ca
     * also be used to increase emergence by giving a negative value.
     * The emergence rate is "old rate" ? (1 - factor) where factor is the
     * value given here; thus, for example, using -1 will double emergence.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::EmergenceReduction EmergenceReductionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EmergenceReductionType > EmergenceReductionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EmergenceReductionType, char > EmergenceReductionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EmergenceReductionOptional&
    getEmergenceReduction () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    EmergenceReductionOptional&
    getEmergenceReduction ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEmergenceReduction (const EmergenceReductionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEmergenceReduction (const EmergenceReductionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEmergenceReduction (::std::unique_ptr< EmergenceReductionType > p);

    //@}

    /**
     * @name mosquito
     *
     * @brief Accessor and modifier functions for the %mosquito
     * required attribute.
     *
     * Name of the species/subspecies/variant.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String MosquitoType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MosquitoType, char > MosquitoTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MosquitoType&
    getMosquito () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MosquitoType&
    getMosquito ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMosquito (const MosquitoType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMosquito (::std::unique_ptr< MosquitoType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VectorSpeciesIntervention (const MosquitoType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VectorSpeciesIntervention (const xercesc::DOMElement& e,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VectorSpeciesIntervention (const VectorSpeciesIntervention& x,
                               ::xml_schema::Flags f = 0,
                               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VectorSpeciesIntervention*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VectorSpeciesIntervention&
    operator= (const VectorSpeciesIntervention& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VectorSpeciesIntervention ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SeekingDeathRateIncreaseOptional seekingDeathRateIncrease_;
    ProbDeathOvipositingOptional probDeathOvipositing_;
    EmergenceReductionOptional emergenceReduction_;
    ::xsd::cxx::tree::one< MosquitoType > mosquito_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %changeHS schema type.
   *
   * @nosubgrouping
   */
  class ChangeHS: public ::xml_schema::Type
  {
    public:
    /**
     * @name timedDeployment
     *
     * @brief Accessor and modifier functions for the %timedDeployment
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TimedDeployment TimedDeploymentType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TimedDeploymentType > TimedDeploymentSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< TimedDeploymentType >::iterator TimedDeploymentIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< TimedDeploymentType >::const_iterator TimedDeploymentConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimedDeploymentType, char > TimedDeploymentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TimedDeploymentSequence&
    getTimedDeployment () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TimedDeploymentSequence&
    getTimedDeployment ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTimedDeployment (const TimedDeploymentSequence& s);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * Name of intervention
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChangeHS ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChangeHS (const xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChangeHS (const ChangeHS& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChangeHS*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChangeHS&
    operator= (const ChangeHS& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChangeHS ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TimedDeploymentSequence timedDeployment_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %changeEIR schema type.
   *
   * @nosubgrouping
   */
  class ChangeEIR: public ::xml_schema::Type
  {
    public:
    /**
     * @name timedDeployment
     *
     * @brief Accessor and modifier functions for the %timedDeployment
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TimedDeployment1 TimedDeploymentType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TimedDeploymentType > TimedDeploymentSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< TimedDeploymentType >::iterator TimedDeploymentIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< TimedDeploymentType >::const_iterator TimedDeploymentConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimedDeploymentType, char > TimedDeploymentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TimedDeploymentSequence&
    getTimedDeployment () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TimedDeploymentSequence&
    getTimedDeployment ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTimedDeployment (const TimedDeploymentSequence& s);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * Name of intervention
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ChangeEIR ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ChangeEIR (const xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChangeEIR (const ChangeEIR& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ChangeEIR*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ChangeEIR&
    operator= (const ChangeEIR& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ChangeEIR ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TimedDeploymentSequence timedDeployment_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %importedInfections schema type.
   *
   * @nosubgrouping
   */
  class ImportedInfections: public ::xml_schema::Type
  {
    public:
    /**
     * @name timed
     *
     * @brief Accessor and modifier functions for the %timed
     * required element.
     *
     * Rate of case importation, as a step function. Each value is
     * valid until replaced by the next value.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Timed1 TimedType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimedType, char > TimedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TimedType&
    getTimed () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TimedType&
    getTimed ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTimed (const TimedType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTimed (::std::unique_ptr< TimedType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * Name of intervention
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ImportedInfections (const TimedType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ImportedInfections (::std::unique_ptr< TimedType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ImportedInfections (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ImportedInfections (const ImportedInfections& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ImportedInfections*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ImportedInfections&
    operator= (const ImportedInfections& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ImportedInfections ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TimedType > timed_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %insertR_0Case schema type.
   *
   * @nosubgrouping
   */
  class InsertR_0Case: public ::xml_schema::Type
  {
    public:
    /**
     * @name timedDeployment
     *
     * @brief Accessor and modifier functions for the %timedDeployment
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TimedDeployment2 TimedDeploymentType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TimedDeploymentType > TimedDeploymentSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< TimedDeploymentType >::iterator TimedDeploymentIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< TimedDeploymentType >::const_iterator TimedDeploymentConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimedDeploymentType, char > TimedDeploymentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TimedDeploymentSequence&
    getTimedDeployment () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TimedDeploymentSequence&
    getTimedDeployment ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTimedDeployment (const TimedDeploymentSequence& s);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * Name of intervention
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    InsertR_0Case ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    InsertR_0Case (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InsertR_0Case (const InsertR_0Case& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual InsertR_0Case*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    InsertR_0Case&
    operator= (const InsertR_0Case& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~InsertR_0Case ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TimedDeploymentSequence timedDeployment_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %uninfectVectors schema type.
   *
   * @nosubgrouping
   */
  class UninfectVectors: public ::xml_schema::Type
  {
    public:
    /**
     * @name timedDeployment
     *
     * @brief Accessor and modifier functions for the %timedDeployment
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TimedDeployment2 TimedDeploymentType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TimedDeploymentType > TimedDeploymentSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< TimedDeploymentType >::iterator TimedDeploymentIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< TimedDeploymentType >::const_iterator TimedDeploymentConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimedDeploymentType, char > TimedDeploymentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TimedDeploymentSequence&
    getTimedDeployment () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TimedDeploymentSequence&
    getTimedDeployment ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTimedDeployment (const TimedDeploymentSequence& s);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * Name of intervention
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    UninfectVectors ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    UninfectVectors (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UninfectVectors (const UninfectVectors& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual UninfectVectors*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    UninfectVectors&
    operator= (const UninfectVectors& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~UninfectVectors ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    TimedDeploymentSequence timedDeployment_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %vectorPop schema type.
   *
   * @nosubgrouping
   */
  class VectorPop: public ::xml_schema::Type
  {
    public:
    /**
     * @name intervention
     *
     * @brief Accessor and modifier functions for the %intervention
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::VectorIntervention InterventionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< InterventionType > InterventionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< InterventionType >::iterator InterventionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< InterventionType >::const_iterator InterventionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InterventionType, char > InterventionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const InterventionSequence&
    getIntervention () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    InterventionSequence&
    getIntervention ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setIntervention (const InterventionSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VectorPop ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VectorPop (const xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VectorPop (const VectorPop& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VectorPop*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VectorPop&
    operator= (const VectorPop& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VectorPop ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    InterventionSequence intervention_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %vectorTrap schema type.
   *
   * @nosubgrouping
   */
  class VectorTrap1: public ::xml_schema::Type
  {
    public:
    /**
     * @name intervention
     *
     * @brief Accessor and modifier functions for the %intervention
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::VectorTrap InterventionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< InterventionType > InterventionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< InterventionType >::iterator InterventionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< InterventionType >::const_iterator InterventionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InterventionType, char > InterventionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const InterventionSequence&
    getIntervention () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    InterventionSequence&
    getIntervention ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setIntervention (const InterventionSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    VectorTrap1 ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    VectorTrap1 (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VectorTrap1 (const VectorTrap1& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual VectorTrap1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    VectorTrap1&
    operator= (const VectorTrap1& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~VectorTrap1 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    InterventionSequence intervention_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %deployment schema type.
   *
   * @nosubgrouping
   */
  class Deployment: public ::xml_schema::Type
  {
    public:
    /**
     * @name component
     *
     * @brief Accessor and modifier functions for the %component
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Component ComponentType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ComponentType > ComponentSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< ComponentType >::iterator ComponentIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< ComponentType >::const_iterator ComponentConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComponentType, char > ComponentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ComponentSequence&
    getComponent () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ComponentSequence&
    getComponent ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setComponent (const ComponentSequence& s);

    //@}

    /**
     * @name condition
     *
     * @brief Accessor and modifier functions for the %condition
     * sequence element.
     *
     * If conditions are specified, deployment of this intervention will only
     * go ahead
     * if all specified conditions are true. Condition statements are
     * evaluated only
     * during surveys, so deployment is enabled or disabled depending on the
     * results
     * of the most recent survey. So called *unreported surveys* can be used
     * to
     * reevaluate conditions without increasing granularity of output.
     * 
     * Conditions are evaluated for the whole population, not for individual
     * age-groups
     * or cohorts.
     * 
     * This affects all types of deployment.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Condition ConditionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ConditionType > ConditionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< ConditionType >::iterator ConditionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< ConditionType >::const_iterator ConditionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ConditionType, char > ConditionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ConditionSequence&
    getCondition () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ConditionSequence&
    getCondition ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setCondition (const ConditionSequence& s);

    //@}

    /**
     * @name continuous
     *
     * @brief Accessor and modifier functions for the %continuous
     * sequence element.
     *
     * List of ages at which deployment takes place
     * (through EPI, post-natal and school-based programmes, etc.).
     * 
     * A sub-population restriction may be added as a property of the
     * list of continuous deployments.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ContinuousList ContinuousType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ContinuousType > ContinuousSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< ContinuousType >::iterator ContinuousIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< ContinuousType >::const_iterator ContinuousConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ContinuousType, char > ContinuousTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ContinuousSequence&
    getContinuous () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ContinuousSequence&
    getContinuous ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setContinuous (const ContinuousSequence& s);

    //@}

    /**
     * @name timed
     *
     * @brief Accessor and modifier functions for the %timed
     * sequence element.
     *
     * List of timed deployments of the intervention (that is, of
     * deployment campaigns).
     * 
     * Cumulative deployment mode can be specified for all deployments in a
     * timed list.
     * To allow multiple cumulative deployment descriptions, the entire timed
     * list
     * may be repeated.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::MassListWithCum TimedType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TimedType > TimedSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< TimedType >::iterator TimedIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< TimedType >::const_iterator TimedConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimedType, char > TimedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TimedSequence&
    getTimed () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TimedSequence&
    getTimed ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTimed (const TimedSequence& s);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * Name of intervention
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Deployment ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Deployment (const xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Deployment (const Deployment& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Deployment*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Deployment&
    operator= (const Deployment& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Deployment ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ComponentSequence component_;
    ConditionSequence condition_;
    ContinuousSequence continuous_;
    TimedSequence timed_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %recruitmentOnly schema type.
   *
   * @nosubgrouping
   */
  class RecruitmentOnly: public ::xml_schema::Type
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    RecruitmentOnly ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RecruitmentOnly (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RecruitmentOnly (const xercesc::DOMAttr& a,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    RecruitmentOnly (const ::std::string& s,
                     const xercesc::DOMElement* e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    RecruitmentOnly (const RecruitmentOnly& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual RecruitmentOnly*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~RecruitmentOnly ();
  };

  /**
   * @brief Class corresponding to the %clearImmunity schema type.
   *
   * @nosubgrouping
   */
  class ClearImmunity: public ::xml_schema::Type
  {
    public:
    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ClearImmunity ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ClearImmunity (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ClearImmunity (const xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ClearImmunity (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClearImmunity (const ClearImmunity& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ClearImmunity*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ClearImmunity ();
  };

  /**
   * @brief Class corresponding to the %description schema type.
   *
   * @nosubgrouping
   */
  class Description: public ::xml_schema::Type
  {
    public:
    /**
     * @name anopheles
     *
     * @brief Accessor and modifier functions for the %anopheles
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::VectorSpeciesIntervention AnophelesType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< AnophelesType > AnophelesSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< AnophelesType >::iterator AnophelesIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< AnophelesType >::const_iterator AnophelesConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AnophelesType, char > AnophelesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const AnophelesSequence&
    getAnopheles () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    AnophelesSequence&
    getAnopheles ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setAnopheles (const AnophelesSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Description ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Description (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Description (const Description& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Description*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Description&
    operator= (const Description& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Description ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AnophelesSequence anopheles_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %description1 schema type.
   *
   * @nosubgrouping
   */
  class Description1: public ::xml_schema::Type
  {
    public:
    /**
     * @name relativeAvailability
     *
     * @brief Accessor and modifier functions for the %relativeAvailability
     * required element.
     *
     * Describes the availiability of a trap to a
     * host-seeking mosquito relative to an average
     * unprotected adult.
     * 
     * I.e. if this parameter is 2, then each trap will on
     * average attract twice as many mosquitoes as
     * unprotected adults.
     * 
     * This is the initial availability; it may decay
     * towards zero depending on the configured
     * decay function.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue RelativeAvailabilityType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RelativeAvailabilityType, char > RelativeAvailabilityTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const RelativeAvailabilityType&
    getRelativeAvailability () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    RelativeAvailabilityType&
    getRelativeAvailability ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRelativeAvailability (const RelativeAvailabilityType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setRelativeAvailability (::std::unique_ptr< RelativeAvailabilityType > p);

    //@}

    /**
     * @name decayOfAvailability
     *
     * @brief Accessor and modifier functions for the %decayOfAvailability
     * required element.
     *
     * Describes how availability decays to zero.
     * 
     * If decay heterogeneity/variance is used, there will be a
     * sample once-per-deployment (i.e. all traps of the same
     * deployment will be affected the same way). There is no
     * support for variances between traps (except in this crude
     * way, between deployments).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecayFunction DecayOfAvailabilityType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DecayOfAvailabilityType, char > DecayOfAvailabilityTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DecayOfAvailabilityType&
    getDecayOfAvailability () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DecayOfAvailabilityType&
    getDecayOfAvailability ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDecayOfAvailability (const DecayOfAvailabilityType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDecayOfAvailability (::std::unique_ptr< DecayOfAvailabilityType > p);

    //@}

    /**
     * @name mosquito
     *
     * @brief Accessor and modifier functions for the %mosquito
     * required attribute.
     *
     * Name of the species/subspecies/variant.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String MosquitoType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MosquitoType, char > MosquitoTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MosquitoType&
    getMosquito () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MosquitoType&
    getMosquito ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMosquito (const MosquitoType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMosquito (::std::unique_ptr< MosquitoType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Description1 (const RelativeAvailabilityType&,
                  const DecayOfAvailabilityType&,
                  const MosquitoType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Description1 (::std::unique_ptr< RelativeAvailabilityType >,
                  ::std::unique_ptr< DecayOfAvailabilityType >,
                  const MosquitoType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Description1 (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Description1 (const Description1& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Description1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Description1&
    operator= (const Description1& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Description1 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RelativeAvailabilityType > relativeAvailability_;
    ::xsd::cxx::tree::one< DecayOfAvailabilityType > decayOfAvailability_;
    ::xsd::cxx::tree::one< MosquitoType > mosquito_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %timed schema type.
   *
   * @nosubgrouping
   */
  class Timed: public ::xml_schema::Type
  {
    public:
    /**
     * @name deploy
     *
     * @brief Accessor and modifier functions for the %deploy
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Deploy1 DeployType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DeployType > DeploySequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::iterator DeployIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::const_iterator DeployConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeployType, char > DeployTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DeploySequence&
    getDeploy () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DeploySequence&
    getDeploy ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDeploy (const DeploySequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Timed ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Timed (const xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Timed (const Timed& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Timed*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Timed&
    operator= (const Timed& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Timed ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DeploySequence deploy_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %cumulativeCoverage schema type.
   *
   * @nosubgrouping
   */
  class CumulativeCoverage: public ::xml_schema::Type
  {
    public:
    /**
     * @name component
     *
     * @brief Accessor and modifier functions for the %component
     * required attribute.
     *
     * The identifier (short name) of the component used when
     * selecting people.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String ComponentType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComponentType, char > ComponentTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ComponentType&
    getComponent () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ComponentType&
    getComponent ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setComponent (const ComponentType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setComponent (::std::unique_ptr< ComponentType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CumulativeCoverage (const ComponentType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CumulativeCoverage (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CumulativeCoverage (const CumulativeCoverage& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CumulativeCoverage*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CumulativeCoverage&
    operator= (const CumulativeCoverage& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CumulativeCoverage ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ComponentType > component_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %anophelesParams schema type.
   *
   * @nosubgrouping
   */
  class AnophelesParams1: public ::xml_schema::Type
  {
    public:
    /**
     * @name holeIndexMax
     *
     * @brief Accessor and modifier functions for the %holeIndexMax
     * optional element.
     *
     * Used by logit attacking and killing models only, holeIndexMax
     * is a user defined maximum hole index (typically, the total surface
     * area of a net).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue HoleIndexMaxType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< HoleIndexMaxType > HoleIndexMaxOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< HoleIndexMaxType, char > HoleIndexMaxTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const HoleIndexMaxOptional&
    getHoleIndexMax () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    HoleIndexMaxOptional&
    getHoleIndexMax ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setHoleIndexMax (const HoleIndexMaxType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setHoleIndexMax (const HoleIndexMaxOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setHoleIndexMax (::std::unique_ptr< HoleIndexMaxType > p);

    //@}

    /**
     * @name deterrency
     *
     * @brief Accessor and modifier functions for the %deterrency
     * optional element.
     *
     * Effect of net on attractiveness of humans to mosquitoes relative to
     * an unprotected adult human. Parameterisations should take into
     * account that mosquitoes do not always bite indoors.
     * 
     * Attractiveness of the human is multiplied by
     * exp(log(H)?h + log(P)?p + log(I)?h?p
     * where H, P and I are the hole, insecticide and interaction factors
     * respectively, h=exp(-holeIndex?holeScalingFactor) and
     * p=1?exp(-insecticideContent?insecticideScalingFactor).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ITNDeterrency DeterrencyType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeterrencyType > DeterrencyOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeterrencyType, char > DeterrencyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeterrencyOptional&
    getDeterrency () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DeterrencyOptional&
    getDeterrency ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeterrency (const DeterrencyType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDeterrency (const DeterrencyOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeterrency (::std::unique_ptr< DeterrencyType > p);

    //@}

    /**
     * @name twoStageDeterrency
     *
     * @brief Accessor and modifier functions for the %twoStageDeterrency
     * optional element.
     *
     * Effect of net on attractiveness of humans to mosquitoes relative to
     * an unprotected adult human. Parameterisations should take into
     * account that mosquitoes do not always bite indoors.
     * 
     * This deterrency model multiplies human attractiveness by
     * pEnt?pAtt.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TwoStageDeterrency TwoStageDeterrencyType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TwoStageDeterrencyType > TwoStageDeterrencyOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TwoStageDeterrencyType, char > TwoStageDeterrencyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TwoStageDeterrencyOptional&
    getTwoStageDeterrency () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TwoStageDeterrencyOptional&
    getTwoStageDeterrency ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTwoStageDeterrency (const TwoStageDeterrencyType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTwoStageDeterrency (const TwoStageDeterrencyOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTwoStageDeterrency (::std::unique_ptr< TwoStageDeterrencyType > p);

    //@}

    /**
     * @name preprandialKillingEffect
     *
     * @brief Accessor and modifier functions for the %preprandialKillingEffect
     * optional element.
     *
     * Effect of net on survival mosquitoes as they seek to bite a human
     * after choosing that human, relative to the same person not
     * sleeping under a net. Parameterisations should take into
     * account that mosquitoes do not always bite indoors.
     * 
     * Killing proportion is calculated as K = B + H?h + P?p + I?h?p
     * where B is the base (without net) probability of death,
     * H, P and I are the hole, insecticide and interaction factors
     * respectively, h=exp(-holeIndex?holeScalingFactor) and
     * p=1?exp(-insecticideContent?insecticideScalingFactor).
     * 
     * Survival of mosquitoes is adjusted via multiplication by (1?K) /
     * (1?B).
     * To keep this in the range [0,1], we require that B+H ? 1, B+P ? 1,
     * B+H+P+I ? 1, H ? 0, P ? 0 and H+P+I ? 0.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ITNKillingEffect PreprandialKillingEffectType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PreprandialKillingEffectType > PreprandialKillingEffectOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PreprandialKillingEffectType, char > PreprandialKillingEffectTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PreprandialKillingEffectOptional&
    getPreprandialKillingEffect () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PreprandialKillingEffectOptional&
    getPreprandialKillingEffect ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPreprandialKillingEffect (const PreprandialKillingEffectType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPreprandialKillingEffect (const PreprandialKillingEffectOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPreprandialKillingEffect (::std::unique_ptr< PreprandialKillingEffectType > p);

    //@}

    /**
     * @name preprandialKillingEffectLogit
     *
     * @brief Accessor and modifier functions for the %preprandialKillingEffectLogit
     * optional element.
     *
     * Effect of net on survival mosquitoes as they seek to bite a human
     * after choosing that human, relative to the same person not
     * sleeping under a net.                 
     * Killing proportion is calculated as 
     * K=exp(logit.K)/(exp(logit.K)+1)
     * logit.K = B + H?min(h,hMax) + P?p + I?min(h,hMax)?p
     * where B is the basefactor (without net),
     * H, P and I are the hole, insecticide and interaction factors
     * respectively, h=log(holeIndex+1) and
     * p=log(insecticideContent+1).
     * Without a net, the killing proportion
     * K0=exp(logit.K0)/(exp(logit.K0)+1)
     * logit.K0 = B + H?hMax
     * where hMax=log(holeIndexMax+1) and holeIndexMax is a user defined
     * maximum hole index (typically, the total surface area of a net).
     * Survival of mosquitoes is adjusted via multiplication by (1?K) /
     * (1?K0).
     * To keep this in the range [0,1], we require that K ? K0. We enforce
     * that P ? 0 (It would not make sense biologically if P were negative)
     * and P+I*hMax ? 0 and H ? 0 and holeIndex ? holeIndexMax and give a
     * warning if these conditions are not fulfilled.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ITNEffectLogit PreprandialKillingEffectLogitType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PreprandialKillingEffectLogitType > PreprandialKillingEffectLogitOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PreprandialKillingEffectLogitType, char > PreprandialKillingEffectLogitTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PreprandialKillingEffectLogitOptional&
    getPreprandialKillingEffectLogit () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PreprandialKillingEffectLogitOptional&
    getPreprandialKillingEffectLogit ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPreprandialKillingEffectLogit (const PreprandialKillingEffectLogitType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPreprandialKillingEffectLogit (const PreprandialKillingEffectLogitOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPreprandialKillingEffectLogit (::std::unique_ptr< PreprandialKillingEffectLogitType > p);

    //@}

    /**
     * @name postprandialKillingEffect
     *
     * @brief Accessor and modifier functions for the %postprandialKillingEffect
     * optional element.
     *
     * Effect of net on survival mosquitoes as they seek to escape from
     * a human host and rest after a blood meal, relative to the same
     * person not sleeping under a net. Parameterisations should take
     * into account that mosquitoes do not always bite indoors.
     * 
     * Killing proportion is calculated as K = B + H?h + P?p + I?h?p
     * where B is the base (without net) probability of death,
     * H, P and I are the hole, insecticide and interaction factors
     * respectively, h=exp(-holeIndex?holeScalingFactor) and
     * p=1?exp(-insecticideContent?insecticideScalingFactor).
     * 
     * Survival of mosquitoes is adjusted via multiplication by (1?K) /
     * (1?B).
     * To keep this in the range [0,1], we require that B+H ? 1, B+P ? 1,
     * B+H+P+I ? 1, H ? 0, P ? 0 and H+P+I ? 0.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ITNKillingEffect PostprandialKillingEffectType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PostprandialKillingEffectType > PostprandialKillingEffectOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PostprandialKillingEffectType, char > PostprandialKillingEffectTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PostprandialKillingEffectOptional&
    getPostprandialKillingEffect () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PostprandialKillingEffectOptional&
    getPostprandialKillingEffect ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPostprandialKillingEffect (const PostprandialKillingEffectType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPostprandialKillingEffect (const PostprandialKillingEffectOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPostprandialKillingEffect (::std::unique_ptr< PostprandialKillingEffectType > p);

    //@}

    /**
     * @name postprandialKillingEffectLogit
     *
     * @brief Accessor and modifier functions for the %postprandialKillingEffectLogit
     * optional element.
     *
     * Effect of net on survival mosquitoes as they seek to escape from
     * a human host and rest after a blood meal, relative to the same
     * person not sleeping under a net.
     * Killing proportion is calculated as 
     * K=exp(logit.K)/(exp(logit.K)+1)
     * logit.K = B + H?min(h,hMax) + P?p + I?min(h,hMax)?p
     * where B is the basefactor (without net),
     * H, P and I are the hole, insecticide and interaction factors
     * respectively, h=log(holeIndex+1) and
     * p=log(insecticideContent+1).
     * Without a net, the killing proportion
     * K0=exp(logit.K0)/(exp(logit.K0)+1)
     * logit.K0 = B + H?hMax
     * where hMax=log(holeIndexMax+1) and holeIndexMax is a user defined
     * maximum hole index (typically, the total surface area of a net).
     * Survival of mosquitoes is adjusted via multiplication by (1?K) /
     * (1?K0).
     * To keep this in the range [0,1], we require that K ? K0. We enforce
     * that P ? 0 (It would not make sense biologically if P were negative)
     * and P+I*hMax ? 0 and H ? 0 and holeIndex ? holeIndexMax and give a
     * warning if these conditions are not fulfilled.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ITNEffectLogit PostprandialKillingEffectLogitType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PostprandialKillingEffectLogitType > PostprandialKillingEffectLogitOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PostprandialKillingEffectLogitType, char > PostprandialKillingEffectLogitTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PostprandialKillingEffectLogitOptional&
    getPostprandialKillingEffectLogit () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PostprandialKillingEffectLogitOptional&
    getPostprandialKillingEffectLogit ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPostprandialKillingEffectLogit (const PostprandialKillingEffectLogitType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPostprandialKillingEffectLogit (const PostprandialKillingEffectLogitOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPostprandialKillingEffectLogit (::std::unique_ptr< PostprandialKillingEffectLogitType > p);

    //@}

    /**
     * @name fecundityReduction
     *
     * @brief Accessor and modifier functions for the %fecundityReduction
     * optional element.
     *
     * Effect of net on fertility of mosquitoes who survive feeding
     * on a protected human, relative to an unprotected human.
     * 
     * Fertility (number of eggs laid) is multiplied by (1-K) / (1-B),
     * similar to killing effects. This is not allowed to be greater than 1.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ITNKillingEffect FecundityReductionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FecundityReductionType > FecundityReductionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FecundityReductionType, char > FecundityReductionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FecundityReductionOptional&
    getFecundityReduction () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FecundityReductionOptional&
    getFecundityReduction ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFecundityReduction (const FecundityReductionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFecundityReduction (const FecundityReductionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFecundityReduction (::std::unique_ptr< FecundityReductionType > p);

    //@}

    /**
     * @name fecundityReductionLogit
     *
     * @brief Accessor and modifier functions for the %fecundityReductionLogit
     * optional element.
     *
     * Effect of net on fertility of mosquitoes who survive feeding
     * on a protected human, relative to an unprotected human.
     * 
     * Fertility (number of eggs laid) is multiplied by (1-K) / (1-K0),
     * similar to killing effects. This is not allowed to be greater than 1.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ITNEffectLogit FecundityReductionLogitType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FecundityReductionLogitType > FecundityReductionLogitOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FecundityReductionLogitType, char > FecundityReductionLogitTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FecundityReductionLogitOptional&
    getFecundityReductionLogit () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FecundityReductionLogitOptional&
    getFecundityReductionLogit ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFecundityReductionLogit (const FecundityReductionLogitType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFecundityReductionLogit (const FecundityReductionLogitOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFecundityReductionLogit (::std::unique_ptr< FecundityReductionLogitType > p);

    //@}

    /**
     * @name mosquito
     *
     * @brief Accessor and modifier functions for the %mosquito
     * required attribute.
     *
     * Name of the affected anopheles-mosquito species.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String MosquitoType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MosquitoType, char > MosquitoTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MosquitoType&
    getMosquito () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MosquitoType&
    getMosquito ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMosquito (const MosquitoType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMosquito (::std::unique_ptr< MosquitoType > p);

    //@}

    /**
     * @name propActive
     *
     * @brief Accessor and modifier functions for the %propActive
     * optional attribute with a default value.
     *
     * The proportion of bites, when nets are in use, for which the net
     * has any action whatsoever on the mosquito.
     * 
     * At the moment this is constant across humans and deterministic:
     * relative attractiveness and survival factors are
     * base*(1-usage*propActing) + intervention_factor*usage*propActing.
     * 
     * See also "usage" (proportion of time nets are used by humans).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double PropActiveType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PropActiveType, char, ::xsd::cxx::tree::schema_type::double_ > PropActiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const PropActiveType&
    getPropActive () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    PropActiveType&
    getPropActive ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setPropActive (const PropActiveType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static PropActiveType
    getPropActiveDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AnophelesParams1 (const MosquitoType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AnophelesParams1 (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AnophelesParams1 (const AnophelesParams1& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AnophelesParams1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AnophelesParams1&
    operator= (const AnophelesParams1& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AnophelesParams1 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    HoleIndexMaxOptional holeIndexMax_;
    DeterrencyOptional deterrency_;
    TwoStageDeterrencyOptional twoStageDeterrency_;
    PreprandialKillingEffectOptional preprandialKillingEffect_;
    PreprandialKillingEffectLogitOptional preprandialKillingEffectLogit_;
    PostprandialKillingEffectOptional postprandialKillingEffect_;
    PostprandialKillingEffectLogitOptional postprandialKillingEffectLogit_;
    FecundityReductionOptional fecundityReduction_;
    FecundityReductionLogitOptional fecundityReductionLogit_;
    ::xsd::cxx::tree::one< MosquitoType > mosquito_;
    ::xsd::cxx::tree::one< PropActiveType > propActive_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %anophelesParams1 schema type.
   *
   * @nosubgrouping
   */
  class AnophelesParams11: public ::xml_schema::Type
  {
    public:
    /**
     * @name deterrency
     *
     * @brief Accessor and modifier functions for the %deterrency
     * optional element.
     *
     * Effect of intervention on attractiveness of humans to mosquitoes
     * relative to
     * an unprotected adult human. Parameterisations should take into
     * account that mosquitoes do not always bite indoors.
     * 
     * Attractiveness of the human is multiplied this factor times
     * survival of effect.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue DeterrencyType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DeterrencyType > DeterrencyOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeterrencyType, char > DeterrencyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DeterrencyOptional&
    getDeterrency () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DeterrencyOptional&
    getDeterrency ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeterrency (const DeterrencyType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDeterrency (const DeterrencyOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDeterrency (::std::unique_ptr< DeterrencyType > p);

    //@}

    /**
     * @name preprandialKillingEffect
     *
     * @brief Accessor and modifier functions for the %preprandialKillingEffect
     * optional element.
     *
     * Effect of intervention on survival of mosquitoes as they seek to bite
     * a human
     * after choosing that human, relative to the same person not
     * protected by the intervention. Parameterisations should take into
     * account
     * that mosquitoes do not always bite indoors. This parameter has
     * been added since some data shows IRS to have a preprandial
     * killing effect.
     * 
     * Killing proportion is this factor multiplied by survival of effect.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue PreprandialKillingEffectType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PreprandialKillingEffectType > PreprandialKillingEffectOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PreprandialKillingEffectType, char > PreprandialKillingEffectTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PreprandialKillingEffectOptional&
    getPreprandialKillingEffect () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PreprandialKillingEffectOptional&
    getPreprandialKillingEffect ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPreprandialKillingEffect (const PreprandialKillingEffectType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPreprandialKillingEffect (const PreprandialKillingEffectOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPreprandialKillingEffect (::std::unique_ptr< PreprandialKillingEffectType > p);

    //@}

    /**
     * @name postprandialKillingEffect
     *
     * @brief Accessor and modifier functions for the %postprandialKillingEffect
     * optional element.
     *
     * Effect of intervention on survival of mosquitoes as they seek to
     * escape from
     * a human host and rest after a blood meal, relative to the same
     * person not protected by the intervention. Parameterisations should
     * take
     * into account that mosquitoes do not always bite indoors.
     * 
     * Killing proportion is this factor multiplied by survival of effect.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue PostprandialKillingEffectType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PostprandialKillingEffectType > PostprandialKillingEffectOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PostprandialKillingEffectType, char > PostprandialKillingEffectTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PostprandialKillingEffectOptional&
    getPostprandialKillingEffect () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PostprandialKillingEffectOptional&
    getPostprandialKillingEffect ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPostprandialKillingEffect (const PostprandialKillingEffectType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPostprandialKillingEffect (const PostprandialKillingEffectOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPostprandialKillingEffect (::std::unique_ptr< PostprandialKillingEffectType > p);

    //@}

    /**
     * @name fecundityReduction
     *
     * @brief Accessor and modifier functions for the %fecundityReduction
     * optional element.
     *
     * Effect of intervention on fertility mosquitoes after successfully
     * feeding on
     * a human host, relative to an unproteced human. Parameterisations
     * should take
     * into account that mosquitoes do not always bite indoors.
     * 
     * Fertility is multiplied by 1 - (fecundityReduction * decay).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue FecundityReductionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FecundityReductionType > FecundityReductionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FecundityReductionType, char > FecundityReductionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FecundityReductionOptional&
    getFecundityReduction () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FecundityReductionOptional&
    getFecundityReduction ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFecundityReduction (const FecundityReductionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFecundityReduction (const FecundityReductionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFecundityReduction (::std::unique_ptr< FecundityReductionType > p);

    //@}

    /**
     * @name mosquito
     *
     * @brief Accessor and modifier functions for the %mosquito
     * required attribute.
     *
     * Name of the affected anopheles-mosquito species.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String MosquitoType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MosquitoType, char > MosquitoTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MosquitoType&
    getMosquito () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MosquitoType&
    getMosquito ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMosquito (const MosquitoType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMosquito (::std::unique_ptr< MosquitoType > p);

    //@}

    /**
     * @name propActive
     *
     * @brief Accessor and modifier functions for the %propActive
     * optional attribute with a default value.
     *
     * The proportion of bites for which the IRS
     * has any action whatsoever on the mosquito.
     * 
     * At the moment this is constant across humans and deterministic:
     * relative attractiveness and survival factors are
     * base*(1-propActing) + intervention_factor*propActing.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double PropActiveType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PropActiveType, char, ::xsd::cxx::tree::schema_type::double_ > PropActiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const PropActiveType&
    getPropActive () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    PropActiveType&
    getPropActive ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setPropActive (const PropActiveType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static PropActiveType
    getPropActiveDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AnophelesParams11 (const MosquitoType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AnophelesParams11 (const xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AnophelesParams11 (const AnophelesParams11& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AnophelesParams11*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AnophelesParams11&
    operator= (const AnophelesParams11& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AnophelesParams11 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DeterrencyOptional deterrency_;
    PreprandialKillingEffectOptional preprandialKillingEffect_;
    PostprandialKillingEffectOptional postprandialKillingEffect_;
    FecundityReductionOptional fecundityReduction_;
    ::xsd::cxx::tree::one< MosquitoType > mosquito_;
    ::xsd::cxx::tree::one< PropActiveType > propActive_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %anophelesParams2 schema type.
   *
   * @nosubgrouping
   */
  class AnophelesParams2: public ::xml_schema::Type
  {
    public:
    /**
     * @name deterrency
     *
     * @brief Accessor and modifier functions for the %deterrency
     * required element.
     *
     * Effect of IRS on attractiveness of humans to mosquitoes relative to
     * an unprotected adult human. Parameterisations should take into
     * account that mosquitoes do not always bite indoors.
     * 
     * Attractiveness of the human is multiplied by exp(P?log(p))
     * where P is the insecticide factor,
     * p=1?exp(-insecticideContent?insecticideScalingFactor).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::IRSDeterrency DeterrencyType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeterrencyType, char > DeterrencyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DeterrencyType&
    getDeterrency () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DeterrencyType&
    getDeterrency ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDeterrency (const DeterrencyType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDeterrency (::std::unique_ptr< DeterrencyType > p);

    //@}

    /**
     * @name preprandialKillingEffect
     *
     * @brief Accessor and modifier functions for the %preprandialKillingEffect
     * required element.
     *
     * Effect of IRS on survival mosquitoes as they seek to bite a human
     * after choosing that human, relative to the same person not
     * protected by IRS. Parameterisations should take into account
     * that mosquitoes do not always bite indoors. This parameter has
     * been added since some data shows IRS to have a preprandial
     * killing effect.
     * 
     * Killing proportion is calculated as K = B + P?p where B is the
     * base (without protection) probability of death, and P is the
     * insecticide factor,
     * p=1?exp(-insecticideContent?insecticideScalingFactor).
     * 
     * Survival of mosquitoes is adjusted via multiplication by (1?K) /
     * (1?B).
     * To keep this in the range [0,1], we require that B+P ? 1 and P ? 0.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::IRSKillingEffect PreprandialKillingEffectType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PreprandialKillingEffectType, char > PreprandialKillingEffectTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PreprandialKillingEffectType&
    getPreprandialKillingEffect () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PreprandialKillingEffectType&
    getPreprandialKillingEffect ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPreprandialKillingEffect (const PreprandialKillingEffectType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPreprandialKillingEffect (::std::unique_ptr< PreprandialKillingEffectType > p);

    //@}

    /**
     * @name postprandialKillingEffect
     *
     * @brief Accessor and modifier functions for the %postprandialKillingEffect
     * required element.
     *
     * Effect of IRS on survival mosquitoes as they seek to escape from
     * a human host and rest after a blood meal, relative to the same
     * person not protected by IRS. Parameterisations should take
     * into account that mosquitoes do not always bite indoors.
     * 
     * Killing proportion is calculated as K = B + P?p where B is the
     * base (without protection) probability of death, and P is the
     * insecticide factor,
     * p=1?exp(-insecticideContent?insecticideScalingFactor).
     * 
     * Survival of mosquitoes is adjusted via multiplication by (1?K) /
     * (1?B).
     * To keep this in the range [0,1], we require that B+P ? 1 and P ? 0.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::IRSKillingEffect PostprandialKillingEffectType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PostprandialKillingEffectType, char > PostprandialKillingEffectTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PostprandialKillingEffectType&
    getPostprandialKillingEffect () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PostprandialKillingEffectType&
    getPostprandialKillingEffect ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPostprandialKillingEffect (const PostprandialKillingEffectType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPostprandialKillingEffect (::std::unique_ptr< PostprandialKillingEffectType > p);

    //@}

    /**
     * @name fecundityReduction
     *
     * @brief Accessor and modifier functions for the %fecundityReduction
     * optional element.
     *
     * Effect of IRS on fertility mosquitoes after successfully feeding on
     * a human host, relative to an unproteced human. Parameterisations
     * should take
     * into account that mosquitoes do not always bite indoors.
     * 
     * First, we calculate K = B + P?p where B is the
     * base (without protection) probability of death, and P is the
     * insecticide factor,
     * p=1?exp(-insecticideContent?insecticideScalingFactor).
     * 
     * Fecundity is multiplied by (1?K) / (1?B). It is not allowed to be
     * greater than 1.
     * To keep this in the range [0,1], we require that B+P ? 1 and P ? 0.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::IRSKillingEffect FecundityReductionType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< FecundityReductionType > FecundityReductionOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FecundityReductionType, char > FecundityReductionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const FecundityReductionOptional&
    getFecundityReduction () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    FecundityReductionOptional&
    getFecundityReduction ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFecundityReduction (const FecundityReductionType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setFecundityReduction (const FecundityReductionOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setFecundityReduction (::std::unique_ptr< FecundityReductionType > p);

    //@}

    /**
     * @name mosquito
     *
     * @brief Accessor and modifier functions for the %mosquito
     * required attribute.
     *
     * Name of the affected anopheles-mosquito species.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String MosquitoType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MosquitoType, char > MosquitoTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MosquitoType&
    getMosquito () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MosquitoType&
    getMosquito ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMosquito (const MosquitoType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMosquito (::std::unique_ptr< MosquitoType > p);

    //@}

    /**
     * @name propActive
     *
     * @brief Accessor and modifier functions for the %propActive
     * optional attribute with a default value.
     *
     * The proportion of bites for which the IRS
     * has any action whatsoever on the mosquito.
     * 
     * At the moment this is constant across humans and deterministic:
     * relative attractiveness and survival factors are
     * base*(1-propActing) + intervention_factor*propActing.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double PropActiveType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PropActiveType, char, ::xsd::cxx::tree::schema_type::double_ > PropActiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const PropActiveType&
    getPropActive () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    PropActiveType&
    getPropActive ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setPropActive (const PropActiveType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static PropActiveType
    getPropActiveDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AnophelesParams2 (const DeterrencyType&,
                      const PreprandialKillingEffectType&,
                      const PostprandialKillingEffectType&,
                      const MosquitoType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    AnophelesParams2 (::std::unique_ptr< DeterrencyType >,
                      ::std::unique_ptr< PreprandialKillingEffectType >,
                      ::std::unique_ptr< PostprandialKillingEffectType >,
                      const MosquitoType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AnophelesParams2 (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AnophelesParams2 (const AnophelesParams2& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AnophelesParams2*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AnophelesParams2&
    operator= (const AnophelesParams2& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AnophelesParams2 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DeterrencyType > deterrency_;
    ::xsd::cxx::tree::one< PreprandialKillingEffectType > preprandialKillingEffect_;
    ::xsd::cxx::tree::one< PostprandialKillingEffectType > postprandialKillingEffect_;
    FecundityReductionOptional fecundityReduction_;
    ::xsd::cxx::tree::one< MosquitoType > mosquito_;
    ::xsd::cxx::tree::one< PropActiveType > propActive_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %seekingDeathRateIncrease schema type.
   *
   * @nosubgrouping
   */
  class SeekingDeathRateIncrease: public ::xml_schema::Type
  {
    public:
    /**
     * @name decay
     *
     * @brief Accessor and modifier functions for the %decay
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecayFunction DecayType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DecayType, char > DecayTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DecayType&
    getDecay () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DecayType&
    getDecay ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDecay (const DecayType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDecay (::std::unique_ptr< DecayType > p);

    //@}

    /**
     * @name initial
     *
     * @brief Accessor and modifier functions for the %initial
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double InitialType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InitialType, char, ::xsd::cxx::tree::schema_type::double_ > InitialTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const InitialType&
    getInitial () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    InitialType&
    getInitial ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInitial (const InitialType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SeekingDeathRateIncrease (const DecayType&,
                              const InitialType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    SeekingDeathRateIncrease (::std::unique_ptr< DecayType >,
                              const InitialType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SeekingDeathRateIncrease (const xercesc::DOMElement& e,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SeekingDeathRateIncrease (const SeekingDeathRateIncrease& x,
                              ::xml_schema::Flags f = 0,
                              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SeekingDeathRateIncrease*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SeekingDeathRateIncrease&
    operator= (const SeekingDeathRateIncrease& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SeekingDeathRateIncrease ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DecayType > decay_;
    ::xsd::cxx::tree::one< InitialType > initial_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %probDeathOvipositing schema type.
   *
   * @nosubgrouping
   */
  class ProbDeathOvipositing: public ::xml_schema::Type
  {
    public:
    /**
     * @name decay
     *
     * @brief Accessor and modifier functions for the %decay
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecayFunction DecayType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DecayType, char > DecayTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DecayType&
    getDecay () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DecayType&
    getDecay ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDecay (const DecayType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDecay (::std::unique_ptr< DecayType > p);

    //@}

    /**
     * @name initial
     *
     * @brief Accessor and modifier functions for the %initial
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double InitialType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InitialType, char, ::xsd::cxx::tree::schema_type::double_ > InitialTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const InitialType&
    getInitial () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    InitialType&
    getInitial ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInitial (const InitialType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ProbDeathOvipositing (const DecayType&,
                          const InitialType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    ProbDeathOvipositing (::std::unique_ptr< DecayType >,
                          const InitialType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ProbDeathOvipositing (const xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ProbDeathOvipositing (const ProbDeathOvipositing& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ProbDeathOvipositing*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ProbDeathOvipositing&
    operator= (const ProbDeathOvipositing& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ProbDeathOvipositing ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DecayType > decay_;
    ::xsd::cxx::tree::one< InitialType > initial_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %emergenceReduction schema type.
   *
   * @nosubgrouping
   */
  class EmergenceReduction: public ::xml_schema::Type
  {
    public:
    /**
     * @name decay
     *
     * @brief Accessor and modifier functions for the %decay
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecayFunction DecayType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DecayType, char > DecayTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DecayType&
    getDecay () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DecayType&
    getDecay ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDecay (const DecayType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDecay (::std::unique_ptr< DecayType > p);

    //@}

    /**
     * @name initial
     *
     * @brief Accessor and modifier functions for the %initial
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double InitialType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InitialType, char, ::xsd::cxx::tree::schema_type::double_ > InitialTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const InitialType&
    getInitial () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    InitialType&
    getInitial ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInitial (const InitialType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    EmergenceReduction (const DecayType&,
                        const InitialType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    EmergenceReduction (::std::unique_ptr< DecayType >,
                        const InitialType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    EmergenceReduction (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EmergenceReduction (const EmergenceReduction& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual EmergenceReduction*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    EmergenceReduction&
    operator= (const EmergenceReduction& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~EmergenceReduction ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DecayType > decay_;
    ::xsd::cxx::tree::one< InitialType > initial_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %timedDeployment schema type.
   *
   * @nosubgrouping
   */
  class TimedDeployment: public ::scnXml::HealthSystem
  {
    public:
    /**
     * @name time
     *
     * @brief Accessor and modifier functions for the %time
     * required attribute.
     *
     * Time at which this replacement occurs. See doc on
     * intervention period and on monitoring/startDate for
     * details of how times work.
     * 
     * Can be specified in steps, days, years, or as a date
     * (examples: 15t, 75d, 0.2y, 2000-03-16).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String TimeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeType, char > TimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const TimeType&
    getTime () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    TimeType&
    getTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTime (const TimeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTime (::std::unique_ptr< TimeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimedDeployment (const CFRType&,
                     const PSequelaeInpatientType&,
                     const TimeType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    TimedDeployment (::std::unique_ptr< CFRType >,
                     ::std::unique_ptr< PSequelaeInpatientType >,
                     const TimeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimedDeployment (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimedDeployment (const TimedDeployment& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimedDeployment*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimedDeployment&
    operator= (const TimedDeployment& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimedDeployment ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TimeType > time_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %timedDeployment1 schema type.
   *
   * @nosubgrouping
   */
  class TimedDeployment1: public ::scnXml::NonVector
  {
    public:
    /**
     * @name time
     *
     * @brief Accessor and modifier functions for the %time
     * required attribute.
     *
     * Time at which this replacement occurs. See doc on
     * intervention period and on monitoring/startDate for
     * details of how times work.
     * 
     * Can be specified in steps, days, years, or as a date
     * (examples: 15t, 75d, 0.2y, 2000-03-16).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String TimeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeType, char > TimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const TimeType&
    getTime () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    TimeType&
    getTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTime (const TimeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTime (::std::unique_ptr< TimeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimedDeployment1 (const EipDurationType&,
                      const TimeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimedDeployment1 (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimedDeployment1 (const TimedDeployment1& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimedDeployment1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimedDeployment1&
    operator= (const TimedDeployment1& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimedDeployment1 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TimeType > time_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %timed1 schema type.
   *
   * @nosubgrouping
   */
  class Timed1: public ::xml_schema::Type
  {
    public:
    /**
     * @name rate
     *
     * @brief Accessor and modifier functions for the %rate
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Rate RateType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RateType > RateSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< RateType >::iterator RateIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< RateType >::const_iterator RateConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RateType, char > RateTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RateSequence&
    getRate () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RateSequence&
    getRate ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRate (const RateSequence& s);

    //@}

    /**
     * @name period
     *
     * @brief Accessor and modifier functions for the %period
     * optional attribute with a default value.
     *
     * If period is 0 (or effectively infinite), the last specified
     * value remains indefinitely in effect, otherwise the times of
     * all values specified must be less than the period, and values
     * are repeated modulo period (the step at time 'period+2t'
     * has same value as the step at '2t', etc.).
     * 
     * Can be specified in steps (e.g. 1t) or days (e.g. 365d).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String PeriodType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PeriodType, char > PeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const PeriodType&
    getPeriod () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    PeriodType&
    getPeriod ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setPeriod (const PeriodType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPeriod (::std::unique_ptr< PeriodType > p);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return A read-only (constant) reference to the attribute's
     * default value.
     */
    static const PeriodType&
    getPeriodDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Timed1 ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Timed1 (const xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Timed1 (const Timed1& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Timed1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Timed1&
    operator= (const Timed1& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Timed1 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RateSequence rate_;
    ::xsd::cxx::tree::one< PeriodType > period_;
    static const PeriodType period_default_value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %timedDeployment2 schema type.
   *
   * @nosubgrouping
   */
  class TimedDeployment2: public ::xml_schema::Type
  {
    public:
    /**
     * @name time
     *
     * @brief Accessor and modifier functions for the %time
     * required attribute.
     *
     * Time at which this intervention occurs.
     * 
     * See doc on intervention period and on monitoring/startDate for
     * details of how times work. Can be specified in steps, days,
     * years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String TimeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeType, char > TimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const TimeType&
    getTime () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    TimeType&
    getTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTime (const TimeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTime (::std::unique_ptr< TimeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TimedDeployment2 (const TimeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TimedDeployment2 (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimedDeployment2 (const TimedDeployment2& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TimedDeployment2*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TimedDeployment2&
    operator= (const TimedDeployment2& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TimedDeployment2 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TimeType > time_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %condition schema type.
   *
   * @nosubgrouping
   */
  class Condition: public ::xml_schema::Type
  {
    public:
    /**
     * @name measure
     *
     * @brief Accessor and modifier functions for the %measure
     * required attribute.
     *
     * The monitoring measure to test. Not all measures are available for
    use. */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String MeasureType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MeasureType, char > MeasureTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MeasureType&
    getMeasure () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MeasureType&
    getMeasure ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMeasure (const MeasureType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setMeasure (::std::unique_ptr< MeasureType > p);

    //@}

    /**
     * @name minValue
     *
     * @brief Accessor and modifier functions for the %minValue
     * optional attribute.
     *
     * Minimum value. If specified, the measured variable must be greater
     * than 
     * or equal to this value for the condition to be satisfied.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MinValueType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MinValueType > MinValueOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MinValueType, char, ::xsd::cxx::tree::schema_type::double_ > MinValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MinValueOptional&
    getMinValue () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MinValueOptional&
    getMinValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMinValue (const MinValueType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMinValue (const MinValueOptional& x);

    //@}

    /**
     * @name maxValue
     *
     * @brief Accessor and modifier functions for the %maxValue
     * optional attribute.
     *
     * Maximum value. If specified, the measured variable must be less than
     * or
     * equal to this value for the condition to be satisfied.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxValueType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxValueType > MaxValueOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxValueType, char, ::xsd::cxx::tree::schema_type::double_ > MaxValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxValueOptional&
    getMaxValue () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxValueOptional&
    getMaxValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxValue (const MaxValueType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxValue (const MaxValueOptional& x);

    //@}

    /**
     * @name initialState
     *
     * @brief Accessor and modifier functions for the %initialState
     * required attribute.
     *
     * Whether this condition is considered true or false before updated by a
     * survey.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean InitialStateType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InitialStateType, char > InitialStateTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const InitialStateType&
    getInitialState () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    InitialStateType&
    getInitialState ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInitialState (const InitialStateType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Condition (const MeasureType&,
               const InitialStateType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Condition (const xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Condition (const Condition& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Condition*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Condition&
    operator= (const Condition& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Condition ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MeasureType > measure_;
    MinValueOptional minValue_;
    MaxValueOptional maxValue_;
    ::xsd::cxx::tree::one< InitialStateType > initialState_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %deploy1 schema type.
   *
   * @nosubgrouping
   */
  class Deploy1: public ::scnXml::TimedBase
  {
    public:
    /**
     * @name ratioToHumans
     *
     * @brief Accessor and modifier functions for the %ratioToHumans
     * required attribute.
     *
     * The number of traps deployed, by this
     * deployment, per adult human.
     * 
     * E.g. if there are currently 100 traps and 1000
     * humans, then a ratio of 0.1 will increase the
     * number of traps to 200.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double RatioToHumansType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RatioToHumansType, char, ::xsd::cxx::tree::schema_type::double_ > RatioToHumansTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const RatioToHumansType&
    getRatioToHumans () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    RatioToHumansType&
    getRatioToHumans ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRatioToHumans (const RatioToHumansType& x);

    //@}

    /**
     * @name lifespan
     *
     * @brief Accessor and modifier functions for the %lifespan
     * required attribute.
     *
     * Life of the trap until replaced or removed, e.g.
     * "73t" or "1y". After this time period, these traps
     * will be removed from the simulation.
     * 
     * New deployments do not automatically remove old
     * traps. Existing traps cannot be refurbished in the
     * model. It may make sense to make the end-of-life
     * coincide with a new deployment.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String LifespanType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LifespanType, char > LifespanTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const LifespanType&
    getLifespan () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    LifespanType&
    getLifespan ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLifespan (const LifespanType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setLifespan (::std::unique_ptr< LifespanType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Deploy1 (const TimeType&,
             const RatioToHumansType&,
             const LifespanType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Deploy1 (const xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Deploy1 (const Deploy1& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Deploy1*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Deploy1&
    operator= (const Deploy1& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Deploy1 ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< RatioToHumansType > ratioToHumans_;
    ::xsd::cxx::tree::one< LifespanType > lifespan_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %twoStageDeterrency schema type.
   *
   * @nosubgrouping
   */
  class TwoStageDeterrency: public ::xml_schema::Type
  {
    public:
    /**
     * @name entering
     *
     * @brief Accessor and modifier functions for the %entering
     * optional element.
     *
     * pEnt represents the relative probability of entering due to
     * ITNs: pEnt = exp(log(P)?p) where P is the insecticide
     * factor and 
     * p=1?exp(-insecticideContent?insecticideScalingFactor).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::IRSDeterrency EnteringType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EnteringType > EnteringOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EnteringType, char > EnteringTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EnteringOptional&
    getEntering () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    EnteringOptional&
    getEntering ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEntering (const EnteringType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEntering (const EnteringOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEntering (::std::unique_ptr< EnteringType > p);

    //@}

    /**
     * @name enteringLogit
     *
     * @brief Accessor and modifier functions for the %enteringLogit
     * optional element.
     *
     * pEnt represents the relative probability of entering due to
     * insecticide
     * in the hut:
     * pEnt = exp(logit.pEnt) / (exp(logit.pEnt) + 1)
     * logit.pEnt = B + P * p
     * where B is the basefactor (without net); P is insecticide factor, and
     * p = log(insecticideContent+1).
     * Without a net, probability of entering a house is
     * pEnt0 = exp(logit.pEnt0) / (exp(logit.pEnt0) + 1)
     * logit.pEnt0 = B
     * Entering of mosquitoes is adjusted via multiplication by pEnt / pEnt0.
     * To keep this in the range [0,1], we (normally) require that
     * pEnt ? pEnt0
     * and thus P ? 0 and give a warning if this is not fulfilled.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ITNEnteringDeterrencyLogit EnteringLogitType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EnteringLogitType > EnteringLogitOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EnteringLogitType, char > EnteringLogitTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EnteringLogitOptional&
    getEnteringLogit () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    EnteringLogitOptional&
    getEnteringLogit ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEnteringLogit (const EnteringLogitType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEnteringLogit (const EnteringLogitOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEnteringLogit (::std::unique_ptr< EnteringLogitType > p);

    //@}

    /**
     * @name attacking
     *
     * @brief Accessor and modifier functions for the %attacking
     * optional element.
     *
     * pAtt represents the relative probability of attacking a human after
     * entering a house due to ITNs (i.e. of feeding/dying vs. flying off):
     * pAtt = B + H?h + P?p + I?h?p
     * where B is the base (without net) probability; H, P and I are the
     * hole,
     * insecticide and interaction factors respectively,
     * h=exp(-holeIndex ? holeScalingFactor)
     * and
     * p=1 - exp(-insecticideContent ? insecticideScalingFactor).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ITNKillingEffect AttackingType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AttackingType > AttackingOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AttackingType, char > AttackingTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AttackingOptional&
    getAttacking () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AttackingOptional&
    getAttacking ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAttacking (const AttackingType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAttacking (const AttackingOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAttacking (::std::unique_ptr< AttackingType > p);

    //@}

    /**
     * @name attackingLogit
     *
     * @brief Accessor and modifier functions for the %attackingLogit
     * optional element.
     *
     * pAtt represents the relative probability of attacking a human
     * after entering a house due to ITNs (i.e. of feeding/dying vs.
     * flying off):
     * pAtt = exp(logit.pAtt) / (exp(logit.pAtt) + 1)
     * logit.pAtt = B + H?min(h, hMax) + P?p + I?min(h, hMax)?p
     * where B is the base factor (without net); H, P and
     * I are the hole, insecticide and interaction factors
     * respectively, and:
     * h = log(holeIndex + 1)
     * p = log(insecticideContent + 1)
     * Without a net, probability of attacking a human
     * after entering a house is
     * pAtt0 = exp(logit.pAtt0) / (exp(logit.pAtt0) + 1)
     * logit.pAtt0 = B + H?hMax
     * where hMax=log(holeIndexMax + 1) and holeIndexMax is a user defined
     * maximum hole index (typically, the total surface area of a net).
     * Attacking of mosquitoes is adjusted via multiplication by pAtt /
     * pAtt0.
     * This may be larger and smaller than 1 (but will not be negative).
     * By definition (through the logit transformation) pAtt0 > 0.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ITNEffectLogit AttackingLogitType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AttackingLogitType > AttackingLogitOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AttackingLogitType, char > AttackingLogitTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AttackingLogitOptional&
    getAttackingLogit () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AttackingLogitOptional&
    getAttackingLogit ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAttackingLogit (const AttackingLogitType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAttackingLogit (const AttackingLogitOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAttackingLogit (::std::unique_ptr< AttackingLogitType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TwoStageDeterrency ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TwoStageDeterrency (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TwoStageDeterrency (const TwoStageDeterrency& x,
                        ::xml_schema::Flags f = 0,
                        ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TwoStageDeterrency*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TwoStageDeterrency&
    operator= (const TwoStageDeterrency& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TwoStageDeterrency ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    EnteringOptional entering_;
    EnteringLogitOptional enteringLogit_;
    AttackingOptional attacking_;
    AttackingLogitOptional attackingLogit_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %rate schema type.
   *
   * @nosubgrouping
   */
  class Rate: public ::scnXml::DoubleValue
  {
    public:
    /**
     * @name time
     *
     * @brief Accessor and modifier functions for the %time
     * required attribute.
     *
     * Time at which this importation rate becomes active.
     * 
     * See doc on intervention period and on monitoring/startDate for
     * details of how times work. Can be specified in steps, days,
     * years, or as a date (examples: 15t, 75d, 0.2y, 2000-03-16).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String TimeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimeType, char > TimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const TimeType&
    getTime () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    TimeType&
    getTime ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTime (const TimeType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTime (::std::unique_ptr< TimeType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Rate (const ValueType&,
          const TimeType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Rate (const xercesc::DOMElement& e,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Rate (const Rate& x,
          ::xml_schema::Flags f = 0,
          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Rate*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Rate&
    operator= (const Rate& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Rate ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TimeType > time_;

    //@endcond
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace scnXml
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_CODE_OPENMALARIA_SCHEMA_INTERVENTIONS_H

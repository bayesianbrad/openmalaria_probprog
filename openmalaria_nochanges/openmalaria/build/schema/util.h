// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from util.xsd.
 */

#ifndef CXX_CODE_OPENMALARIA_SCHEMA_UTIL_H
#define CXX_CODE_OPENMALARIA_SCHEMA_UTIL_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type Type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type Container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char Byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char UnsignedByte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short Short;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short UnsignedShort;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int Int;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int UnsignedInt;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long Long;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long UnsignedLong;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long Integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long NonPositiveInteger;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long NonNegativeInteger;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long PositiveInteger;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long NegativeInteger;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool Boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float Float;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double Double;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double Decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, Token > Name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, Token > Language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > Buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone TimeZone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags Flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity Severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > Error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > Exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > Bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > Parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace scnXml
{
  class Component;
  class TriggeredDeployments;
  class OptionSet;
  class Option;
  class DoubleList;
  class DecayFunction;
  class LognormalSample;
  class NormalSample;
  class BetaMeanSample;
  class SampledValue;
  class DoubleValue;
  class IntValue;
  class BooleanValue;
  class AgeGroupValues;
  class Deploy;
  class Function;
  class Distr;
  class Group;
  class Interpolation;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

/**
 * @brief C++ namespace for the %http://openmalaria.org/schema/scenario_39
 * schema namespace.
 */
namespace scnXml
{
  /**
   * @brief Class corresponding to the %Component schema type.
   *
   * The list of components deployed to eligible humans.
   *
   * @nosubgrouping
   */
  class Component: public ::xml_schema::Type
  {
    public:
    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     *
     * The identifier (short name) of a component.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::unique_ptr< IdType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Component (const IdType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Component (const xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Component (const Component& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Component*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Component&
    operator= (const Component& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Component ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IdType > id_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TriggeredDeployments schema type.
   *
   * Lists intervention components which are deployed according to some
   * external trigger (for example, screening with a negative patency
   * outcome or health-system treatment).
   * 
   * Components are referenced from one or more sub-lists. Each of these
   * lists is deployed independently if and only if its age constraints are
   * met by the human host and a random sample with the given probability
   * of
   * a positive outcome is positive.
   *
   * @nosubgrouping
   */
  class TriggeredDeployments: public ::xml_schema::Type
  {
    public:
    /**
     * @name deploy
     *
     * @brief Accessor and modifier functions for the %deploy
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Deploy DeployType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DeployType > DeploySequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::iterator DeployIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::const_iterator DeployConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeployType, char > DeployTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DeploySequence&
    getDeploy () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DeploySequence&
    getDeploy ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDeploy (const DeploySequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TriggeredDeployments ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TriggeredDeployments (const xercesc::DOMElement& e,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TriggeredDeployments (const TriggeredDeployments& x,
                          ::xml_schema::Flags f = 0,
                          ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TriggeredDeployments*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TriggeredDeployments&
    operator= (const TriggeredDeployments& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TriggeredDeployments ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    DeploySequence deploy_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %OptionSet schema type.
   *
   * @nosubgrouping
   */
  class OptionSet: public ::xml_schema::Type
  {
    public:
    /**
     * @name option
     *
     * @brief Accessor and modifier functions for the %option
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Option OptionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< OptionType > OptionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< OptionType >::iterator OptionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< OptionType >::const_iterator OptionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OptionType, char > OptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const OptionSequence&
    getOption () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    OptionSequence&
    getOption ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setOption (const OptionSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    OptionSet ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    OptionSet (const xercesc::DOMElement& e,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OptionSet (const OptionSet& x,
               ::xml_schema::Flags f = 0,
               ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual OptionSet*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    OptionSet&
    operator= (const OptionSet& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~OptionSet ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    OptionSequence option_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Option schema type.
   *
   * @nosubgrouping
   */
  class Option: public ::xml_schema::Type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     *
     * Name of an option (monitoring measure or model option).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * optional attribute with a default value.
     *
     * Option on/off switch (true/false). Specifying value="true" is
     * the same as not specifying a value; specifying value="false"
     * explicitly turns the option off. If an option is not mentioned
     * at all, it is left at its default value (normally off, but
     * in a few cases, such as some bug-fix options, on).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean ValueType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValue (const ValueType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static ValueType
    getValueDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Option (const NameType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Option (const xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Option (const Option& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Option*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Option&
    operator= (const Option& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Option ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< NameType > name_;
    ::xsd::cxx::tree::one< ValueType > value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DoubleList schema type.
   *
   * @nosubgrouping
   */
  class DoubleList: public ::xml_schema::Type
  {
    public:
    /**
     * @name item
     *
     * @brief Accessor and modifier functions for the %item
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double ItemType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ItemType > ItemSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< ItemType >::iterator ItemIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< ItemType >::const_iterator ItemConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ItemType, char, ::xsd::cxx::tree::schema_type::double_ > ItemTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ItemSequence&
    getItem () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ItemSequence&
    getItem ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setItem (const ItemSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DoubleList ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DoubleList (const xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DoubleList (const DoubleList& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DoubleList*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DoubleList&
    operator= (const DoubleList& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DoubleList ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ItemSequence item_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DecayFunction schema type.
   *
   * Specification of decay or survival of a parameter.
   *
   * @nosubgrouping
   */
  class DecayFunction: public ::xml_schema::Type
  {
    public:
    /**
     * @name function
     *
     * @brief Accessor and modifier functions for the %function
     * required attribute.
     *
     * Determines which decay function to use. Available decay functions,
     * for age t in years:
     * 
     * constant: 1
     * 
     * step: 1 for t less than L, otherwise 0
     * 
     * linear: 1 - t/L for t less than L, otherwise 0
     * 
     * exponential: exp( - t/L * log(2) )
     * 
     * weibull: exp( -(t/L)^k * log(2) )
     * 
     * hill: 1 / (1 + (t/L)^k)
     * 
     * smooth-compact: exp( k - k / (1 - (t/L)^2) ) for t less than L,
     * otherwise 0
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::scnXml::Function FunctionType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< FunctionType, char > FunctionTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const FunctionType&
    getFunction () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    FunctionType&
    getFunction ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setFunction (const FunctionType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setFunction (::std::unique_ptr< FunctionType > p);

    //@}

    /**
     * @name L
     *
     * @brief Accessor and modifier functions for the %L
     * optional attribute.
     *
     * (Time) scale parameter of distribution: this is either the age of
     * complete decay (smooth-compact, step and linear functions) or the age
     * at which the parameter has decayed to half its original value
     * (exponential, weibull and hill). Not used when function="constant"
     * (i.e. no decay).
     * 
     * This value can be specified in years, days or steps (e.g. 2y, 180d or
     * 100t). When the unit is not specified years are assumed. The value is
     * used without rounding except when sampling an age of decay, when the
     * rounding happens as late as possible.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String LType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LType > LOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LType, char > LTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LOptional&
    getL () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    LOptional&
    getL ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setL (const LType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setL (const LOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setL (::std::unique_ptr< LType > p);

    //@}

    /**
     * @name k
     *
     * @brief Accessor and modifier functions for the %k
     * optional attribute with a default value.
     *
     * Shape parameter of distribution. If not specified, default value of
     * 1 is used. Meaning depends on function; not used in some cases.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double KType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< KType, char, ::xsd::cxx::tree::schema_type::double_ > KTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const KType&
    getK () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    KType&
    getK ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setK (const KType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static KType
    getKDefaultValue ();

    //@}

    /**
     * @name mu
     *
     * @brief Accessor and modifier functions for the %mu
     * optional attribute with a default value.
     *
     * If sigma is non-zero, heterogeneity of decay is introduced via a
     * random
     * variable sampled from the log-normal distribution with mu and sigma as
     * specified. Both mu and sigma default to zero when not specified.
     * 
     * The decay rate is multiplied by this variable (effectively, the
     * half-life is divided by it).
     * 
     * Note that with m=0, the median of the variable and the median value of
     * L is unchanged, and thus the time at which the median decay amongst
     * the
     * population of decaying objects reaches half (assuming exponential,
     * Weibull or Hill decay) is L. With m=-??? (negative half sigma squared)
     * the mean of the variable will be 1 and mean of the half-life L, but
     * the
     * time at which mean decay of the population has reached half may not be
     * L.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MuType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MuType, char, ::xsd::cxx::tree::schema_type::double_ > MuTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MuType&
    getMu () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MuType&
    getMu ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMu (const MuType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static MuType
    getMuDefaultValue ();

    //@}

    /**
     * @name sigma
     *
     * @brief Accessor and modifier functions for the %sigma
     * optional attribute with a default value.
     *
     * If sigma is non-zero, heterogeneity of decay is introduced via a
     * random
     * variable sampled from the log-normal distribution with mu and sigma as
     * specified. Both mu and sigma default to zero when not specified.
     * 
     * The decay rate is multiplied by this variable (effectively, the
     * half-life is divided by it).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double SigmaType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SigmaType, char, ::xsd::cxx::tree::schema_type::double_ > SigmaTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const SigmaType&
    getSigma () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    SigmaType&
    getSigma ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSigma (const SigmaType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static SigmaType
    getSigmaDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DecayFunction (const FunctionType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DecayFunction (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DecayFunction (const DecayFunction& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DecayFunction*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DecayFunction&
    operator= (const DecayFunction& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DecayFunction ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< FunctionType > function_;
    LOptional L_;
    ::xsd::cxx::tree::one< KType > k_;
    ::xsd::cxx::tree::one< MuType > mu_;
    ::xsd::cxx::tree::one< SigmaType > sigma_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LognormalSample schema type.
   *
   * Parameters of a log-normal distribution.
   * 
   * Variates are sampled as: X ~ ln N( log(mean)-sigma?/2, sigma? ).
   * 
   * Equivalent R sample: rlnorm(n, log(m) - s*s/2, s)
   *
   * @nosubgrouping
   */
  class LognormalSample: public ::xml_schema::Type
  {
    public:
    /**
     * @name mean
     *
     * @brief Accessor and modifier functions for the %mean
     * required attribute.
     *
     * The mean of the lognormal distribution.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MeanType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MeanType, char, ::xsd::cxx::tree::schema_type::double_ > MeanTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MeanType&
    getMean () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MeanType&
    getMean ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMean (const MeanType& x);

    //@}

    /**
     * @name sigma
     *
     * @brief Accessor and modifier functions for the %sigma
     * required attribute.
     *
     * Sigma parameter of the lognormal distribution; sigma squared is the
     * variance of the log of samples.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double SigmaType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SigmaType, char, ::xsd::cxx::tree::schema_type::double_ > SigmaTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const SigmaType&
    getSigma () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    SigmaType&
    getSigma ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSigma (const SigmaType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LognormalSample (const MeanType&,
                     const SigmaType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LognormalSample (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LognormalSample (const LognormalSample& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LognormalSample*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LognormalSample&
    operator= (const LognormalSample& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LognormalSample ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MeanType > mean_;
    ::xsd::cxx::tree::one< SigmaType > sigma_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NormalSample schema type.
   *
   * Parameters of a normal distribution.
   * 
   * Variates are sampled as: X ~ N( mu, sigma? ).
   *
   * @nosubgrouping
   */
  class NormalSample: public ::xml_schema::Type
  {
    public:
    /**
     * @name mu
     *
     * @brief Accessor and modifier functions for the %mu
     * required attribute.
     *
     * The mean of the normal distribution.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MuType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MuType, char, ::xsd::cxx::tree::schema_type::double_ > MuTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MuType&
    getMu () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MuType&
    getMu ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMu (const MuType& x);

    //@}

    /**
     * @name sigma
     *
     * @brief Accessor and modifier functions for the %sigma
     * required attribute.
     *
     * The standard deviation of variates.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double SigmaType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SigmaType, char, ::xsd::cxx::tree::schema_type::double_ > SigmaTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const SigmaType&
    getSigma () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    SigmaType&
    getSigma ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSigma (const SigmaType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NormalSample (const MuType&,
                  const SigmaType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NormalSample (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NormalSample (const NormalSample& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NormalSample*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NormalSample&
    operator= (const NormalSample& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NormalSample ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MuType > mu_;
    ::xsd::cxx::tree::one< SigmaType > sigma_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BetaMeanSample schema type.
   *
   * Parameters of a normal distribution, provided as mean and variance.
   * 
   * Variates are sampled from Be(?,?) where ? and ? are determined from
   * the
   * mean and variance as follows: let v be the variance and
   * c=mean/(1-mean).
   * Then we set ?=c? and ?=((c+1)?v - c)/((c+1)?v).
   *
   * @nosubgrouping
   */
  class BetaMeanSample: public ::xml_schema::Type
  {
    public:
    /**
     * @name mean
     *
     * @brief Accessor and modifier functions for the %mean
     * required attribute.
     *
     * The mean of the beta distribution (must be in the open range (0,1)).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MeanType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MeanType, char, ::xsd::cxx::tree::schema_type::double_ > MeanTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MeanType&
    getMean () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MeanType&
    getMean ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMean (const MeanType& x);

    //@}

    /**
     * @name variance
     *
     * @brief Accessor and modifier functions for the %variance
     * required attribute.
     *
     * The standard deviation of variates.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double VarianceType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< VarianceType, char, ::xsd::cxx::tree::schema_type::double_ > VarianceTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const VarianceType&
    getVariance () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    VarianceType&
    getVariance ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setVariance (const VarianceType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BetaMeanSample (const MeanType&,
                    const VarianceType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BetaMeanSample (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BetaMeanSample (const BetaMeanSample& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BetaMeanSample*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BetaMeanSample&
    operator= (const BetaMeanSample& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BetaMeanSample ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MeanType > mean_;
    ::xsd::cxx::tree::one< VarianceType > variance_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %SampledValue schema type.
   *
   * Parameters of some distribution. The mean is that provided and the
   * standard deviation is cv*mean.
   * 
   * Log-normal:
   * ? = cv * mean ;
   * ? = ln(mean) - ?? / 2 ;
   * X ~ ln N( ?, ?? ) ;
   * equivalent R sample: rlnorm(1, log(mean) - ((cv * mean)^2) / 2, cv *
   * mean).
   *
   * @nosubgrouping
   */
  class SampledValue: public ::xml_schema::Type
  {
    public:
    /**
     * @name mean
     *
     * @brief Accessor and modifier functions for the %mean
     * required attribute.
     *
     * The mean of the distribution.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MeanType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MeanType, char, ::xsd::cxx::tree::schema_type::double_ > MeanTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MeanType&
    getMean () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MeanType&
    getMean ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMean (const MeanType& x);

    //@}

    /**
     * @name cv
     *
     * @brief Accessor and modifier functions for the %cv
     * optional attribute.
     *
     * Coefficient of variance (mean * cv gives standard deviation).
     * 
     * Must be specified when distribution is not constant.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double CvType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CvType > CvOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< CvType, char, ::xsd::cxx::tree::schema_type::double_ > CvTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CvOptional&
    getCv () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    CvOptional&
    getCv ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setCv (const CvType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setCv (const CvOptional& x);

    //@}

    /**
     * @name distr
     *
     * @brief Accessor and modifier functions for the %distr
     * required attribute.
     *
     * Selects the distribution to use.
     * 
     * const: constant (no distribution). Setting cv=0 has the same
     * behaviour.
     * 
     * lnorm: log-normal distribution
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::scnXml::Distr DistrType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DistrType, char > DistrTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const DistrType&
    getDistr () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    DistrType&
    getDistr ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDistr (const DistrType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDistr (::std::unique_ptr< DistrType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SampledValue (const MeanType&,
                  const DistrType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SampledValue (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SampledValue (const SampledValue& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SampledValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SampledValue&
    operator= (const SampledValue& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SampledValue ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MeanType > mean_;
    CvOptional cv_;
    ::xsd::cxx::tree::one< DistrType > distr_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DoubleValue schema type.
   *
   * @nosubgrouping
   */
  class DoubleValue: public ::xml_schema::Type
  {
    public:
    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     *
     * A double-precision floating-point value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double ValueType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char, ::xsd::cxx::tree::schema_type::double_ > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValue (const ValueType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DoubleValue (const ValueType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DoubleValue (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DoubleValue (const DoubleValue& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DoubleValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DoubleValue&
    operator= (const DoubleValue& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DoubleValue ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ValueType > value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %IntValue schema type.
   *
   * @nosubgrouping
   */
  class IntValue: public ::xml_schema::Type
  {
    public:
    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     *
     * An integer value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int ValueType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValue (const ValueType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    IntValue (const ValueType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    IntValue (const xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IntValue (const IntValue& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual IntValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    IntValue&
    operator= (const IntValue& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~IntValue ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ValueType > value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %BooleanValue schema type.
   *
   * @nosubgrouping
   */
  class BooleanValue: public ::xml_schema::Type
  {
    public:
    /**
     * @name value
     *
     * @brief Accessor and modifier functions for the %value
     * required attribute.
     *
     * A boolean value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean ValueType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ValueType, char > ValueTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ValueType&
    getValue () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ValueType&
    getValue ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setValue (const ValueType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    BooleanValue (const ValueType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    BooleanValue (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BooleanValue (const BooleanValue& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual BooleanValue*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    BooleanValue&
    operator= (const BooleanValue& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~BooleanValue ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ValueType > value_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %AgeGroupValues schema type.
   *
   * @nosubgrouping
   */
  class AgeGroupValues: public ::xml_schema::Type
  {
    public:
    /**
     * @name group
     *
     * @brief Accessor and modifier functions for the %group
     * sequence element.
     *
     * A series of values according to age groups, each specified with
     * a lower-bound and a value. The first lower-bound specified must be
     * zero; a final upper-bound of infinity is added to complete the last
     * age group. At least one age group is required. Normally these are
     * interpolated by a continuous function (see interpolation attribute).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Group GroupType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< GroupType > GroupSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< GroupType >::iterator GroupIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< GroupType >::const_iterator GroupConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< GroupType, char > GroupTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const GroupSequence&
    getGroup () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    GroupSequence&
    getGroup ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setGroup (const GroupSequence& s);

    //@}

    /**
     * @name interpolation
     *
     * @brief Accessor and modifier functions for the %interpolation
     * optional attribute.
     *
     * Interpolation algorithm. Normally it is desirable for age-based
     * values to be continuous w.r.t. age. By default linear interpolation
     * is used.
     * 
     * With all algorithms except "none", the age groups are converted to a
     * set of points centred within each age range. Extra
     * points are added at each end (zero and infinity) to keep value
     * constant at both ends of the function. A zero-length age group may
     * be used as a kind of barrier to adjust the distribution; e.g. with
     * age group boundaries at 15, 20 and 25 years, a (linear) spline would
     * be drawn between ages 17.5 and 22.5, whereas with boundaries at
     * 15, 20 and 20 years, a spline would be drawn between ages 17.5 and 20
     * years (may be desired if individuals are assumed to reach adult size
     * at 20).
     * 
     * Algorithms:
     * 1. none: input values are used directly
     * 2. linear: straight lines (on an age vs. value graph) are used to
     * interpolate data points.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::scnXml::Interpolation InterpolationType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< InterpolationType > InterpolationOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InterpolationType, char > InterpolationTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const InterpolationOptional&
    getInterpolation () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    InterpolationOptional&
    getInterpolation ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInterpolation (const InterpolationType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setInterpolation (const InterpolationOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setInterpolation (::std::unique_ptr< InterpolationType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    AgeGroupValues ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    AgeGroupValues (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AgeGroupValues (const AgeGroupValues& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual AgeGroupValues*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    AgeGroupValues&
    operator= (const AgeGroupValues& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~AgeGroupValues ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    GroupSequence group_;
    InterpolationOptional interpolation_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %deploy schema type.
   *
   * @nosubgrouping
   */
  class Deploy: public ::xml_schema::Type
  {
    public:
    /**
     * @name component
     *
     * @brief Accessor and modifier functions for the %component
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Component ComponentType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ComponentType > ComponentSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< ComponentType >::iterator ComponentIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< ComponentType >::const_iterator ComponentConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComponentType, char > ComponentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ComponentSequence&
    getComponent () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ComponentSequence&
    getComponent ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setComponent (const ComponentSequence& s);

    //@}

    /**
     * @name maxAge
     *
     * @brief Accessor and modifier functions for the %maxAge
     * optional attribute.
     *
     * Maximum age of eligible humans (defaults to no limit).
     * 
     * Input is rounded to the nearest time step.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MaxAgeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MaxAgeType > MaxAgeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxAgeType, char, ::xsd::cxx::tree::schema_type::double_ > MaxAgeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MaxAgeOptional&
    getMaxAge () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    MaxAgeOptional&
    getMaxAge ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMaxAge (const MaxAgeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setMaxAge (const MaxAgeOptional& x);

    //@}

    /**
     * @name minAge
     *
     * @brief Accessor and modifier functions for the %minAge
     * optional attribute with a default value.
     *
     * Minimum age of eligible humans (defaults to 0).
     * 
     * Input is rounded to the nearest time step.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double MinAgeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< MinAgeType, char, ::xsd::cxx::tree::schema_type::double_ > MinAgeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const MinAgeType&
    getMinAge () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    MinAgeType&
    getMinAge ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setMinAge (const MinAgeType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static MinAgeType
    getMinAgeDefaultValue ();

    //@}

    /**
     * @name p
     *
     * @brief Accessor and modifier functions for the %p
     * optional attribute with a default value.
     *
     * Probability of this list of components being deployed, given
     * that other constraints are met.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double PType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PType, char, ::xsd::cxx::tree::schema_type::double_ > PTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const PType&
    getP () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    PType&
    getP ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setP (const PType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static PType
    getPDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Deploy ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Deploy (const xercesc::DOMElement& e,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Deploy (const Deploy& x,
            ::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Deploy*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Deploy&
    operator= (const Deploy& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Deploy ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ComponentSequence component_;
    MaxAgeOptional maxAge_;
    ::xsd::cxx::tree::one< MinAgeType > minAge_;
    ::xsd::cxx::tree::one< PType > p_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %function
   * schema type.
   */
  class Function: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      constant,
      step,
      linear,
      exponential,
      weibull,
      hill,
      smooth_compact
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Function (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Function (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Function (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Function (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Function (const xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Function (const xercesc::DOMAttr& a,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Function (const ::std::string& s,
              const xercesc::DOMElement* e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Function (const Function& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Function*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Function&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Function_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Function_convert () const;

    public:
    static const char* const _xsd_Function_literals_[7];
    static const Value _xsd_Function_indexes_[7];

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %distr
   * schema type.
   */
  class Distr: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      lnorm,
      const_
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Distr (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Distr (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Distr (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Distr (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Distr (const xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Distr (const xercesc::DOMAttr& a,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Distr (const ::std::string& s,
           const xercesc::DOMElement* e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Distr (const Distr& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Distr*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Distr&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Distr_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Distr_convert () const;

    public:
    static const char* const _xsd_Distr_literals_[2];
    static const Value _xsd_Distr_indexes_[2];

    //@endcond
  };

  /**
   * @brief Class corresponding to the %group schema type.
   *
   * @nosubgrouping
   */
  class Group: public ::scnXml::DoubleValue
  {
    public:
    /**
     * @name lowerbound
     *
     * @brief Accessor and modifier functions for the %lowerbound
     * required attribute.
     *
     * Lower bound of age group
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double LowerboundType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerboundType, char, ::xsd::cxx::tree::schema_type::double_ > LowerboundTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const LowerboundType&
    getLowerbound () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    LowerboundType&
    getLowerbound ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLowerbound (const LowerboundType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Group (const ValueType&,
           const LowerboundType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Group (const xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Group (const Group& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Group*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Group&
    operator= (const Group& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Group ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LowerboundType > lowerbound_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %interpolation
   * schema type.
   */
  class Interpolation: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      none,
      linear
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Interpolation (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Interpolation (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Interpolation (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Interpolation (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Interpolation (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Interpolation (const xercesc::DOMAttr& a,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Interpolation (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Interpolation (const Interpolation& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Interpolation*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Interpolation&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Interpolation_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Interpolation_convert () const;

    public:
    static const char* const _xsd_Interpolation_literals_[2];
    static const Value _xsd_Interpolation_indexes_[2];

    //@endcond
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace scnXml
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_CODE_OPENMALARIA_SCHEMA_UTIL_H

// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "entomology.h"

namespace scnXml
{
  // Entomology
  // 

  const Entomology::NonVectorOptional& Entomology::
  getNonVector () const
  {
    return this->nonVector_;
  }

  Entomology::NonVectorOptional& Entomology::
  getNonVector ()
  {
    return this->nonVector_;
  }

  void Entomology::
  setNonVector (const NonVectorType& x)
  {
    this->nonVector_.set (x);
  }

  void Entomology::
  setNonVector (const NonVectorOptional& x)
  {
    this->nonVector_ = x;
  }

  void Entomology::
  setNonVector (::std::unique_ptr< NonVectorType > x)
  {
    this->nonVector_.set (std::move (x));
  }

  const Entomology::VectorOptional& Entomology::
  getVector () const
  {
    return this->vector_;
  }

  Entomology::VectorOptional& Entomology::
  getVector ()
  {
    return this->vector_;
  }

  void Entomology::
  setVector (const VectorType& x)
  {
    this->vector_.set (x);
  }

  void Entomology::
  setVector (const VectorOptional& x)
  {
    this->vector_ = x;
  }

  void Entomology::
  setVector (::std::unique_ptr< VectorType > x)
  {
    this->vector_.set (std::move (x));
  }

  const Entomology::NameType& Entomology::
  getName () const
  {
    return this->name_.get ();
  }

  Entomology::NameType& Entomology::
  getName ()
  {
    return this->name_.get ();
  }

  void Entomology::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Entomology::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const Entomology::ModeType& Entomology::
  getMode () const
  {
    return this->mode_.get ();
  }

  Entomology::ModeType& Entomology::
  getMode ()
  {
    return this->mode_.get ();
  }

  void Entomology::
  setMode (const ModeType& x)
  {
    this->mode_.set (x);
  }

  void Entomology::
  setMode (::std::unique_ptr< ModeType > x)
  {
    this->mode_.set (std::move (x));
  }

  const Entomology::ScaledAnnualEIROptional& Entomology::
  getScaledAnnualEIR () const
  {
    return this->scaledAnnualEIR_;
  }

  Entomology::ScaledAnnualEIROptional& Entomology::
  getScaledAnnualEIR ()
  {
    return this->scaledAnnualEIR_;
  }

  void Entomology::
  setScaledAnnualEIR (const ScaledAnnualEIRType& x)
  {
    this->scaledAnnualEIR_.set (x);
  }

  void Entomology::
  setScaledAnnualEIR (const ScaledAnnualEIROptional& x)
  {
    this->scaledAnnualEIR_ = x;
  }


  // NonVector
  // 

  const NonVector::EIRDailySequence& NonVector::
  getEIRDaily () const
  {
    return this->EIRDaily_;
  }

  NonVector::EIRDailySequence& NonVector::
  getEIRDaily ()
  {
    return this->EIRDaily_;
  }

  void NonVector::
  setEIRDaily (const EIRDailySequence& s)
  {
    this->EIRDaily_ = s;
  }

  const NonVector::EipDurationType& NonVector::
  getEipDuration () const
  {
    return this->eipDuration_.get ();
  }

  NonVector::EipDurationType& NonVector::
  getEipDuration ()
  {
    return this->eipDuration_.get ();
  }

  void NonVector::
  setEipDuration (const EipDurationType& x)
  {
    this->eipDuration_.set (x);
  }


  // EIRDaily
  // 

  const EIRDaily::OriginOptional& EIRDaily::
  getOrigin () const
  {
    return this->origin_;
  }

  EIRDaily::OriginOptional& EIRDaily::
  getOrigin ()
  {
    return this->origin_;
  }

  void EIRDaily::
  setOrigin (const OriginType& x)
  {
    this->origin_.set (x);
  }

  void EIRDaily::
  setOrigin (const OriginOptional& x)
  {
    this->origin_ = x;
  }

  void EIRDaily::
  setOrigin (::std::unique_ptr< OriginType > x)
  {
    this->origin_.set (std::move (x));
  }


  // AnophelesParams
  // 

  const AnophelesParams::SeasonalityType& AnophelesParams::
  getSeasonality () const
  {
    return this->seasonality_.get ();
  }

  AnophelesParams::SeasonalityType& AnophelesParams::
  getSeasonality ()
  {
    return this->seasonality_.get ();
  }

  void AnophelesParams::
  setSeasonality (const SeasonalityType& x)
  {
    this->seasonality_.set (x);
  }

  void AnophelesParams::
  setSeasonality (::std::unique_ptr< SeasonalityType > x)
  {
    this->seasonality_.set (std::move (x));
  }

  const AnophelesParams::MosqType& AnophelesParams::
  getMosq () const
  {
    return this->mosq_.get ();
  }

  AnophelesParams::MosqType& AnophelesParams::
  getMosq ()
  {
    return this->mosq_.get ();
  }

  void AnophelesParams::
  setMosq (const MosqType& x)
  {
    this->mosq_.set (x);
  }

  void AnophelesParams::
  setMosq (::std::unique_ptr< MosqType > x)
  {
    this->mosq_.set (std::move (x));
  }

  const AnophelesParams::LifeCycleOptional& AnophelesParams::
  getLifeCycle () const
  {
    return this->lifeCycle_;
  }

  AnophelesParams::LifeCycleOptional& AnophelesParams::
  getLifeCycle ()
  {
    return this->lifeCycle_;
  }

  void AnophelesParams::
  setLifeCycle (const LifeCycleType& x)
  {
    this->lifeCycle_.set (x);
  }

  void AnophelesParams::
  setLifeCycle (const LifeCycleOptional& x)
  {
    this->lifeCycle_ = x;
  }

  void AnophelesParams::
  setLifeCycle (::std::unique_ptr< LifeCycleType > x)
  {
    this->lifeCycle_.set (std::move (x));
  }

  const AnophelesParams::SimpleMPDOptional& AnophelesParams::
  getSimpleMPD () const
  {
    return this->simpleMPD_;
  }

  AnophelesParams::SimpleMPDOptional& AnophelesParams::
  getSimpleMPD ()
  {
    return this->simpleMPD_;
  }

  void AnophelesParams::
  setSimpleMPD (const SimpleMPDType& x)
  {
    this->simpleMPD_.set (x);
  }

  void AnophelesParams::
  setSimpleMPD (const SimpleMPDOptional& x)
  {
    this->simpleMPD_ = x;
  }

  void AnophelesParams::
  setSimpleMPD (::std::unique_ptr< SimpleMPDType > x)
  {
    this->simpleMPD_.set (std::move (x));
  }

  const AnophelesParams::NonHumanHostsSequence& AnophelesParams::
  getNonHumanHosts () const
  {
    return this->nonHumanHosts_;
  }

  AnophelesParams::NonHumanHostsSequence& AnophelesParams::
  getNonHumanHosts ()
  {
    return this->nonHumanHosts_;
  }

  void AnophelesParams::
  setNonHumanHosts (const NonHumanHostsSequence& s)
  {
    this->nonHumanHosts_ = s;
  }

  const AnophelesParams::MosquitoType& AnophelesParams::
  getMosquito () const
  {
    return this->mosquito_.get ();
  }

  AnophelesParams::MosquitoType& AnophelesParams::
  getMosquito ()
  {
    return this->mosquito_.get ();
  }

  void AnophelesParams::
  setMosquito (const MosquitoType& x)
  {
    this->mosquito_.set (x);
  }

  void AnophelesParams::
  setMosquito (::std::unique_ptr< MosquitoType > x)
  {
    this->mosquito_.set (std::move (x));
  }

  const AnophelesParams::PropInfectedType& AnophelesParams::
  getPropInfected () const
  {
    return this->propInfected_.get ();
  }

  AnophelesParams::PropInfectedType& AnophelesParams::
  getPropInfected ()
  {
    return this->propInfected_.get ();
  }

  void AnophelesParams::
  setPropInfected (const PropInfectedType& x)
  {
    this->propInfected_.set (x);
  }

  const AnophelesParams::PropInfectiousType& AnophelesParams::
  getPropInfectious () const
  {
    return this->propInfectious_.get ();
  }

  AnophelesParams::PropInfectiousType& AnophelesParams::
  getPropInfectious ()
  {
    return this->propInfectious_.get ();
  }

  void AnophelesParams::
  setPropInfectious (const PropInfectiousType& x)
  {
    this->propInfectious_.set (x);
  }


  // MosqStage
  // 

  const MosqStage::DurationType& MosqStage::
  getDuration () const
  {
    return this->duration_.get ();
  }

  MosqStage::DurationType& MosqStage::
  getDuration ()
  {
    return this->duration_.get ();
  }

  void MosqStage::
  setDuration (const DurationType& x)
  {
    this->duration_.set (x);
  }

  const MosqStage::SurvivalType& MosqStage::
  getSurvival () const
  {
    return this->survival_.get ();
  }

  MosqStage::SurvivalType& MosqStage::
  getSurvival ()
  {
    return this->survival_.get ();
  }

  void MosqStage::
  setSurvival (const SurvivalType& x)
  {
    this->survival_.set (x);
  }


  // Vector
  // 

  const Vector::AnophelesSequence& Vector::
  getAnopheles () const
  {
    return this->anopheles_;
  }

  Vector::AnophelesSequence& Vector::
  getAnopheles ()
  {
    return this->anopheles_;
  }

  void Vector::
  setAnopheles (const AnophelesSequence& s)
  {
    this->anopheles_ = s;
  }

  const Vector::NonHumanHostsSequence& Vector::
  getNonHumanHosts () const
  {
    return this->nonHumanHosts_;
  }

  Vector::NonHumanHostsSequence& Vector::
  getNonHumanHosts ()
  {
    return this->nonHumanHosts_;
  }

  void Vector::
  setNonHumanHosts (const NonHumanHostsSequence& s)
  {
    this->nonHumanHosts_ = s;
  }


  // Mode
  // 

  Mode::
  Mode (Value v)
  : ::xml_schema::String (_xsd_Mode_literals_[v])
  {
  }

  Mode::
  Mode (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Mode::
  Mode (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Mode::
  Mode (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Mode::
  Mode (const Mode& v,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Mode& Mode::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Mode_literals_[v]);

    return *this;
  }


  // Seasonality
  // 

  const Seasonality::FourierSeriesOptional& Seasonality::
  getFourierSeries () const
  {
    return this->fourierSeries_;
  }

  Seasonality::FourierSeriesOptional& Seasonality::
  getFourierSeries ()
  {
    return this->fourierSeries_;
  }

  void Seasonality::
  setFourierSeries (const FourierSeriesType& x)
  {
    this->fourierSeries_.set (x);
  }

  void Seasonality::
  setFourierSeries (const FourierSeriesOptional& x)
  {
    this->fourierSeries_ = x;
  }

  void Seasonality::
  setFourierSeries (::std::unique_ptr< FourierSeriesType > x)
  {
    this->fourierSeries_.set (std::move (x));
  }

  const Seasonality::MonthlyValuesOptional& Seasonality::
  getMonthlyValues () const
  {
    return this->monthlyValues_;
  }

  Seasonality::MonthlyValuesOptional& Seasonality::
  getMonthlyValues ()
  {
    return this->monthlyValues_;
  }

  void Seasonality::
  setMonthlyValues (const MonthlyValuesType& x)
  {
    this->monthlyValues_.set (x);
  }

  void Seasonality::
  setMonthlyValues (const MonthlyValuesOptional& x)
  {
    this->monthlyValues_ = x;
  }

  void Seasonality::
  setMonthlyValues (::std::unique_ptr< MonthlyValuesType > x)
  {
    this->monthlyValues_.set (std::move (x));
  }

  const Seasonality::DailyValuesOptional& Seasonality::
  getDailyValues () const
  {
    return this->dailyValues_;
  }

  Seasonality::DailyValuesOptional& Seasonality::
  getDailyValues ()
  {
    return this->dailyValues_;
  }

  void Seasonality::
  setDailyValues (const DailyValuesType& x)
  {
    this->dailyValues_.set (x);
  }

  void Seasonality::
  setDailyValues (const DailyValuesOptional& x)
  {
    this->dailyValues_ = x;
  }

  void Seasonality::
  setDailyValues (::std::unique_ptr< DailyValuesType > x)
  {
    this->dailyValues_.set (std::move (x));
  }

  const Seasonality::InputType& Seasonality::
  getInput () const
  {
    return this->input_.get ();
  }

  Seasonality::InputType& Seasonality::
  getInput ()
  {
    return this->input_.get ();
  }

  void Seasonality::
  setInput (const InputType& x)
  {
    this->input_.set (x);
  }

  void Seasonality::
  setInput (::std::unique_ptr< InputType > x)
  {
    this->input_.set (std::move (x));
  }

  const Seasonality::AnnualEIROptional& Seasonality::
  getAnnualEIR () const
  {
    return this->annualEIR_;
  }

  Seasonality::AnnualEIROptional& Seasonality::
  getAnnualEIR ()
  {
    return this->annualEIR_;
  }

  void Seasonality::
  setAnnualEIR (const AnnualEIRType& x)
  {
    this->annualEIR_.set (x);
  }

  void Seasonality::
  setAnnualEIR (const AnnualEIROptional& x)
  {
    this->annualEIR_ = x;
  }


  // Mosq
  // 

  const Mosq::MosqRestDurationType& Mosq::
  getMosqRestDuration () const
  {
    return this->mosqRestDuration_.get ();
  }

  Mosq::MosqRestDurationType& Mosq::
  getMosqRestDuration ()
  {
    return this->mosqRestDuration_.get ();
  }

  void Mosq::
  setMosqRestDuration (const MosqRestDurationType& x)
  {
    this->mosqRestDuration_.set (x);
  }

  void Mosq::
  setMosqRestDuration (::std::unique_ptr< MosqRestDurationType > x)
  {
    this->mosqRestDuration_.set (std::move (x));
  }

  const Mosq::ExtrinsicIncubationPeriodType& Mosq::
  getExtrinsicIncubationPeriod () const
  {
    return this->extrinsicIncubationPeriod_.get ();
  }

  Mosq::ExtrinsicIncubationPeriodType& Mosq::
  getExtrinsicIncubationPeriod ()
  {
    return this->extrinsicIncubationPeriod_.get ();
  }

  void Mosq::
  setExtrinsicIncubationPeriod (const ExtrinsicIncubationPeriodType& x)
  {
    this->extrinsicIncubationPeriod_.set (x);
  }

  void Mosq::
  setExtrinsicIncubationPeriod (::std::unique_ptr< ExtrinsicIncubationPeriodType > x)
  {
    this->extrinsicIncubationPeriod_.set (std::move (x));
  }

  const Mosq::MosqLaidEggsSameDayProportionType& Mosq::
  getMosqLaidEggsSameDayProportion () const
  {
    return this->mosqLaidEggsSameDayProportion_.get ();
  }

  Mosq::MosqLaidEggsSameDayProportionType& Mosq::
  getMosqLaidEggsSameDayProportion ()
  {
    return this->mosqLaidEggsSameDayProportion_.get ();
  }

  void Mosq::
  setMosqLaidEggsSameDayProportion (const MosqLaidEggsSameDayProportionType& x)
  {
    this->mosqLaidEggsSameDayProportion_.set (x);
  }

  void Mosq::
  setMosqLaidEggsSameDayProportion (::std::unique_ptr< MosqLaidEggsSameDayProportionType > x)
  {
    this->mosqLaidEggsSameDayProportion_.set (std::move (x));
  }

  const Mosq::MosqSeekingDurationType& Mosq::
  getMosqSeekingDuration () const
  {
    return this->mosqSeekingDuration_.get ();
  }

  Mosq::MosqSeekingDurationType& Mosq::
  getMosqSeekingDuration ()
  {
    return this->mosqSeekingDuration_.get ();
  }

  void Mosq::
  setMosqSeekingDuration (const MosqSeekingDurationType& x)
  {
    this->mosqSeekingDuration_.set (x);
  }

  void Mosq::
  setMosqSeekingDuration (::std::unique_ptr< MosqSeekingDurationType > x)
  {
    this->mosqSeekingDuration_.set (std::move (x));
  }

  const Mosq::MosqSurvivalFeedingCycleProbabilityType& Mosq::
  getMosqSurvivalFeedingCycleProbability () const
  {
    return this->mosqSurvivalFeedingCycleProbability_.get ();
  }

  Mosq::MosqSurvivalFeedingCycleProbabilityType& Mosq::
  getMosqSurvivalFeedingCycleProbability ()
  {
    return this->mosqSurvivalFeedingCycleProbability_.get ();
  }

  void Mosq::
  setMosqSurvivalFeedingCycleProbability (const MosqSurvivalFeedingCycleProbabilityType& x)
  {
    this->mosqSurvivalFeedingCycleProbability_.set (x);
  }

  void Mosq::
  setMosqSurvivalFeedingCycleProbability (::std::unique_ptr< MosqSurvivalFeedingCycleProbabilityType > x)
  {
    this->mosqSurvivalFeedingCycleProbability_.set (std::move (x));
  }

  const Mosq::AvailabilityVarianceType& Mosq::
  getAvailabilityVariance () const
  {
    return this->availabilityVariance_.get ();
  }

  Mosq::AvailabilityVarianceType& Mosq::
  getAvailabilityVariance ()
  {
    return this->availabilityVariance_.get ();
  }

  void Mosq::
  setAvailabilityVariance (const AvailabilityVarianceType& x)
  {
    this->availabilityVariance_.set (x);
  }

  void Mosq::
  setAvailabilityVariance (::std::unique_ptr< AvailabilityVarianceType > x)
  {
    this->availabilityVariance_.set (std::move (x));
  }

  const Mosq::MosqProbBitingType& Mosq::
  getMosqProbBiting () const
  {
    return this->mosqProbBiting_.get ();
  }

  Mosq::MosqProbBitingType& Mosq::
  getMosqProbBiting ()
  {
    return this->mosqProbBiting_.get ();
  }

  void Mosq::
  setMosqProbBiting (const MosqProbBitingType& x)
  {
    this->mosqProbBiting_.set (x);
  }

  void Mosq::
  setMosqProbBiting (::std::unique_ptr< MosqProbBitingType > x)
  {
    this->mosqProbBiting_.set (std::move (x));
  }

  const Mosq::MosqProbFindRestSiteType& Mosq::
  getMosqProbFindRestSite () const
  {
    return this->mosqProbFindRestSite_.get ();
  }

  Mosq::MosqProbFindRestSiteType& Mosq::
  getMosqProbFindRestSite ()
  {
    return this->mosqProbFindRestSite_.get ();
  }

  void Mosq::
  setMosqProbFindRestSite (const MosqProbFindRestSiteType& x)
  {
    this->mosqProbFindRestSite_.set (x);
  }

  void Mosq::
  setMosqProbFindRestSite (::std::unique_ptr< MosqProbFindRestSiteType > x)
  {
    this->mosqProbFindRestSite_.set (std::move (x));
  }

  const Mosq::MosqProbRestingType& Mosq::
  getMosqProbResting () const
  {
    return this->mosqProbResting_.get ();
  }

  Mosq::MosqProbRestingType& Mosq::
  getMosqProbResting ()
  {
    return this->mosqProbResting_.get ();
  }

  void Mosq::
  setMosqProbResting (const MosqProbRestingType& x)
  {
    this->mosqProbResting_.set (x);
  }

  void Mosq::
  setMosqProbResting (::std::unique_ptr< MosqProbRestingType > x)
  {
    this->mosqProbResting_.set (std::move (x));
  }

  const Mosq::MosqProbOvipositingType& Mosq::
  getMosqProbOvipositing () const
  {
    return this->mosqProbOvipositing_.get ();
  }

  Mosq::MosqProbOvipositingType& Mosq::
  getMosqProbOvipositing ()
  {
    return this->mosqProbOvipositing_.get ();
  }

  void Mosq::
  setMosqProbOvipositing (const MosqProbOvipositingType& x)
  {
    this->mosqProbOvipositing_.set (x);
  }

  void Mosq::
  setMosqProbOvipositing (::std::unique_ptr< MosqProbOvipositingType > x)
  {
    this->mosqProbOvipositing_.set (std::move (x));
  }

  const Mosq::MosqHumanBloodIndexType& Mosq::
  getMosqHumanBloodIndex () const
  {
    return this->mosqHumanBloodIndex_.get ();
  }

  Mosq::MosqHumanBloodIndexType& Mosq::
  getMosqHumanBloodIndex ()
  {
    return this->mosqHumanBloodIndex_.get ();
  }

  void Mosq::
  setMosqHumanBloodIndex (const MosqHumanBloodIndexType& x)
  {
    this->mosqHumanBloodIndex_.set (x);
  }

  void Mosq::
  setMosqHumanBloodIndex (::std::unique_ptr< MosqHumanBloodIndexType > x)
  {
    this->mosqHumanBloodIndex_.set (std::move (x));
  }

  const Mosq::MinInfectedThresholdType& Mosq::
  getMinInfectedThreshold () const
  {
    return this->minInfectedThreshold_.get ();
  }

  Mosq::MinInfectedThresholdType& Mosq::
  getMinInfectedThreshold ()
  {
    return this->minInfectedThreshold_.get ();
  }

  void Mosq::
  setMinInfectedThreshold (const MinInfectedThresholdType& x)
  {
    this->minInfectedThreshold_.set (x);
  }


  // LifeCycle
  // 

  const LifeCycle::EggStageType& LifeCycle::
  getEggStage () const
  {
    return this->eggStage_.get ();
  }

  LifeCycle::EggStageType& LifeCycle::
  getEggStage ()
  {
    return this->eggStage_.get ();
  }

  void LifeCycle::
  setEggStage (const EggStageType& x)
  {
    this->eggStage_.set (x);
  }

  void LifeCycle::
  setEggStage (::std::unique_ptr< EggStageType > x)
  {
    this->eggStage_.set (std::move (x));
  }

  const LifeCycle::LarvalStageType& LifeCycle::
  getLarvalStage () const
  {
    return this->larvalStage_.get ();
  }

  LifeCycle::LarvalStageType& LifeCycle::
  getLarvalStage ()
  {
    return this->larvalStage_.get ();
  }

  void LifeCycle::
  setLarvalStage (const LarvalStageType& x)
  {
    this->larvalStage_.set (x);
  }

  void LifeCycle::
  setLarvalStage (::std::unique_ptr< LarvalStageType > x)
  {
    this->larvalStage_.set (std::move (x));
  }

  const LifeCycle::PupalStageType& LifeCycle::
  getPupalStage () const
  {
    return this->pupalStage_.get ();
  }

  LifeCycle::PupalStageType& LifeCycle::
  getPupalStage ()
  {
    return this->pupalStage_.get ();
  }

  void LifeCycle::
  setPupalStage (const PupalStageType& x)
  {
    this->pupalStage_.set (x);
  }

  void LifeCycle::
  setPupalStage (::std::unique_ptr< PupalStageType > x)
  {
    this->pupalStage_.set (std::move (x));
  }

  const LifeCycle::FemaleEggsLaidByOvipositType& LifeCycle::
  getFemaleEggsLaidByOviposit () const
  {
    return this->femaleEggsLaidByOviposit_.get ();
  }

  LifeCycle::FemaleEggsLaidByOvipositType& LifeCycle::
  getFemaleEggsLaidByOviposit ()
  {
    return this->femaleEggsLaidByOviposit_.get ();
  }

  void LifeCycle::
  setFemaleEggsLaidByOviposit (const FemaleEggsLaidByOvipositType& x)
  {
    this->femaleEggsLaidByOviposit_.set (x);
  }

  void LifeCycle::
  setFemaleEggsLaidByOviposit (::std::unique_ptr< FemaleEggsLaidByOvipositType > x)
  {
    this->femaleEggsLaidByOviposit_.set (std::move (x));
  }

  const LifeCycle::EstimatedLarvalResourcesType& LifeCycle::
  getEstimatedLarvalResources () const
  {
    return this->estimatedLarvalResources_.get ();
  }

  LifeCycle::EstimatedLarvalResourcesType& LifeCycle::
  getEstimatedLarvalResources ()
  {
    return this->estimatedLarvalResources_.get ();
  }

  void LifeCycle::
  setEstimatedLarvalResources (const EstimatedLarvalResourcesType& x)
  {
    this->estimatedLarvalResources_.set (x);
  }

  LifeCycle::EstimatedLarvalResourcesType LifeCycle::
  getEstimatedLarvalResourcesDefaultValue ()
  {
    return EstimatedLarvalResourcesType (1e8);
  }


  // SimpleMPD
  // 

  const SimpleMPD::DevelopmentDurationType& SimpleMPD::
  getDevelopmentDuration () const
  {
    return this->developmentDuration_.get ();
  }

  SimpleMPD::DevelopmentDurationType& SimpleMPD::
  getDevelopmentDuration ()
  {
    return this->developmentDuration_.get ();
  }

  void SimpleMPD::
  setDevelopmentDuration (const DevelopmentDurationType& x)
  {
    this->developmentDuration_.set (x);
  }

  void SimpleMPD::
  setDevelopmentDuration (::std::unique_ptr< DevelopmentDurationType > x)
  {
    this->developmentDuration_.set (std::move (x));
  }

  const SimpleMPD::DevelopmentSurvivalType& SimpleMPD::
  getDevelopmentSurvival () const
  {
    return this->developmentSurvival_.get ();
  }

  SimpleMPD::DevelopmentSurvivalType& SimpleMPD::
  getDevelopmentSurvival ()
  {
    return this->developmentSurvival_.get ();
  }

  void SimpleMPD::
  setDevelopmentSurvival (const DevelopmentSurvivalType& x)
  {
    this->developmentSurvival_.set (x);
  }

  void SimpleMPD::
  setDevelopmentSurvival (::std::unique_ptr< DevelopmentSurvivalType > x)
  {
    this->developmentSurvival_.set (std::move (x));
  }

  const SimpleMPD::FemaleEggsLaidByOvipositType& SimpleMPD::
  getFemaleEggsLaidByOviposit () const
  {
    return this->femaleEggsLaidByOviposit_.get ();
  }

  SimpleMPD::FemaleEggsLaidByOvipositType& SimpleMPD::
  getFemaleEggsLaidByOviposit ()
  {
    return this->femaleEggsLaidByOviposit_.get ();
  }

  void SimpleMPD::
  setFemaleEggsLaidByOviposit (const FemaleEggsLaidByOvipositType& x)
  {
    this->femaleEggsLaidByOviposit_.set (x);
  }

  void SimpleMPD::
  setFemaleEggsLaidByOviposit (::std::unique_ptr< FemaleEggsLaidByOvipositType > x)
  {
    this->femaleEggsLaidByOviposit_.set (std::move (x));
  }


  // NonHumanHosts
  // 

  const NonHumanHosts::MosqRelativeEntoAvailabilityType& NonHumanHosts::
  getMosqRelativeEntoAvailability () const
  {
    return this->mosqRelativeEntoAvailability_.get ();
  }

  NonHumanHosts::MosqRelativeEntoAvailabilityType& NonHumanHosts::
  getMosqRelativeEntoAvailability ()
  {
    return this->mosqRelativeEntoAvailability_.get ();
  }

  void NonHumanHosts::
  setMosqRelativeEntoAvailability (const MosqRelativeEntoAvailabilityType& x)
  {
    this->mosqRelativeEntoAvailability_.set (x);
  }

  void NonHumanHosts::
  setMosqRelativeEntoAvailability (::std::unique_ptr< MosqRelativeEntoAvailabilityType > x)
  {
    this->mosqRelativeEntoAvailability_.set (std::move (x));
  }

  const NonHumanHosts::MosqProbBitingType& NonHumanHosts::
  getMosqProbBiting () const
  {
    return this->mosqProbBiting_.get ();
  }

  NonHumanHosts::MosqProbBitingType& NonHumanHosts::
  getMosqProbBiting ()
  {
    return this->mosqProbBiting_.get ();
  }

  void NonHumanHosts::
  setMosqProbBiting (const MosqProbBitingType& x)
  {
    this->mosqProbBiting_.set (x);
  }

  void NonHumanHosts::
  setMosqProbBiting (::std::unique_ptr< MosqProbBitingType > x)
  {
    this->mosqProbBiting_.set (std::move (x));
  }

  const NonHumanHosts::MosqProbFindRestSiteType& NonHumanHosts::
  getMosqProbFindRestSite () const
  {
    return this->mosqProbFindRestSite_.get ();
  }

  NonHumanHosts::MosqProbFindRestSiteType& NonHumanHosts::
  getMosqProbFindRestSite ()
  {
    return this->mosqProbFindRestSite_.get ();
  }

  void NonHumanHosts::
  setMosqProbFindRestSite (const MosqProbFindRestSiteType& x)
  {
    this->mosqProbFindRestSite_.set (x);
  }

  void NonHumanHosts::
  setMosqProbFindRestSite (::std::unique_ptr< MosqProbFindRestSiteType > x)
  {
    this->mosqProbFindRestSite_.set (std::move (x));
  }

  const NonHumanHosts::MosqProbRestingType& NonHumanHosts::
  getMosqProbResting () const
  {
    return this->mosqProbResting_.get ();
  }

  NonHumanHosts::MosqProbRestingType& NonHumanHosts::
  getMosqProbResting ()
  {
    return this->mosqProbResting_.get ();
  }

  void NonHumanHosts::
  setMosqProbResting (const MosqProbRestingType& x)
  {
    this->mosqProbResting_.set (x);
  }

  void NonHumanHosts::
  setMosqProbResting (::std::unique_ptr< MosqProbRestingType > x)
  {
    this->mosqProbResting_.set (std::move (x));
  }

  const NonHumanHosts::HostFecundityFactorOptional& NonHumanHosts::
  getHostFecundityFactor () const
  {
    return this->hostFecundityFactor_;
  }

  NonHumanHosts::HostFecundityFactorOptional& NonHumanHosts::
  getHostFecundityFactor ()
  {
    return this->hostFecundityFactor_;
  }

  void NonHumanHosts::
  setHostFecundityFactor (const HostFecundityFactorType& x)
  {
    this->hostFecundityFactor_.set (x);
  }

  void NonHumanHosts::
  setHostFecundityFactor (const HostFecundityFactorOptional& x)
  {
    this->hostFecundityFactor_ = x;
  }

  void NonHumanHosts::
  setHostFecundityFactor (::std::unique_ptr< HostFecundityFactorType > x)
  {
    this->hostFecundityFactor_.set (std::move (x));
  }

  const NonHumanHosts::NameType& NonHumanHosts::
  getName () const
  {
    return this->name_.get ();
  }

  NonHumanHosts::NameType& NonHumanHosts::
  getName ()
  {
    return this->name_.get ();
  }

  void NonHumanHosts::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void NonHumanHosts::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // NonHumanHosts1
  // 

  const NonHumanHosts1::NameType& NonHumanHosts1::
  getName () const
  {
    return this->name_.get ();
  }

  NonHumanHosts1::NameType& NonHumanHosts1::
  getName ()
  {
    return this->name_.get ();
  }

  void NonHumanHosts1::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void NonHumanHosts1::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const NonHumanHosts1::NumberType& NonHumanHosts1::
  getNumber () const
  {
    return this->number_.get ();
  }

  NonHumanHosts1::NumberType& NonHumanHosts1::
  getNumber ()
  {
    return this->number_.get ();
  }

  void NonHumanHosts1::
  setNumber (const NumberType& x)
  {
    this->number_.set (x);
  }


  // FourierSeries
  // 

  const FourierSeries::CoefficSequence& FourierSeries::
  getCoeffic () const
  {
    return this->coeffic_;
  }

  FourierSeries::CoefficSequence& FourierSeries::
  getCoeffic ()
  {
    return this->coeffic_;
  }

  void FourierSeries::
  setCoeffic (const CoefficSequence& s)
  {
    this->coeffic_ = s;
  }

  const FourierSeries::EIRRotateAngleType& FourierSeries::
  getEIRRotateAngle () const
  {
    return this->EIRRotateAngle_.get ();
  }

  FourierSeries::EIRRotateAngleType& FourierSeries::
  getEIRRotateAngle ()
  {
    return this->EIRRotateAngle_.get ();
  }

  void FourierSeries::
  setEIRRotateAngle (const EIRRotateAngleType& x)
  {
    this->EIRRotateAngle_.set (x);
  }


  // MonthlyValues
  // 

  const MonthlyValues::ValueSequence& MonthlyValues::
  getValue () const
  {
    return this->value_;
  }

  MonthlyValues::ValueSequence& MonthlyValues::
  getValue ()
  {
    return this->value_;
  }

  void MonthlyValues::
  setValue (const ValueSequence& s)
  {
    this->value_ = s;
  }

  const MonthlyValues::SmoothingType& MonthlyValues::
  getSmoothing () const
  {
    return this->smoothing_.get ();
  }

  MonthlyValues::SmoothingType& MonthlyValues::
  getSmoothing ()
  {
    return this->smoothing_.get ();
  }

  void MonthlyValues::
  setSmoothing (const SmoothingType& x)
  {
    this->smoothing_.set (x);
  }

  void MonthlyValues::
  setSmoothing (::std::unique_ptr< SmoothingType > x)
  {
    this->smoothing_.set (std::move (x));
  }


  // DailyValues
  // 

  const DailyValues::ValueSequence& DailyValues::
  getValue () const
  {
    return this->value_;
  }

  DailyValues::ValueSequence& DailyValues::
  getValue ()
  {
    return this->value_;
  }

  void DailyValues::
  setValue (const ValueSequence& s)
  {
    this->value_ = s;
  }


  // Input
  // 

  Input::
  Input (Value v)
  : ::xml_schema::String (_xsd_Input_literals_[v])
  {
  }

  Input::
  Input (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Input::
  Input (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Input::
  Input (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Input::
  Input (const Input& v,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Input& Input::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Input_literals_[v]);

    return *this;
  }


  // LarvalStage
  // 

  const LarvalStage::DailySequence& LarvalStage::
  getDaily () const
  {
    return this->daily_;
  }

  LarvalStage::DailySequence& LarvalStage::
  getDaily ()
  {
    return this->daily_;
  }

  void LarvalStage::
  setDaily (const DailySequence& s)
  {
    this->daily_ = s;
  }


  // Coeffic
  // 

  const Coeffic::AType& Coeffic::
  getA () const
  {
    return this->a_.get ();
  }

  Coeffic::AType& Coeffic::
  getA ()
  {
    return this->a_.get ();
  }

  void Coeffic::
  setA (const AType& x)
  {
    this->a_.set (x);
  }

  const Coeffic::BType& Coeffic::
  getB () const
  {
    return this->b_.get ();
  }

  Coeffic::BType& Coeffic::
  getB ()
  {
    return this->b_.get ();
  }

  void Coeffic::
  setB (const BType& x)
  {
    this->b_.set (x);
  }


  // Smoothing
  // 

  Smoothing::
  Smoothing (Value v)
  : ::xml_schema::String (_xsd_Smoothing_literals_[v])
  {
  }

  Smoothing::
  Smoothing (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Smoothing::
  Smoothing (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Smoothing::
  Smoothing (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Smoothing::
  Smoothing (const Smoothing& v,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Smoothing& Smoothing::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Smoothing_literals_[v]);

    return *this;
  }


  // Daily
  // 

  const Daily::ResourceUsageType& Daily::
  getResourceUsage () const
  {
    return this->resourceUsage_.get ();
  }

  Daily::ResourceUsageType& Daily::
  getResourceUsage ()
  {
    return this->resourceUsage_.get ();
  }

  void Daily::
  setResourceUsage (const ResourceUsageType& x)
  {
    this->resourceUsage_.set (x);
  }

  const Daily::EffectCompetitionType& Daily::
  getEffectCompetition () const
  {
    return this->effectCompetition_.get ();
  }

  Daily::EffectCompetitionType& Daily::
  getEffectCompetition ()
  {
    return this->effectCompetition_.get ();
  }

  void Daily::
  setEffectCompetition (const EffectCompetitionType& x)
  {
    this->effectCompetition_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace scnXml
{
  // Entomology
  //

  Entomology::
  Entomology (const NameType& name,
              const ModeType& mode)
  : ::xml_schema::Type (),
    nonVector_ (this),
    vector_ (this),
    name_ (name, this),
    mode_ (mode, this),
    scaledAnnualEIR_ (this)
  {
  }

  Entomology::
  Entomology (const Entomology& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    nonVector_ (x.nonVector_, f, this),
    vector_ (x.vector_, f, this),
    name_ (x.name_, f, this),
    mode_ (x.mode_, f, this),
    scaledAnnualEIR_ (x.scaledAnnualEIR_, f, this)
  {
  }

  Entomology::
  Entomology (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    nonVector_ (this),
    vector_ (this),
    name_ (this),
    mode_ (this),
    scaledAnnualEIR_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Entomology::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // nonVector
      //
      if (n.name () == "nonVector" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< NonVectorType > r (
          NonVectorTraits::create (i, f, this));

        if (!this->nonVector_)
        {
          this->nonVector_.set (::std::move (r));
          continue;
        }
      }

      // vector
      //
      if (n.name () == "vector" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< VectorType > r (
          VectorTraits::create (i, f, this));

        if (!this->vector_)
        {
          this->vector_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "mode" && n.namespace_ ().empty ())
      {
        this->mode_.set (ModeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "scaledAnnualEIR" && n.namespace_ ().empty ())
      {
        this->scaledAnnualEIR_.set (ScaledAnnualEIRTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!mode_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mode",
        "");
    }
  }

  Entomology* Entomology::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Entomology (*this, f, c);
  }

  Entomology& Entomology::
  operator= (const Entomology& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->nonVector_ = x.nonVector_;
      this->vector_ = x.vector_;
      this->name_ = x.name_;
      this->mode_ = x.mode_;
      this->scaledAnnualEIR_ = x.scaledAnnualEIR_;
    }

    return *this;
  }

  Entomology::
  ~Entomology ()
  {
  }

  // NonVector
  //

  NonVector::
  NonVector (const EipDurationType& eipDuration)
  : ::xml_schema::Type (),
    EIRDaily_ (this),
    eipDuration_ (eipDuration, this)
  {
  }

  NonVector::
  NonVector (const NonVector& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    EIRDaily_ (x.EIRDaily_, f, this),
    eipDuration_ (x.eipDuration_, f, this)
  {
  }

  NonVector::
  NonVector (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    EIRDaily_ (this),
    eipDuration_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void NonVector::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EIRDaily
      //
      if (n.name () == "EIRDaily" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< EIRDailyType > r (
          EIRDailyTraits::create (i, f, this));

        this->EIRDaily_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "eipDuration" && n.namespace_ ().empty ())
      {
        this->eipDuration_.set (EipDurationTraits::create (i, f, this));
        continue;
      }
    }

    if (!eipDuration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "eipDuration",
        "");
    }
  }

  NonVector* NonVector::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NonVector (*this, f, c);
  }

  NonVector& NonVector::
  operator= (const NonVector& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->EIRDaily_ = x.EIRDaily_;
      this->eipDuration_ = x.eipDuration_;
    }

    return *this;
  }

  NonVector::
  ~NonVector ()
  {
  }

  // EIRDaily
  //

  EIRDaily::
  EIRDaily (const ::xml_schema::Double& _xsd_Double_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (_xsd_Double_base),
    origin_ (this)
  {
  }

  EIRDaily::
  EIRDaily (const EIRDaily& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (x, f, c),
    origin_ (x.origin_, f, this)
  {
  }

  EIRDaily::
  EIRDaily (const xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ > (e, f | ::xml_schema::Flags::base, c),
    origin_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void EIRDaily::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "origin" && n.namespace_ ().empty ())
      {
        this->origin_.set (OriginTraits::create (i, f, this));
        continue;
      }
    }
  }

  EIRDaily* EIRDaily::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EIRDaily (*this, f, c);
  }

  EIRDaily& EIRDaily::
  operator= (const EIRDaily& x)
  {
    if (this != &x)
    {
      static_cast< ::xsd::cxx::tree::fundamental_base< ::xml_schema::Double, char, ::xml_schema::SimpleType, ::xsd::cxx::tree::schema_type::double_ >& > (*this) = x;
      this->origin_ = x.origin_;
    }

    return *this;
  }

  EIRDaily::
  ~EIRDaily ()
  {
  }

  // AnophelesParams
  //

  AnophelesParams::
  AnophelesParams (const SeasonalityType& seasonality,
                   const MosqType& mosq,
                   const MosquitoType& mosquito,
                   const PropInfectedType& propInfected,
                   const PropInfectiousType& propInfectious)
  : ::xml_schema::Type (),
    seasonality_ (seasonality, this),
    mosq_ (mosq, this),
    lifeCycle_ (this),
    simpleMPD_ (this),
    nonHumanHosts_ (this),
    mosquito_ (mosquito, this),
    propInfected_ (propInfected, this),
    propInfectious_ (propInfectious, this)
  {
  }

  AnophelesParams::
  AnophelesParams (::std::unique_ptr< SeasonalityType > seasonality,
                   ::std::unique_ptr< MosqType > mosq,
                   const MosquitoType& mosquito,
                   const PropInfectedType& propInfected,
                   const PropInfectiousType& propInfectious)
  : ::xml_schema::Type (),
    seasonality_ (std::move (seasonality), this),
    mosq_ (std::move (mosq), this),
    lifeCycle_ (this),
    simpleMPD_ (this),
    nonHumanHosts_ (this),
    mosquito_ (mosquito, this),
    propInfected_ (propInfected, this),
    propInfectious_ (propInfectious, this)
  {
  }

  AnophelesParams::
  AnophelesParams (const AnophelesParams& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    seasonality_ (x.seasonality_, f, this),
    mosq_ (x.mosq_, f, this),
    lifeCycle_ (x.lifeCycle_, f, this),
    simpleMPD_ (x.simpleMPD_, f, this),
    nonHumanHosts_ (x.nonHumanHosts_, f, this),
    mosquito_ (x.mosquito_, f, this),
    propInfected_ (x.propInfected_, f, this),
    propInfectious_ (x.propInfectious_, f, this)
  {
  }

  AnophelesParams::
  AnophelesParams (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    seasonality_ (this),
    mosq_ (this),
    lifeCycle_ (this),
    simpleMPD_ (this),
    nonHumanHosts_ (this),
    mosquito_ (this),
    propInfected_ (this),
    propInfectious_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AnophelesParams::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // seasonality
      //
      if (n.name () == "seasonality" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SeasonalityType > r (
          SeasonalityTraits::create (i, f, this));

        if (!seasonality_.present ())
        {
          this->seasonality_.set (::std::move (r));
          continue;
        }
      }

      // mosq
      //
      if (n.name () == "mosq" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqType > r (
          MosqTraits::create (i, f, this));

        if (!mosq_.present ())
        {
          this->mosq_.set (::std::move (r));
          continue;
        }
      }

      // lifeCycle
      //
      if (n.name () == "lifeCycle" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< LifeCycleType > r (
          LifeCycleTraits::create (i, f, this));

        if (!this->lifeCycle_)
        {
          this->lifeCycle_.set (::std::move (r));
          continue;
        }
      }

      // simpleMPD
      //
      if (n.name () == "simpleMPD" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SimpleMPDType > r (
          SimpleMPDTraits::create (i, f, this));

        if (!this->simpleMPD_)
        {
          this->simpleMPD_.set (::std::move (r));
          continue;
        }
      }

      // nonHumanHosts
      //
      if (n.name () == "nonHumanHosts" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< NonHumanHostsType > r (
          NonHumanHostsTraits::create (i, f, this));

        this->nonHumanHosts_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!seasonality_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "seasonality",
        "");
    }

    if (!mosq_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosq",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mosquito" && n.namespace_ ().empty ())
      {
        this->mosquito_.set (MosquitoTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "propInfected" && n.namespace_ ().empty ())
      {
        this->propInfected_.set (PropInfectedTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "propInfectious" && n.namespace_ ().empty ())
      {
        this->propInfectious_.set (PropInfectiousTraits::create (i, f, this));
        continue;
      }
    }

    if (!mosquito_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mosquito",
        "");
    }

    if (!propInfected_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "propInfected",
        "");
    }

    if (!propInfectious_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "propInfectious",
        "");
    }
  }

  AnophelesParams* AnophelesParams::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AnophelesParams (*this, f, c);
  }

  AnophelesParams& AnophelesParams::
  operator= (const AnophelesParams& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->seasonality_ = x.seasonality_;
      this->mosq_ = x.mosq_;
      this->lifeCycle_ = x.lifeCycle_;
      this->simpleMPD_ = x.simpleMPD_;
      this->nonHumanHosts_ = x.nonHumanHosts_;
      this->mosquito_ = x.mosquito_;
      this->propInfected_ = x.propInfected_;
      this->propInfectious_ = x.propInfectious_;
    }

    return *this;
  }

  AnophelesParams::
  ~AnophelesParams ()
  {
  }

  // MosqStage
  //

  MosqStage::
  MosqStage (const DurationType& duration,
             const SurvivalType& survival)
  : ::xml_schema::Type (),
    duration_ (duration, this),
    survival_ (survival, this)
  {
  }

  MosqStage::
  MosqStage (const MosqStage& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    duration_ (x.duration_, f, this),
    survival_ (x.survival_, f, this)
  {
  }

  MosqStage::
  MosqStage (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    duration_ (this),
    survival_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void MosqStage::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "duration" && n.namespace_ ().empty ())
      {
        this->duration_.set (DurationTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "survival" && n.namespace_ ().empty ())
      {
        this->survival_.set (SurvivalTraits::create (i, f, this));
        continue;
      }
    }

    if (!duration_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "duration",
        "");
    }

    if (!survival_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "survival",
        "");
    }
  }

  MosqStage* MosqStage::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MosqStage (*this, f, c);
  }

  MosqStage& MosqStage::
  operator= (const MosqStage& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->duration_ = x.duration_;
      this->survival_ = x.survival_;
    }

    return *this;
  }

  MosqStage::
  ~MosqStage ()
  {
  }

  // Vector
  //

  Vector::
  Vector ()
  : ::xml_schema::Type (),
    anopheles_ (this),
    nonHumanHosts_ (this)
  {
  }

  Vector::
  Vector (const Vector& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    anopheles_ (x.anopheles_, f, this),
    nonHumanHosts_ (x.nonHumanHosts_, f, this)
  {
  }

  Vector::
  Vector (const xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    anopheles_ (this),
    nonHumanHosts_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Vector::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // anopheles
      //
      if (n.name () == "anopheles" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AnophelesType > r (
          AnophelesTraits::create (i, f, this));

        this->anopheles_.push_back (::std::move (r));
        continue;
      }

      // nonHumanHosts
      //
      if (n.name () == "nonHumanHosts" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< NonHumanHostsType > r (
          NonHumanHostsTraits::create (i, f, this));

        this->nonHumanHosts_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Vector* Vector::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Vector (*this, f, c);
  }

  Vector& Vector::
  operator= (const Vector& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->anopheles_ = x.anopheles_;
      this->nonHumanHosts_ = x.nonHumanHosts_;
    }

    return *this;
  }

  Vector::
  ~Vector ()
  {
  }

  // Mode
  //

  Mode::
  Mode (const xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Mode_convert ();
  }

  Mode::
  Mode (const xercesc::DOMAttr& a,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Mode_convert ();
  }

  Mode::
  Mode (const ::std::string& s,
        const xercesc::DOMElement* e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Mode_convert ();
  }

  Mode* Mode::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Mode (*this, f, c);
  }

  Mode::Value Mode::
  _xsd_Mode_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Mode_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Mode_indexes_,
                      _xsd_Mode_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_Mode_indexes_ + 2 || _xsd_Mode_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Mode::
  _xsd_Mode_literals_[2] =
  {
    "forced",
    "dynamic"
  };

  const Mode::Value Mode::
  _xsd_Mode_indexes_[2] =
  {
    ::scnXml::Mode::dynamic,
    ::scnXml::Mode::forced
  };

  // Seasonality
  //

  Seasonality::
  Seasonality (const InputType& input)
  : ::xml_schema::Type (),
    fourierSeries_ (this),
    monthlyValues_ (this),
    dailyValues_ (this),
    input_ (input, this),
    annualEIR_ (this)
  {
  }

  Seasonality::
  Seasonality (const Seasonality& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    fourierSeries_ (x.fourierSeries_, f, this),
    monthlyValues_ (x.monthlyValues_, f, this),
    dailyValues_ (x.dailyValues_, f, this),
    input_ (x.input_, f, this),
    annualEIR_ (x.annualEIR_, f, this)
  {
  }

  Seasonality::
  Seasonality (const xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    fourierSeries_ (this),
    monthlyValues_ (this),
    dailyValues_ (this),
    input_ (this),
    annualEIR_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Seasonality::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // fourierSeries
      //
      if (n.name () == "fourierSeries" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< FourierSeriesType > r (
          FourierSeriesTraits::create (i, f, this));

        if (!this->fourierSeries_)
        {
          this->fourierSeries_.set (::std::move (r));
          continue;
        }
      }

      // monthlyValues
      //
      if (n.name () == "monthlyValues" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MonthlyValuesType > r (
          MonthlyValuesTraits::create (i, f, this));

        if (!this->monthlyValues_)
        {
          this->monthlyValues_.set (::std::move (r));
          continue;
        }
      }

      // dailyValues
      //
      if (n.name () == "dailyValues" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DailyValuesType > r (
          DailyValuesTraits::create (i, f, this));

        if (!this->dailyValues_)
        {
          this->dailyValues_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "input" && n.namespace_ ().empty ())
      {
        this->input_.set (InputTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "annualEIR" && n.namespace_ ().empty ())
      {
        this->annualEIR_.set (AnnualEIRTraits::create (i, f, this));
        continue;
      }
    }

    if (!input_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "input",
        "");
    }
  }

  Seasonality* Seasonality::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Seasonality (*this, f, c);
  }

  Seasonality& Seasonality::
  operator= (const Seasonality& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->fourierSeries_ = x.fourierSeries_;
      this->monthlyValues_ = x.monthlyValues_;
      this->dailyValues_ = x.dailyValues_;
      this->input_ = x.input_;
      this->annualEIR_ = x.annualEIR_;
    }

    return *this;
  }

  Seasonality::
  ~Seasonality ()
  {
  }

  // Mosq
  //

  Mosq::
  Mosq (const MosqRestDurationType& mosqRestDuration,
        const ExtrinsicIncubationPeriodType& extrinsicIncubationPeriod,
        const MosqLaidEggsSameDayProportionType& mosqLaidEggsSameDayProportion,
        const MosqSeekingDurationType& mosqSeekingDuration,
        const MosqSurvivalFeedingCycleProbabilityType& mosqSurvivalFeedingCycleProbability,
        const AvailabilityVarianceType& availabilityVariance,
        const MosqProbBitingType& mosqProbBiting,
        const MosqProbFindRestSiteType& mosqProbFindRestSite,
        const MosqProbRestingType& mosqProbResting,
        const MosqProbOvipositingType& mosqProbOvipositing,
        const MosqHumanBloodIndexType& mosqHumanBloodIndex,
        const MinInfectedThresholdType& minInfectedThreshold)
  : ::xml_schema::Type (),
    mosqRestDuration_ (mosqRestDuration, this),
    extrinsicIncubationPeriod_ (extrinsicIncubationPeriod, this),
    mosqLaidEggsSameDayProportion_ (mosqLaidEggsSameDayProportion, this),
    mosqSeekingDuration_ (mosqSeekingDuration, this),
    mosqSurvivalFeedingCycleProbability_ (mosqSurvivalFeedingCycleProbability, this),
    availabilityVariance_ (availabilityVariance, this),
    mosqProbBiting_ (mosqProbBiting, this),
    mosqProbFindRestSite_ (mosqProbFindRestSite, this),
    mosqProbResting_ (mosqProbResting, this),
    mosqProbOvipositing_ (mosqProbOvipositing, this),
    mosqHumanBloodIndex_ (mosqHumanBloodIndex, this),
    minInfectedThreshold_ (minInfectedThreshold, this)
  {
  }

  Mosq::
  Mosq (::std::unique_ptr< MosqRestDurationType > mosqRestDuration,
        ::std::unique_ptr< ExtrinsicIncubationPeriodType > extrinsicIncubationPeriod,
        ::std::unique_ptr< MosqLaidEggsSameDayProportionType > mosqLaidEggsSameDayProportion,
        ::std::unique_ptr< MosqSeekingDurationType > mosqSeekingDuration,
        ::std::unique_ptr< MosqSurvivalFeedingCycleProbabilityType > mosqSurvivalFeedingCycleProbability,
        ::std::unique_ptr< AvailabilityVarianceType > availabilityVariance,
        ::std::unique_ptr< MosqProbBitingType > mosqProbBiting,
        ::std::unique_ptr< MosqProbFindRestSiteType > mosqProbFindRestSite,
        ::std::unique_ptr< MosqProbRestingType > mosqProbResting,
        ::std::unique_ptr< MosqProbOvipositingType > mosqProbOvipositing,
        ::std::unique_ptr< MosqHumanBloodIndexType > mosqHumanBloodIndex,
        const MinInfectedThresholdType& minInfectedThreshold)
  : ::xml_schema::Type (),
    mosqRestDuration_ (std::move (mosqRestDuration), this),
    extrinsicIncubationPeriod_ (std::move (extrinsicIncubationPeriod), this),
    mosqLaidEggsSameDayProportion_ (std::move (mosqLaidEggsSameDayProportion), this),
    mosqSeekingDuration_ (std::move (mosqSeekingDuration), this),
    mosqSurvivalFeedingCycleProbability_ (std::move (mosqSurvivalFeedingCycleProbability), this),
    availabilityVariance_ (std::move (availabilityVariance), this),
    mosqProbBiting_ (std::move (mosqProbBiting), this),
    mosqProbFindRestSite_ (std::move (mosqProbFindRestSite), this),
    mosqProbResting_ (std::move (mosqProbResting), this),
    mosqProbOvipositing_ (std::move (mosqProbOvipositing), this),
    mosqHumanBloodIndex_ (std::move (mosqHumanBloodIndex), this),
    minInfectedThreshold_ (minInfectedThreshold, this)
  {
  }

  Mosq::
  Mosq (const Mosq& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    mosqRestDuration_ (x.mosqRestDuration_, f, this),
    extrinsicIncubationPeriod_ (x.extrinsicIncubationPeriod_, f, this),
    mosqLaidEggsSameDayProportion_ (x.mosqLaidEggsSameDayProportion_, f, this),
    mosqSeekingDuration_ (x.mosqSeekingDuration_, f, this),
    mosqSurvivalFeedingCycleProbability_ (x.mosqSurvivalFeedingCycleProbability_, f, this),
    availabilityVariance_ (x.availabilityVariance_, f, this),
    mosqProbBiting_ (x.mosqProbBiting_, f, this),
    mosqProbFindRestSite_ (x.mosqProbFindRestSite_, f, this),
    mosqProbResting_ (x.mosqProbResting_, f, this),
    mosqProbOvipositing_ (x.mosqProbOvipositing_, f, this),
    mosqHumanBloodIndex_ (x.mosqHumanBloodIndex_, f, this),
    minInfectedThreshold_ (x.minInfectedThreshold_, f, this)
  {
  }

  Mosq::
  Mosq (const xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    mosqRestDuration_ (this),
    extrinsicIncubationPeriod_ (this),
    mosqLaidEggsSameDayProportion_ (this),
    mosqSeekingDuration_ (this),
    mosqSurvivalFeedingCycleProbability_ (this),
    availabilityVariance_ (this),
    mosqProbBiting_ (this),
    mosqProbFindRestSite_ (this),
    mosqProbResting_ (this),
    mosqProbOvipositing_ (this),
    mosqHumanBloodIndex_ (this),
    minInfectedThreshold_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Mosq::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // mosqRestDuration
      //
      if (n.name () == "mosqRestDuration" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqRestDurationType > r (
          MosqRestDurationTraits::create (i, f, this));

        if (!mosqRestDuration_.present ())
        {
          this->mosqRestDuration_.set (::std::move (r));
          continue;
        }
      }

      // extrinsicIncubationPeriod
      //
      if (n.name () == "extrinsicIncubationPeriod" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ExtrinsicIncubationPeriodType > r (
          ExtrinsicIncubationPeriodTraits::create (i, f, this));

        if (!extrinsicIncubationPeriod_.present ())
        {
          this->extrinsicIncubationPeriod_.set (::std::move (r));
          continue;
        }
      }

      // mosqLaidEggsSameDayProportion
      //
      if (n.name () == "mosqLaidEggsSameDayProportion" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqLaidEggsSameDayProportionType > r (
          MosqLaidEggsSameDayProportionTraits::create (i, f, this));

        if (!mosqLaidEggsSameDayProportion_.present ())
        {
          this->mosqLaidEggsSameDayProportion_.set (::std::move (r));
          continue;
        }
      }

      // mosqSeekingDuration
      //
      if (n.name () == "mosqSeekingDuration" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqSeekingDurationType > r (
          MosqSeekingDurationTraits::create (i, f, this));

        if (!mosqSeekingDuration_.present ())
        {
          this->mosqSeekingDuration_.set (::std::move (r));
          continue;
        }
      }

      // mosqSurvivalFeedingCycleProbability
      //
      if (n.name () == "mosqSurvivalFeedingCycleProbability" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqSurvivalFeedingCycleProbabilityType > r (
          MosqSurvivalFeedingCycleProbabilityTraits::create (i, f, this));

        if (!mosqSurvivalFeedingCycleProbability_.present ())
        {
          this->mosqSurvivalFeedingCycleProbability_.set (::std::move (r));
          continue;
        }
      }

      // availabilityVariance
      //
      if (n.name () == "availabilityVariance" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AvailabilityVarianceType > r (
          AvailabilityVarianceTraits::create (i, f, this));

        if (!availabilityVariance_.present ())
        {
          this->availabilityVariance_.set (::std::move (r));
          continue;
        }
      }

      // mosqProbBiting
      //
      if (n.name () == "mosqProbBiting" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqProbBitingType > r (
          MosqProbBitingTraits::create (i, f, this));

        if (!mosqProbBiting_.present ())
        {
          this->mosqProbBiting_.set (::std::move (r));
          continue;
        }
      }

      // mosqProbFindRestSite
      //
      if (n.name () == "mosqProbFindRestSite" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqProbFindRestSiteType > r (
          MosqProbFindRestSiteTraits::create (i, f, this));

        if (!mosqProbFindRestSite_.present ())
        {
          this->mosqProbFindRestSite_.set (::std::move (r));
          continue;
        }
      }

      // mosqProbResting
      //
      if (n.name () == "mosqProbResting" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqProbRestingType > r (
          MosqProbRestingTraits::create (i, f, this));

        if (!mosqProbResting_.present ())
        {
          this->mosqProbResting_.set (::std::move (r));
          continue;
        }
      }

      // mosqProbOvipositing
      //
      if (n.name () == "mosqProbOvipositing" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqProbOvipositingType > r (
          MosqProbOvipositingTraits::create (i, f, this));

        if (!mosqProbOvipositing_.present ())
        {
          this->mosqProbOvipositing_.set (::std::move (r));
          continue;
        }
      }

      // mosqHumanBloodIndex
      //
      if (n.name () == "mosqHumanBloodIndex" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqHumanBloodIndexType > r (
          MosqHumanBloodIndexTraits::create (i, f, this));

        if (!mosqHumanBloodIndex_.present ())
        {
          this->mosqHumanBloodIndex_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!mosqRestDuration_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosqRestDuration",
        "");
    }

    if (!extrinsicIncubationPeriod_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "extrinsicIncubationPeriod",
        "");
    }

    if (!mosqLaidEggsSameDayProportion_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosqLaidEggsSameDayProportion",
        "");
    }

    if (!mosqSeekingDuration_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosqSeekingDuration",
        "");
    }

    if (!mosqSurvivalFeedingCycleProbability_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosqSurvivalFeedingCycleProbability",
        "");
    }

    if (!availabilityVariance_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "availabilityVariance",
        "");
    }

    if (!mosqProbBiting_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosqProbBiting",
        "");
    }

    if (!mosqProbFindRestSite_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosqProbFindRestSite",
        "");
    }

    if (!mosqProbResting_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosqProbResting",
        "");
    }

    if (!mosqProbOvipositing_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosqProbOvipositing",
        "");
    }

    if (!mosqHumanBloodIndex_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosqHumanBloodIndex",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "minInfectedThreshold" && n.namespace_ ().empty ())
      {
        this->minInfectedThreshold_.set (MinInfectedThresholdTraits::create (i, f, this));
        continue;
      }
    }

    if (!minInfectedThreshold_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "minInfectedThreshold",
        "");
    }
  }

  Mosq* Mosq::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Mosq (*this, f, c);
  }

  Mosq& Mosq::
  operator= (const Mosq& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->mosqRestDuration_ = x.mosqRestDuration_;
      this->extrinsicIncubationPeriod_ = x.extrinsicIncubationPeriod_;
      this->mosqLaidEggsSameDayProportion_ = x.mosqLaidEggsSameDayProportion_;
      this->mosqSeekingDuration_ = x.mosqSeekingDuration_;
      this->mosqSurvivalFeedingCycleProbability_ = x.mosqSurvivalFeedingCycleProbability_;
      this->availabilityVariance_ = x.availabilityVariance_;
      this->mosqProbBiting_ = x.mosqProbBiting_;
      this->mosqProbFindRestSite_ = x.mosqProbFindRestSite_;
      this->mosqProbResting_ = x.mosqProbResting_;
      this->mosqProbOvipositing_ = x.mosqProbOvipositing_;
      this->mosqHumanBloodIndex_ = x.mosqHumanBloodIndex_;
      this->minInfectedThreshold_ = x.minInfectedThreshold_;
    }

    return *this;
  }

  Mosq::
  ~Mosq ()
  {
  }

  // LifeCycle
  //

  LifeCycle::
  LifeCycle (const EggStageType& eggStage,
             const LarvalStageType& larvalStage,
             const PupalStageType& pupalStage,
             const FemaleEggsLaidByOvipositType& femaleEggsLaidByOviposit)
  : ::xml_schema::Type (),
    eggStage_ (eggStage, this),
    larvalStage_ (larvalStage, this),
    pupalStage_ (pupalStage, this),
    femaleEggsLaidByOviposit_ (femaleEggsLaidByOviposit, this),
    estimatedLarvalResources_ (getEstimatedLarvalResourcesDefaultValue (), this)
  {
  }

  LifeCycle::
  LifeCycle (::std::unique_ptr< EggStageType > eggStage,
             ::std::unique_ptr< LarvalStageType > larvalStage,
             ::std::unique_ptr< PupalStageType > pupalStage,
             ::std::unique_ptr< FemaleEggsLaidByOvipositType > femaleEggsLaidByOviposit)
  : ::xml_schema::Type (),
    eggStage_ (std::move (eggStage), this),
    larvalStage_ (std::move (larvalStage), this),
    pupalStage_ (std::move (pupalStage), this),
    femaleEggsLaidByOviposit_ (std::move (femaleEggsLaidByOviposit), this),
    estimatedLarvalResources_ (getEstimatedLarvalResourcesDefaultValue (), this)
  {
  }

  LifeCycle::
  LifeCycle (const LifeCycle& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    eggStage_ (x.eggStage_, f, this),
    larvalStage_ (x.larvalStage_, f, this),
    pupalStage_ (x.pupalStage_, f, this),
    femaleEggsLaidByOviposit_ (x.femaleEggsLaidByOviposit_, f, this),
    estimatedLarvalResources_ (x.estimatedLarvalResources_, f, this)
  {
  }

  LifeCycle::
  LifeCycle (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    eggStage_ (this),
    larvalStage_ (this),
    pupalStage_ (this),
    femaleEggsLaidByOviposit_ (this),
    estimatedLarvalResources_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LifeCycle::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // eggStage
      //
      if (n.name () == "eggStage" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< EggStageType > r (
          EggStageTraits::create (i, f, this));

        if (!eggStage_.present ())
        {
          this->eggStage_.set (::std::move (r));
          continue;
        }
      }

      // larvalStage
      //
      if (n.name () == "larvalStage" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< LarvalStageType > r (
          LarvalStageTraits::create (i, f, this));

        if (!larvalStage_.present ())
        {
          this->larvalStage_.set (::std::move (r));
          continue;
        }
      }

      // pupalStage
      //
      if (n.name () == "pupalStage" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PupalStageType > r (
          PupalStageTraits::create (i, f, this));

        if (!pupalStage_.present ())
        {
          this->pupalStage_.set (::std::move (r));
          continue;
        }
      }

      // femaleEggsLaidByOviposit
      //
      if (n.name () == "femaleEggsLaidByOviposit" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< FemaleEggsLaidByOvipositType > r (
          FemaleEggsLaidByOvipositTraits::create (i, f, this));

        if (!femaleEggsLaidByOviposit_.present ())
        {
          this->femaleEggsLaidByOviposit_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!eggStage_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "eggStage",
        "");
    }

    if (!larvalStage_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "larvalStage",
        "");
    }

    if (!pupalStage_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pupalStage",
        "");
    }

    if (!femaleEggsLaidByOviposit_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "femaleEggsLaidByOviposit",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "estimatedLarvalResources" && n.namespace_ ().empty ())
      {
        this->estimatedLarvalResources_.set (EstimatedLarvalResourcesTraits::create (i, f, this));
        continue;
      }
    }

    if (!estimatedLarvalResources_.present ())
    {
      this->estimatedLarvalResources_.set (getEstimatedLarvalResourcesDefaultValue ());
    }
  }

  LifeCycle* LifeCycle::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LifeCycle (*this, f, c);
  }

  LifeCycle& LifeCycle::
  operator= (const LifeCycle& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->eggStage_ = x.eggStage_;
      this->larvalStage_ = x.larvalStage_;
      this->pupalStage_ = x.pupalStage_;
      this->femaleEggsLaidByOviposit_ = x.femaleEggsLaidByOviposit_;
      this->estimatedLarvalResources_ = x.estimatedLarvalResources_;
    }

    return *this;
  }

  LifeCycle::
  ~LifeCycle ()
  {
  }

  // SimpleMPD
  //

  SimpleMPD::
  SimpleMPD (const DevelopmentDurationType& developmentDuration,
             const DevelopmentSurvivalType& developmentSurvival,
             const FemaleEggsLaidByOvipositType& femaleEggsLaidByOviposit)
  : ::xml_schema::Type (),
    developmentDuration_ (developmentDuration, this),
    developmentSurvival_ (developmentSurvival, this),
    femaleEggsLaidByOviposit_ (femaleEggsLaidByOviposit, this)
  {
  }

  SimpleMPD::
  SimpleMPD (::std::unique_ptr< DevelopmentDurationType > developmentDuration,
             ::std::unique_ptr< DevelopmentSurvivalType > developmentSurvival,
             ::std::unique_ptr< FemaleEggsLaidByOvipositType > femaleEggsLaidByOviposit)
  : ::xml_schema::Type (),
    developmentDuration_ (std::move (developmentDuration), this),
    developmentSurvival_ (std::move (developmentSurvival), this),
    femaleEggsLaidByOviposit_ (std::move (femaleEggsLaidByOviposit), this)
  {
  }

  SimpleMPD::
  SimpleMPD (const SimpleMPD& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    developmentDuration_ (x.developmentDuration_, f, this),
    developmentSurvival_ (x.developmentSurvival_, f, this),
    femaleEggsLaidByOviposit_ (x.femaleEggsLaidByOviposit_, f, this)
  {
  }

  SimpleMPD::
  SimpleMPD (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    developmentDuration_ (this),
    developmentSurvival_ (this),
    femaleEggsLaidByOviposit_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void SimpleMPD::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // developmentDuration
      //
      if (n.name () == "developmentDuration" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DevelopmentDurationType > r (
          DevelopmentDurationTraits::create (i, f, this));

        if (!developmentDuration_.present ())
        {
          this->developmentDuration_.set (::std::move (r));
          continue;
        }
      }

      // developmentSurvival
      //
      if (n.name () == "developmentSurvival" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DevelopmentSurvivalType > r (
          DevelopmentSurvivalTraits::create (i, f, this));

        if (!developmentSurvival_.present ())
        {
          this->developmentSurvival_.set (::std::move (r));
          continue;
        }
      }

      // femaleEggsLaidByOviposit
      //
      if (n.name () == "femaleEggsLaidByOviposit" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< FemaleEggsLaidByOvipositType > r (
          FemaleEggsLaidByOvipositTraits::create (i, f, this));

        if (!femaleEggsLaidByOviposit_.present ())
        {
          this->femaleEggsLaidByOviposit_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!developmentDuration_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "developmentDuration",
        "");
    }

    if (!developmentSurvival_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "developmentSurvival",
        "");
    }

    if (!femaleEggsLaidByOviposit_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "femaleEggsLaidByOviposit",
        "");
    }
  }

  SimpleMPD* SimpleMPD::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SimpleMPD (*this, f, c);
  }

  SimpleMPD& SimpleMPD::
  operator= (const SimpleMPD& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->developmentDuration_ = x.developmentDuration_;
      this->developmentSurvival_ = x.developmentSurvival_;
      this->femaleEggsLaidByOviposit_ = x.femaleEggsLaidByOviposit_;
    }

    return *this;
  }

  SimpleMPD::
  ~SimpleMPD ()
  {
  }

  // NonHumanHosts
  //

  NonHumanHosts::
  NonHumanHosts (const MosqRelativeEntoAvailabilityType& mosqRelativeEntoAvailability,
                 const MosqProbBitingType& mosqProbBiting,
                 const MosqProbFindRestSiteType& mosqProbFindRestSite,
                 const MosqProbRestingType& mosqProbResting,
                 const NameType& name)
  : ::xml_schema::Type (),
    mosqRelativeEntoAvailability_ (mosqRelativeEntoAvailability, this),
    mosqProbBiting_ (mosqProbBiting, this),
    mosqProbFindRestSite_ (mosqProbFindRestSite, this),
    mosqProbResting_ (mosqProbResting, this),
    hostFecundityFactor_ (this),
    name_ (name, this)
  {
  }

  NonHumanHosts::
  NonHumanHosts (::std::unique_ptr< MosqRelativeEntoAvailabilityType > mosqRelativeEntoAvailability,
                 ::std::unique_ptr< MosqProbBitingType > mosqProbBiting,
                 ::std::unique_ptr< MosqProbFindRestSiteType > mosqProbFindRestSite,
                 ::std::unique_ptr< MosqProbRestingType > mosqProbResting,
                 const NameType& name)
  : ::xml_schema::Type (),
    mosqRelativeEntoAvailability_ (std::move (mosqRelativeEntoAvailability), this),
    mosqProbBiting_ (std::move (mosqProbBiting), this),
    mosqProbFindRestSite_ (std::move (mosqProbFindRestSite), this),
    mosqProbResting_ (std::move (mosqProbResting), this),
    hostFecundityFactor_ (this),
    name_ (name, this)
  {
  }

  NonHumanHosts::
  NonHumanHosts (const NonHumanHosts& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    mosqRelativeEntoAvailability_ (x.mosqRelativeEntoAvailability_, f, this),
    mosqProbBiting_ (x.mosqProbBiting_, f, this),
    mosqProbFindRestSite_ (x.mosqProbFindRestSite_, f, this),
    mosqProbResting_ (x.mosqProbResting_, f, this),
    hostFecundityFactor_ (x.hostFecundityFactor_, f, this),
    name_ (x.name_, f, this)
  {
  }

  NonHumanHosts::
  NonHumanHosts (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    mosqRelativeEntoAvailability_ (this),
    mosqProbBiting_ (this),
    mosqProbFindRestSite_ (this),
    mosqProbResting_ (this),
    hostFecundityFactor_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void NonHumanHosts::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // mosqRelativeEntoAvailability
      //
      if (n.name () == "mosqRelativeEntoAvailability" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqRelativeEntoAvailabilityType > r (
          MosqRelativeEntoAvailabilityTraits::create (i, f, this));

        if (!mosqRelativeEntoAvailability_.present ())
        {
          this->mosqRelativeEntoAvailability_.set (::std::move (r));
          continue;
        }
      }

      // mosqProbBiting
      //
      if (n.name () == "mosqProbBiting" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqProbBitingType > r (
          MosqProbBitingTraits::create (i, f, this));

        if (!mosqProbBiting_.present ())
        {
          this->mosqProbBiting_.set (::std::move (r));
          continue;
        }
      }

      // mosqProbFindRestSite
      //
      if (n.name () == "mosqProbFindRestSite" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqProbFindRestSiteType > r (
          MosqProbFindRestSiteTraits::create (i, f, this));

        if (!mosqProbFindRestSite_.present ())
        {
          this->mosqProbFindRestSite_.set (::std::move (r));
          continue;
        }
      }

      // mosqProbResting
      //
      if (n.name () == "mosqProbResting" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MosqProbRestingType > r (
          MosqProbRestingTraits::create (i, f, this));

        if (!mosqProbResting_.present ())
        {
          this->mosqProbResting_.set (::std::move (r));
          continue;
        }
      }

      // hostFecundityFactor
      //
      if (n.name () == "hostFecundityFactor" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< HostFecundityFactorType > r (
          HostFecundityFactorTraits::create (i, f, this));

        if (!this->hostFecundityFactor_)
        {
          this->hostFecundityFactor_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!mosqRelativeEntoAvailability_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosqRelativeEntoAvailability",
        "");
    }

    if (!mosqProbBiting_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosqProbBiting",
        "");
    }

    if (!mosqProbFindRestSite_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosqProbFindRestSite",
        "");
    }

    if (!mosqProbResting_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "mosqProbResting",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  NonHumanHosts* NonHumanHosts::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NonHumanHosts (*this, f, c);
  }

  NonHumanHosts& NonHumanHosts::
  operator= (const NonHumanHosts& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->mosqRelativeEntoAvailability_ = x.mosqRelativeEntoAvailability_;
      this->mosqProbBiting_ = x.mosqProbBiting_;
      this->mosqProbFindRestSite_ = x.mosqProbFindRestSite_;
      this->mosqProbResting_ = x.mosqProbResting_;
      this->hostFecundityFactor_ = x.hostFecundityFactor_;
      this->name_ = x.name_;
    }

    return *this;
  }

  NonHumanHosts::
  ~NonHumanHosts ()
  {
  }

  // NonHumanHosts1
  //

  NonHumanHosts1::
  NonHumanHosts1 (const NameType& name,
                  const NumberType& number)
  : ::xml_schema::Type (),
    name_ (name, this),
    number_ (number, this)
  {
  }

  NonHumanHosts1::
  NonHumanHosts1 (const NonHumanHosts1& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    number_ (x.number_, f, this)
  {
  }

  NonHumanHosts1::
  NonHumanHosts1 (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    number_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void NonHumanHosts1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (NumberTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "number",
        "");
    }
  }

  NonHumanHosts1* NonHumanHosts1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NonHumanHosts1 (*this, f, c);
  }

  NonHumanHosts1& NonHumanHosts1::
  operator= (const NonHumanHosts1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->number_ = x.number_;
    }

    return *this;
  }

  NonHumanHosts1::
  ~NonHumanHosts1 ()
  {
  }

  // FourierSeries
  //

  FourierSeries::
  FourierSeries (const EIRRotateAngleType& EIRRotateAngle)
  : ::xml_schema::Type (),
    coeffic_ (this),
    EIRRotateAngle_ (EIRRotateAngle, this)
  {
  }

  FourierSeries::
  FourierSeries (const FourierSeries& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    coeffic_ (x.coeffic_, f, this),
    EIRRotateAngle_ (x.EIRRotateAngle_, f, this)
  {
  }

  FourierSeries::
  FourierSeries (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    coeffic_ (this),
    EIRRotateAngle_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void FourierSeries::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // coeffic
      //
      if (n.name () == "coeffic" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< CoefficType > r (
          CoefficTraits::create (i, f, this));

        this->coeffic_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "EIRRotateAngle" && n.namespace_ ().empty ())
      {
        this->EIRRotateAngle_.set (EIRRotateAngleTraits::create (i, f, this));
        continue;
      }
    }

    if (!EIRRotateAngle_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "EIRRotateAngle",
        "");
    }
  }

  FourierSeries* FourierSeries::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class FourierSeries (*this, f, c);
  }

  FourierSeries& FourierSeries::
  operator= (const FourierSeries& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->coeffic_ = x.coeffic_;
      this->EIRRotateAngle_ = x.EIRRotateAngle_;
    }

    return *this;
  }

  FourierSeries::
  ~FourierSeries ()
  {
  }

  // MonthlyValues
  //

  MonthlyValues::
  MonthlyValues (const SmoothingType& smoothing)
  : ::xml_schema::Type (),
    value_ (this),
    smoothing_ (smoothing, this)
  {
  }

  MonthlyValues::
  MonthlyValues (const MonthlyValues& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    value_ (x.value_, f, this),
    smoothing_ (x.smoothing_, f, this)
  {
  }

  MonthlyValues::
  MonthlyValues (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    value_ (this),
    smoothing_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void MonthlyValues::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // value
      //
      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.push_back (ValueTraits::create (i, f, this));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "smoothing" && n.namespace_ ().empty ())
      {
        this->smoothing_.set (SmoothingTraits::create (i, f, this));
        continue;
      }
    }

    if (!smoothing_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "smoothing",
        "");
    }
  }

  MonthlyValues* MonthlyValues::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MonthlyValues (*this, f, c);
  }

  MonthlyValues& MonthlyValues::
  operator= (const MonthlyValues& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->value_ = x.value_;
      this->smoothing_ = x.smoothing_;
    }

    return *this;
  }

  MonthlyValues::
  ~MonthlyValues ()
  {
  }

  // DailyValues
  //

  DailyValues::
  DailyValues ()
  : ::xml_schema::Type (),
    value_ (this)
  {
  }

  DailyValues::
  DailyValues (const DailyValues& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  DailyValues::
  DailyValues (const xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DailyValues::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // value
      //
      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.push_back (ValueTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  DailyValues* DailyValues::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DailyValues (*this, f, c);
  }

  DailyValues& DailyValues::
  operator= (const DailyValues& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  DailyValues::
  ~DailyValues ()
  {
  }

  // Input
  //

  Input::
  Input (const xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Input_convert ();
  }

  Input::
  Input (const xercesc::DOMAttr& a,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Input_convert ();
  }

  Input::
  Input (const ::std::string& s,
         const xercesc::DOMElement* e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Input_convert ();
  }

  Input* Input::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Input (*this, f, c);
  }

  Input::Value Input::
  _xsd_Input_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Input_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Input_indexes_,
                      _xsd_Input_indexes_ + 1,
                      *this,
                      c));

    if (i == _xsd_Input_indexes_ + 1 || _xsd_Input_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Input::
  _xsd_Input_literals_[1] =
  {
    "EIR"
  };

  const Input::Value Input::
  _xsd_Input_indexes_[1] =
  {
    ::scnXml::Input::EIR
  };

  // LarvalStage
  //

  LarvalStage::
  LarvalStage (const DurationType& duration,
               const SurvivalType& survival)
  : ::scnXml::MosqStage (duration,
                         survival),
    daily_ (this)
  {
  }

  LarvalStage::
  LarvalStage (const LarvalStage& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::scnXml::MosqStage (x, f, c),
    daily_ (x.daily_, f, this)
  {
  }

  LarvalStage::
  LarvalStage (const xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::scnXml::MosqStage (e, f | ::xml_schema::Flags::base, c),
    daily_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void LarvalStage::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::MosqStage::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // daily
      //
      if (n.name () == "daily" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DailyType > r (
          DailyTraits::create (i, f, this));

        this->daily_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  LarvalStage* LarvalStage::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LarvalStage (*this, f, c);
  }

  LarvalStage& LarvalStage::
  operator= (const LarvalStage& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::MosqStage& > (*this) = x;
      this->daily_ = x.daily_;
    }

    return *this;
  }

  LarvalStage::
  ~LarvalStage ()
  {
  }

  // Coeffic
  //

  Coeffic::
  Coeffic (const AType& a,
           const BType& b)
  : ::xml_schema::Type (),
    a_ (a, this),
    b_ (b, this)
  {
  }

  Coeffic::
  Coeffic (const Coeffic& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    a_ (x.a_, f, this),
    b_ (x.b_, f, this)
  {
  }

  Coeffic::
  Coeffic (const xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    a_ (this),
    b_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Coeffic::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "a" && n.namespace_ ().empty ())
      {
        this->a_.set (ATraits::create (i, f, this));
        continue;
      }

      if (n.name () == "b" && n.namespace_ ().empty ())
      {
        this->b_.set (BTraits::create (i, f, this));
        continue;
      }
    }

    if (!a_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "a",
        "");
    }

    if (!b_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "b",
        "");
    }
  }

  Coeffic* Coeffic::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Coeffic (*this, f, c);
  }

  Coeffic& Coeffic::
  operator= (const Coeffic& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->a_ = x.a_;
      this->b_ = x.b_;
    }

    return *this;
  }

  Coeffic::
  ~Coeffic ()
  {
  }

  // Smoothing
  //

  Smoothing::
  Smoothing (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Smoothing_convert ();
  }

  Smoothing::
  Smoothing (const xercesc::DOMAttr& a,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Smoothing_convert ();
  }

  Smoothing::
  Smoothing (const ::std::string& s,
             const xercesc::DOMElement* e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Smoothing_convert ();
  }

  Smoothing* Smoothing::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Smoothing (*this, f, c);
  }

  Smoothing::Value Smoothing::
  _xsd_Smoothing_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Smoothing_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Smoothing_indexes_,
                      _xsd_Smoothing_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_Smoothing_indexes_ + 2 || _xsd_Smoothing_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Smoothing::
  _xsd_Smoothing_literals_[2] =
  {
    "none",
    "fourier"
  };

  const Smoothing::Value Smoothing::
  _xsd_Smoothing_indexes_[2] =
  {
    ::scnXml::Smoothing::fourier,
    ::scnXml::Smoothing::none
  };

  // Daily
  //

  Daily::
  Daily (const ResourceUsageType& resourceUsage,
         const EffectCompetitionType& effectCompetition)
  : ::xml_schema::Type (),
    resourceUsage_ (resourceUsage, this),
    effectCompetition_ (effectCompetition, this)
  {
  }

  Daily::
  Daily (const Daily& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    resourceUsage_ (x.resourceUsage_, f, this),
    effectCompetition_ (x.effectCompetition_, f, this)
  {
  }

  Daily::
  Daily (const xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    resourceUsage_ (this),
    effectCompetition_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Daily::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "resourceUsage" && n.namespace_ ().empty ())
      {
        this->resourceUsage_.set (ResourceUsageTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "effectCompetition" && n.namespace_ ().empty ())
      {
        this->effectCompetition_.set (EffectCompetitionTraits::create (i, f, this));
        continue;
      }
    }

    if (!resourceUsage_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "resourceUsage",
        "");
    }

    if (!effectCompetition_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "effectCompetition",
        "");
    }
  }

  Daily* Daily::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Daily (*this, f, c);
  }

  Daily& Daily::
  operator= (const Daily& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->resourceUsage_ = x.resourceUsage_;
      this->effectCompetition_ = x.effectCompetition_;
    }

    return *this;
  }

  Daily::
  ~Daily ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace scnXml
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "util.h"

namespace scnXml
{
  // Component
  // 

  const Component::IdType& Component::
  getId () const
  {
    return this->id_.get ();
  }

  Component::IdType& Component::
  getId ()
  {
    return this->id_.get ();
  }

  void Component::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void Component::
  setId (::std::unique_ptr< IdType > x)
  {
    this->id_.set (std::move (x));
  }


  // TriggeredDeployments
  // 

  const TriggeredDeployments::DeploySequence& TriggeredDeployments::
  getDeploy () const
  {
    return this->deploy_;
  }

  TriggeredDeployments::DeploySequence& TriggeredDeployments::
  getDeploy ()
  {
    return this->deploy_;
  }

  void TriggeredDeployments::
  setDeploy (const DeploySequence& s)
  {
    this->deploy_ = s;
  }


  // OptionSet
  // 

  const OptionSet::OptionSequence& OptionSet::
  getOption () const
  {
    return this->option_;
  }

  OptionSet::OptionSequence& OptionSet::
  getOption ()
  {
    return this->option_;
  }

  void OptionSet::
  setOption (const OptionSequence& s)
  {
    this->option_ = s;
  }


  // Option
  // 

  const Option::NameType& Option::
  getName () const
  {
    return this->name_.get ();
  }

  Option::NameType& Option::
  getName ()
  {
    return this->name_.get ();
  }

  void Option::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Option::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const Option::ValueType& Option::
  getValue () const
  {
    return this->value_.get ();
  }

  Option::ValueType& Option::
  getValue ()
  {
    return this->value_.get ();
  }

  void Option::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }

  Option::ValueType Option::
  getValueDefaultValue ()
  {
    return ValueType (true);
  }


  // DoubleList
  // 

  const DoubleList::ItemSequence& DoubleList::
  getItem () const
  {
    return this->item_;
  }

  DoubleList::ItemSequence& DoubleList::
  getItem ()
  {
    return this->item_;
  }

  void DoubleList::
  setItem (const ItemSequence& s)
  {
    this->item_ = s;
  }


  // DecayFunction
  // 

  const DecayFunction::FunctionType& DecayFunction::
  getFunction () const
  {
    return this->function_.get ();
  }

  DecayFunction::FunctionType& DecayFunction::
  getFunction ()
  {
    return this->function_.get ();
  }

  void DecayFunction::
  setFunction (const FunctionType& x)
  {
    this->function_.set (x);
  }

  void DecayFunction::
  setFunction (::std::unique_ptr< FunctionType > x)
  {
    this->function_.set (std::move (x));
  }

  const DecayFunction::LOptional& DecayFunction::
  getL () const
  {
    return this->L_;
  }

  DecayFunction::LOptional& DecayFunction::
  getL ()
  {
    return this->L_;
  }

  void DecayFunction::
  setL (const LType& x)
  {
    this->L_.set (x);
  }

  void DecayFunction::
  setL (const LOptional& x)
  {
    this->L_ = x;
  }

  void DecayFunction::
  setL (::std::unique_ptr< LType > x)
  {
    this->L_.set (std::move (x));
  }

  const DecayFunction::KType& DecayFunction::
  getK () const
  {
    return this->k_.get ();
  }

  DecayFunction::KType& DecayFunction::
  getK ()
  {
    return this->k_.get ();
  }

  void DecayFunction::
  setK (const KType& x)
  {
    this->k_.set (x);
  }

  DecayFunction::KType DecayFunction::
  getKDefaultValue ()
  {
    return KType (1.0);
  }

  const DecayFunction::MuType& DecayFunction::
  getMu () const
  {
    return this->mu_.get ();
  }

  DecayFunction::MuType& DecayFunction::
  getMu ()
  {
    return this->mu_.get ();
  }

  void DecayFunction::
  setMu (const MuType& x)
  {
    this->mu_.set (x);
  }

  DecayFunction::MuType DecayFunction::
  getMuDefaultValue ()
  {
    return MuType (0.0);
  }

  const DecayFunction::SigmaType& DecayFunction::
  getSigma () const
  {
    return this->sigma_.get ();
  }

  DecayFunction::SigmaType& DecayFunction::
  getSigma ()
  {
    return this->sigma_.get ();
  }

  void DecayFunction::
  setSigma (const SigmaType& x)
  {
    this->sigma_.set (x);
  }

  DecayFunction::SigmaType DecayFunction::
  getSigmaDefaultValue ()
  {
    return SigmaType (0.0);
  }


  // LognormalSample
  // 

  const LognormalSample::MeanType& LognormalSample::
  getMean () const
  {
    return this->mean_.get ();
  }

  LognormalSample::MeanType& LognormalSample::
  getMean ()
  {
    return this->mean_.get ();
  }

  void LognormalSample::
  setMean (const MeanType& x)
  {
    this->mean_.set (x);
  }

  const LognormalSample::SigmaType& LognormalSample::
  getSigma () const
  {
    return this->sigma_.get ();
  }

  LognormalSample::SigmaType& LognormalSample::
  getSigma ()
  {
    return this->sigma_.get ();
  }

  void LognormalSample::
  setSigma (const SigmaType& x)
  {
    this->sigma_.set (x);
  }


  // NormalSample
  // 

  const NormalSample::MuType& NormalSample::
  getMu () const
  {
    return this->mu_.get ();
  }

  NormalSample::MuType& NormalSample::
  getMu ()
  {
    return this->mu_.get ();
  }

  void NormalSample::
  setMu (const MuType& x)
  {
    this->mu_.set (x);
  }

  const NormalSample::SigmaType& NormalSample::
  getSigma () const
  {
    return this->sigma_.get ();
  }

  NormalSample::SigmaType& NormalSample::
  getSigma ()
  {
    return this->sigma_.get ();
  }

  void NormalSample::
  setSigma (const SigmaType& x)
  {
    this->sigma_.set (x);
  }


  // BetaMeanSample
  // 

  const BetaMeanSample::MeanType& BetaMeanSample::
  getMean () const
  {
    return this->mean_.get ();
  }

  BetaMeanSample::MeanType& BetaMeanSample::
  getMean ()
  {
    return this->mean_.get ();
  }

  void BetaMeanSample::
  setMean (const MeanType& x)
  {
    this->mean_.set (x);
  }

  const BetaMeanSample::VarianceType& BetaMeanSample::
  getVariance () const
  {
    return this->variance_.get ();
  }

  BetaMeanSample::VarianceType& BetaMeanSample::
  getVariance ()
  {
    return this->variance_.get ();
  }

  void BetaMeanSample::
  setVariance (const VarianceType& x)
  {
    this->variance_.set (x);
  }


  // SampledValue
  // 

  const SampledValue::MeanType& SampledValue::
  getMean () const
  {
    return this->mean_.get ();
  }

  SampledValue::MeanType& SampledValue::
  getMean ()
  {
    return this->mean_.get ();
  }

  void SampledValue::
  setMean (const MeanType& x)
  {
    this->mean_.set (x);
  }

  const SampledValue::CvOptional& SampledValue::
  getCv () const
  {
    return this->cv_;
  }

  SampledValue::CvOptional& SampledValue::
  getCv ()
  {
    return this->cv_;
  }

  void SampledValue::
  setCv (const CvType& x)
  {
    this->cv_.set (x);
  }

  void SampledValue::
  setCv (const CvOptional& x)
  {
    this->cv_ = x;
  }

  const SampledValue::DistrType& SampledValue::
  getDistr () const
  {
    return this->distr_.get ();
  }

  SampledValue::DistrType& SampledValue::
  getDistr ()
  {
    return this->distr_.get ();
  }

  void SampledValue::
  setDistr (const DistrType& x)
  {
    this->distr_.set (x);
  }

  void SampledValue::
  setDistr (::std::unique_ptr< DistrType > x)
  {
    this->distr_.set (std::move (x));
  }


  // DoubleValue
  // 

  const DoubleValue::ValueType& DoubleValue::
  getValue () const
  {
    return this->value_.get ();
  }

  DoubleValue::ValueType& DoubleValue::
  getValue ()
  {
    return this->value_.get ();
  }

  void DoubleValue::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }


  // IntValue
  // 

  const IntValue::ValueType& IntValue::
  getValue () const
  {
    return this->value_.get ();
  }

  IntValue::ValueType& IntValue::
  getValue ()
  {
    return this->value_.get ();
  }

  void IntValue::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }


  // BooleanValue
  // 

  const BooleanValue::ValueType& BooleanValue::
  getValue () const
  {
    return this->value_.get ();
  }

  BooleanValue::ValueType& BooleanValue::
  getValue ()
  {
    return this->value_.get ();
  }

  void BooleanValue::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }


  // AgeGroupValues
  // 

  const AgeGroupValues::GroupSequence& AgeGroupValues::
  getGroup () const
  {
    return this->group_;
  }

  AgeGroupValues::GroupSequence& AgeGroupValues::
  getGroup ()
  {
    return this->group_;
  }

  void AgeGroupValues::
  setGroup (const GroupSequence& s)
  {
    this->group_ = s;
  }

  const AgeGroupValues::InterpolationOptional& AgeGroupValues::
  getInterpolation () const
  {
    return this->interpolation_;
  }

  AgeGroupValues::InterpolationOptional& AgeGroupValues::
  getInterpolation ()
  {
    return this->interpolation_;
  }

  void AgeGroupValues::
  setInterpolation (const InterpolationType& x)
  {
    this->interpolation_.set (x);
  }

  void AgeGroupValues::
  setInterpolation (const InterpolationOptional& x)
  {
    this->interpolation_ = x;
  }

  void AgeGroupValues::
  setInterpolation (::std::unique_ptr< InterpolationType > x)
  {
    this->interpolation_.set (std::move (x));
  }


  // Deploy
  // 

  const Deploy::ComponentSequence& Deploy::
  getComponent () const
  {
    return this->component_;
  }

  Deploy::ComponentSequence& Deploy::
  getComponent ()
  {
    return this->component_;
  }

  void Deploy::
  setComponent (const ComponentSequence& s)
  {
    this->component_ = s;
  }

  const Deploy::MaxAgeOptional& Deploy::
  getMaxAge () const
  {
    return this->maxAge_;
  }

  Deploy::MaxAgeOptional& Deploy::
  getMaxAge ()
  {
    return this->maxAge_;
  }

  void Deploy::
  setMaxAge (const MaxAgeType& x)
  {
    this->maxAge_.set (x);
  }

  void Deploy::
  setMaxAge (const MaxAgeOptional& x)
  {
    this->maxAge_ = x;
  }

  const Deploy::MinAgeType& Deploy::
  getMinAge () const
  {
    return this->minAge_.get ();
  }

  Deploy::MinAgeType& Deploy::
  getMinAge ()
  {
    return this->minAge_.get ();
  }

  void Deploy::
  setMinAge (const MinAgeType& x)
  {
    this->minAge_.set (x);
  }

  Deploy::MinAgeType Deploy::
  getMinAgeDefaultValue ()
  {
    return MinAgeType (0.0);
  }

  const Deploy::PType& Deploy::
  getP () const
  {
    return this->p_.get ();
  }

  Deploy::PType& Deploy::
  getP ()
  {
    return this->p_.get ();
  }

  void Deploy::
  setP (const PType& x)
  {
    this->p_.set (x);
  }

  Deploy::PType Deploy::
  getPDefaultValue ()
  {
    return PType (1.0);
  }


  // Function
  // 

  Function::
  Function (Value v)
  : ::xml_schema::String (_xsd_Function_literals_[v])
  {
  }

  Function::
  Function (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Function::
  Function (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Function::
  Function (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Function::
  Function (const Function& v,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Function& Function::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Function_literals_[v]);

    return *this;
  }


  // Distr
  // 

  Distr::
  Distr (Value v)
  : ::xml_schema::String (_xsd_Distr_literals_[v])
  {
  }

  Distr::
  Distr (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Distr::
  Distr (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Distr::
  Distr (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Distr::
  Distr (const Distr& v,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Distr& Distr::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Distr_literals_[v]);

    return *this;
  }


  // Group
  // 

  const Group::LowerboundType& Group::
  getLowerbound () const
  {
    return this->lowerbound_.get ();
  }

  Group::LowerboundType& Group::
  getLowerbound ()
  {
    return this->lowerbound_.get ();
  }

  void Group::
  setLowerbound (const LowerboundType& x)
  {
    this->lowerbound_.set (x);
  }


  // Interpolation
  // 

  Interpolation::
  Interpolation (Value v)
  : ::xml_schema::String (_xsd_Interpolation_literals_[v])
  {
  }

  Interpolation::
  Interpolation (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Interpolation::
  Interpolation (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Interpolation::
  Interpolation (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Interpolation::
  Interpolation (const Interpolation& v,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Interpolation& Interpolation::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Interpolation_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace scnXml
{
  // Component
  //

  Component::
  Component (const IdType& id)
  : ::xml_schema::Type (),
    id_ (id, this)
  {
  }

  Component::
  Component (const Component& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    id_ (x.id_, f, this)
  {
  }

  Component::
  Component (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    id_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Component::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (IdTraits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  Component* Component::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Component (*this, f, c);
  }

  Component& Component::
  operator= (const Component& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->id_ = x.id_;
    }

    return *this;
  }

  Component::
  ~Component ()
  {
  }

  // TriggeredDeployments
  //

  TriggeredDeployments::
  TriggeredDeployments ()
  : ::xml_schema::Type (),
    deploy_ (this)
  {
  }

  TriggeredDeployments::
  TriggeredDeployments (const TriggeredDeployments& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    deploy_ (x.deploy_, f, this)
  {
  }

  TriggeredDeployments::
  TriggeredDeployments (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    deploy_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TriggeredDeployments::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // deploy
      //
      if (n.name () == "deploy" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DeployType > r (
          DeployTraits::create (i, f, this));

        this->deploy_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  TriggeredDeployments* TriggeredDeployments::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TriggeredDeployments (*this, f, c);
  }

  TriggeredDeployments& TriggeredDeployments::
  operator= (const TriggeredDeployments& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->deploy_ = x.deploy_;
    }

    return *this;
  }

  TriggeredDeployments::
  ~TriggeredDeployments ()
  {
  }

  // OptionSet
  //

  OptionSet::
  OptionSet ()
  : ::xml_schema::Type (),
    option_ (this)
  {
  }

  OptionSet::
  OptionSet (const OptionSet& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    option_ (x.option_, f, this)
  {
  }

  OptionSet::
  OptionSet (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    option_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void OptionSet::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // option
      //
      if (n.name () == "option" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< OptionType > r (
          OptionTraits::create (i, f, this));

        this->option_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  OptionSet* OptionSet::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class OptionSet (*this, f, c);
  }

  OptionSet& OptionSet::
  operator= (const OptionSet& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->option_ = x.option_;
    }

    return *this;
  }

  OptionSet::
  ~OptionSet ()
  {
  }

  // Option
  //

  Option::
  Option (const NameType& name)
  : ::xml_schema::Type (),
    name_ (name, this),
    value_ (getValueDefaultValue (), this)
  {
  }

  Option::
  Option (const Option& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    value_ (x.value_, f, this)
  {
  }

  Option::
  Option (const xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Option::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!value_.present ())
    {
      this->value_.set (getValueDefaultValue ());
    }
  }

  Option* Option::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Option (*this, f, c);
  }

  Option& Option::
  operator= (const Option& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->value_ = x.value_;
    }

    return *this;
  }

  Option::
  ~Option ()
  {
  }

  // DoubleList
  //

  DoubleList::
  DoubleList ()
  : ::xml_schema::Type (),
    item_ (this)
  {
  }

  DoubleList::
  DoubleList (const DoubleList& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    item_ (x.item_, f, this)
  {
  }

  DoubleList::
  DoubleList (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    item_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void DoubleList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // item
      //
      if (n.name () == "item" && n.namespace_ ().empty ())
      {
        this->item_.push_back (ItemTraits::create (i, f, this));
        continue;
      }

      break;
    }
  }

  DoubleList* DoubleList::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DoubleList (*this, f, c);
  }

  DoubleList& DoubleList::
  operator= (const DoubleList& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->item_ = x.item_;
    }

    return *this;
  }

  DoubleList::
  ~DoubleList ()
  {
  }

  // DecayFunction
  //

  DecayFunction::
  DecayFunction (const FunctionType& function)
  : ::xml_schema::Type (),
    function_ (function, this),
    L_ (this),
    k_ (getKDefaultValue (), this),
    mu_ (getMuDefaultValue (), this),
    sigma_ (getSigmaDefaultValue (), this)
  {
  }

  DecayFunction::
  DecayFunction (const DecayFunction& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    function_ (x.function_, f, this),
    L_ (x.L_, f, this),
    k_ (x.k_, f, this),
    mu_ (x.mu_, f, this),
    sigma_ (x.sigma_, f, this)
  {
  }

  DecayFunction::
  DecayFunction (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    function_ (this),
    L_ (this),
    k_ (this),
    mu_ (this),
    sigma_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DecayFunction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "function" && n.namespace_ ().empty ())
      {
        this->function_.set (FunctionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "L" && n.namespace_ ().empty ())
      {
        this->L_.set (LTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "k" && n.namespace_ ().empty ())
      {
        this->k_.set (KTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "mu" && n.namespace_ ().empty ())
      {
        this->mu_.set (MuTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "sigma" && n.namespace_ ().empty ())
      {
        this->sigma_.set (SigmaTraits::create (i, f, this));
        continue;
      }
    }

    if (!function_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "function",
        "");
    }

    if (!k_.present ())
    {
      this->k_.set (getKDefaultValue ());
    }

    if (!mu_.present ())
    {
      this->mu_.set (getMuDefaultValue ());
    }

    if (!sigma_.present ())
    {
      this->sigma_.set (getSigmaDefaultValue ());
    }
  }

  DecayFunction* DecayFunction::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DecayFunction (*this, f, c);
  }

  DecayFunction& DecayFunction::
  operator= (const DecayFunction& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->function_ = x.function_;
      this->L_ = x.L_;
      this->k_ = x.k_;
      this->mu_ = x.mu_;
      this->sigma_ = x.sigma_;
    }

    return *this;
  }

  DecayFunction::
  ~DecayFunction ()
  {
  }

  // LognormalSample
  //

  LognormalSample::
  LognormalSample (const MeanType& mean,
                   const SigmaType& sigma)
  : ::xml_schema::Type (),
    mean_ (mean, this),
    sigma_ (sigma, this)
  {
  }

  LognormalSample::
  LognormalSample (const LognormalSample& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    mean_ (x.mean_, f, this),
    sigma_ (x.sigma_, f, this)
  {
  }

  LognormalSample::
  LognormalSample (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    mean_ (this),
    sigma_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void LognormalSample::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mean" && n.namespace_ ().empty ())
      {
        this->mean_.set (MeanTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "sigma" && n.namespace_ ().empty ())
      {
        this->sigma_.set (SigmaTraits::create (i, f, this));
        continue;
      }
    }

    if (!mean_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mean",
        "");
    }

    if (!sigma_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "sigma",
        "");
    }
  }

  LognormalSample* LognormalSample::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LognormalSample (*this, f, c);
  }

  LognormalSample& LognormalSample::
  operator= (const LognormalSample& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->mean_ = x.mean_;
      this->sigma_ = x.sigma_;
    }

    return *this;
  }

  LognormalSample::
  ~LognormalSample ()
  {
  }

  // NormalSample
  //

  NormalSample::
  NormalSample (const MuType& mu,
                const SigmaType& sigma)
  : ::xml_schema::Type (),
    mu_ (mu, this),
    sigma_ (sigma, this)
  {
  }

  NormalSample::
  NormalSample (const NormalSample& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    mu_ (x.mu_, f, this),
    sigma_ (x.sigma_, f, this)
  {
  }

  NormalSample::
  NormalSample (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    mu_ (this),
    sigma_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void NormalSample::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mu" && n.namespace_ ().empty ())
      {
        this->mu_.set (MuTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "sigma" && n.namespace_ ().empty ())
      {
        this->sigma_.set (SigmaTraits::create (i, f, this));
        continue;
      }
    }

    if (!mu_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mu",
        "");
    }

    if (!sigma_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "sigma",
        "");
    }
  }

  NormalSample* NormalSample::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NormalSample (*this, f, c);
  }

  NormalSample& NormalSample::
  operator= (const NormalSample& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->mu_ = x.mu_;
      this->sigma_ = x.sigma_;
    }

    return *this;
  }

  NormalSample::
  ~NormalSample ()
  {
  }

  // BetaMeanSample
  //

  BetaMeanSample::
  BetaMeanSample (const MeanType& mean,
                  const VarianceType& variance)
  : ::xml_schema::Type (),
    mean_ (mean, this),
    variance_ (variance, this)
  {
  }

  BetaMeanSample::
  BetaMeanSample (const BetaMeanSample& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    mean_ (x.mean_, f, this),
    variance_ (x.variance_, f, this)
  {
  }

  BetaMeanSample::
  BetaMeanSample (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    mean_ (this),
    variance_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void BetaMeanSample::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mean" && n.namespace_ ().empty ())
      {
        this->mean_.set (MeanTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "variance" && n.namespace_ ().empty ())
      {
        this->variance_.set (VarianceTraits::create (i, f, this));
        continue;
      }
    }

    if (!mean_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mean",
        "");
    }

    if (!variance_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "variance",
        "");
    }
  }

  BetaMeanSample* BetaMeanSample::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BetaMeanSample (*this, f, c);
  }

  BetaMeanSample& BetaMeanSample::
  operator= (const BetaMeanSample& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->mean_ = x.mean_;
      this->variance_ = x.variance_;
    }

    return *this;
  }

  BetaMeanSample::
  ~BetaMeanSample ()
  {
  }

  // SampledValue
  //

  SampledValue::
  SampledValue (const MeanType& mean,
                const DistrType& distr)
  : ::xml_schema::Type (),
    mean_ (mean, this),
    cv_ (this),
    distr_ (distr, this)
  {
  }

  SampledValue::
  SampledValue (const SampledValue& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    mean_ (x.mean_, f, this),
    cv_ (x.cv_, f, this),
    distr_ (x.distr_, f, this)
  {
  }

  SampledValue::
  SampledValue (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    mean_ (this),
    cv_ (this),
    distr_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SampledValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mean" && n.namespace_ ().empty ())
      {
        this->mean_.set (MeanTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "cv" && n.namespace_ ().empty ())
      {
        this->cv_.set (CvTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "distr" && n.namespace_ ().empty ())
      {
        this->distr_.set (DistrTraits::create (i, f, this));
        continue;
      }
    }

    if (!mean_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mean",
        "");
    }

    if (!distr_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "distr",
        "");
    }
  }

  SampledValue* SampledValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SampledValue (*this, f, c);
  }

  SampledValue& SampledValue::
  operator= (const SampledValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->mean_ = x.mean_;
      this->cv_ = x.cv_;
      this->distr_ = x.distr_;
    }

    return *this;
  }

  SampledValue::
  ~SampledValue ()
  {
  }

  // DoubleValue
  //

  DoubleValue::
  DoubleValue (const ValueType& value)
  : ::xml_schema::Type (),
    value_ (value, this)
  {
  }

  DoubleValue::
  DoubleValue (const DoubleValue& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  DoubleValue::
  DoubleValue (const xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DoubleValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  DoubleValue* DoubleValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DoubleValue (*this, f, c);
  }

  DoubleValue& DoubleValue::
  operator= (const DoubleValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  DoubleValue::
  ~DoubleValue ()
  {
  }

  // IntValue
  //

  IntValue::
  IntValue (const ValueType& value)
  : ::xml_schema::Type (),
    value_ (value, this)
  {
  }

  IntValue::
  IntValue (const IntValue& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  IntValue::
  IntValue (const xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void IntValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  IntValue* IntValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IntValue (*this, f, c);
  }

  IntValue& IntValue::
  operator= (const IntValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  IntValue::
  ~IntValue ()
  {
  }

  // BooleanValue
  //

  BooleanValue::
  BooleanValue (const ValueType& value)
  : ::xml_schema::Type (),
    value_ (value, this)
  {
  }

  BooleanValue::
  BooleanValue (const BooleanValue& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    value_ (x.value_, f, this)
  {
  }

  BooleanValue::
  BooleanValue (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    value_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void BooleanValue::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (ValueTraits::create (i, f, this));
        continue;
      }
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  BooleanValue* BooleanValue::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BooleanValue (*this, f, c);
  }

  BooleanValue& BooleanValue::
  operator= (const BooleanValue& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->value_ = x.value_;
    }

    return *this;
  }

  BooleanValue::
  ~BooleanValue ()
  {
  }

  // AgeGroupValues
  //

  AgeGroupValues::
  AgeGroupValues ()
  : ::xml_schema::Type (),
    group_ (this),
    interpolation_ (this)
  {
  }

  AgeGroupValues::
  AgeGroupValues (const AgeGroupValues& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    group_ (x.group_, f, this),
    interpolation_ (x.interpolation_, f, this)
  {
  }

  AgeGroupValues::
  AgeGroupValues (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    group_ (this),
    interpolation_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AgeGroupValues::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // group
      //
      if (n.name () == "group" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< GroupType > r (
          GroupTraits::create (i, f, this));

        this->group_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "interpolation" && n.namespace_ ().empty ())
      {
        this->interpolation_.set (InterpolationTraits::create (i, f, this));
        continue;
      }
    }
  }

  AgeGroupValues* AgeGroupValues::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AgeGroupValues (*this, f, c);
  }

  AgeGroupValues& AgeGroupValues::
  operator= (const AgeGroupValues& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->group_ = x.group_;
      this->interpolation_ = x.interpolation_;
    }

    return *this;
  }

  AgeGroupValues::
  ~AgeGroupValues ()
  {
  }

  // Deploy
  //

  Deploy::
  Deploy ()
  : ::xml_schema::Type (),
    component_ (this),
    maxAge_ (this),
    minAge_ (getMinAgeDefaultValue (), this),
    p_ (getPDefaultValue (), this)
  {
  }

  Deploy::
  Deploy (const Deploy& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    component_ (x.component_, f, this),
    maxAge_ (x.maxAge_, f, this),
    minAge_ (x.minAge_, f, this),
    p_ (x.p_, f, this)
  {
  }

  Deploy::
  Deploy (const xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    component_ (this),
    maxAge_ (this),
    minAge_ (this),
    p_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Deploy::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // component
      //
      if (n.name () == "component" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ComponentType > r (
          ComponentTraits::create (i, f, this));

        this->component_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "maxAge" && n.namespace_ ().empty ())
      {
        this->maxAge_.set (MaxAgeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "minAge" && n.namespace_ ().empty ())
      {
        this->minAge_.set (MinAgeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "p" && n.namespace_ ().empty ())
      {
        this->p_.set (PTraits::create (i, f, this));
        continue;
      }
    }

    if (!minAge_.present ())
    {
      this->minAge_.set (getMinAgeDefaultValue ());
    }

    if (!p_.present ())
    {
      this->p_.set (getPDefaultValue ());
    }
  }

  Deploy* Deploy::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Deploy (*this, f, c);
  }

  Deploy& Deploy::
  operator= (const Deploy& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->component_ = x.component_;
      this->maxAge_ = x.maxAge_;
      this->minAge_ = x.minAge_;
      this->p_ = x.p_;
    }

    return *this;
  }

  Deploy::
  ~Deploy ()
  {
  }

  // Function
  //

  Function::
  Function (const xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Function_convert ();
  }

  Function::
  Function (const xercesc::DOMAttr& a,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Function_convert ();
  }

  Function::
  Function (const ::std::string& s,
            const xercesc::DOMElement* e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Function_convert ();
  }

  Function* Function::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Function (*this, f, c);
  }

  Function::Value Function::
  _xsd_Function_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Function_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Function_indexes_,
                      _xsd_Function_indexes_ + 7,
                      *this,
                      c));

    if (i == _xsd_Function_indexes_ + 7 || _xsd_Function_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Function::
  _xsd_Function_literals_[7] =
  {
    "constant",
    "step",
    "linear",
    "exponential",
    "weibull",
    "hill",
    "smooth-compact"
  };

  const Function::Value Function::
  _xsd_Function_indexes_[7] =
  {
    ::scnXml::Function::constant,
    ::scnXml::Function::exponential,
    ::scnXml::Function::hill,
    ::scnXml::Function::linear,
    ::scnXml::Function::smooth_compact,
    ::scnXml::Function::step,
    ::scnXml::Function::weibull
  };

  // Distr
  //

  Distr::
  Distr (const xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Distr_convert ();
  }

  Distr::
  Distr (const xercesc::DOMAttr& a,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Distr_convert ();
  }

  Distr::
  Distr (const ::std::string& s,
         const xercesc::DOMElement* e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Distr_convert ();
  }

  Distr* Distr::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Distr (*this, f, c);
  }

  Distr::Value Distr::
  _xsd_Distr_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Distr_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Distr_indexes_,
                      _xsd_Distr_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_Distr_indexes_ + 2 || _xsd_Distr_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Distr::
  _xsd_Distr_literals_[2] =
  {
    "lnorm",
    "const"
  };

  const Distr::Value Distr::
  _xsd_Distr_indexes_[2] =
  {
    ::scnXml::Distr::const_,
    ::scnXml::Distr::lnorm
  };

  // Group
  //

  Group::
  Group (const ValueType& value,
         const LowerboundType& lowerbound)
  : ::scnXml::DoubleValue (value),
    lowerbound_ (lowerbound, this)
  {
  }

  Group::
  Group (const Group& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::scnXml::DoubleValue (x, f, c),
    lowerbound_ (x.lowerbound_, f, this)
  {
  }

  Group::
  Group (const xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::scnXml::DoubleValue (e, f | ::xml_schema::Flags::base, c),
    lowerbound_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Group::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::DoubleValue::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lowerbound" && n.namespace_ ().empty ())
      {
        this->lowerbound_.set (LowerboundTraits::create (i, f, this));
        continue;
      }
    }

    if (!lowerbound_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lowerbound",
        "");
    }
  }

  Group* Group::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Group (*this, f, c);
  }

  Group& Group::
  operator= (const Group& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::DoubleValue& > (*this) = x;
      this->lowerbound_ = x.lowerbound_;
    }

    return *this;
  }

  Group::
  ~Group ()
  {
  }

  // Interpolation
  //

  Interpolation::
  Interpolation (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Interpolation_convert ();
  }

  Interpolation::
  Interpolation (const xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Interpolation_convert ();
  }

  Interpolation::
  Interpolation (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Interpolation_convert ();
  }

  Interpolation* Interpolation::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Interpolation (*this, f, c);
  }

  Interpolation::Value Interpolation::
  _xsd_Interpolation_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Interpolation_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Interpolation_indexes_,
                      _xsd_Interpolation_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_Interpolation_indexes_ + 2 || _xsd_Interpolation_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Interpolation::
  _xsd_Interpolation_literals_[2] =
  {
    "none",
    "linear"
  };

  const Interpolation::Value Interpolation::
  _xsd_Interpolation_indexes_[2] =
  {
    ::scnXml::Interpolation::linear,
    ::scnXml::Interpolation::none
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace scnXml
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


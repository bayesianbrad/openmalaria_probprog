// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "demography.h"

namespace scnXml
{
  // Demography
  // 

  const Demography::AgeGroupType& Demography::
  getAgeGroup () const
  {
    return this->ageGroup_.get ();
  }

  Demography::AgeGroupType& Demography::
  getAgeGroup ()
  {
    return this->ageGroup_.get ();
  }

  void Demography::
  setAgeGroup (const AgeGroupType& x)
  {
    this->ageGroup_.set (x);
  }

  void Demography::
  setAgeGroup (::std::unique_ptr< AgeGroupType > x)
  {
    this->ageGroup_.set (std::move (x));
  }

  const Demography::NameType& Demography::
  getName () const
  {
    return this->name_.get ();
  }

  Demography::NameType& Demography::
  getName ()
  {
    return this->name_.get ();
  }

  void Demography::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Demography::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const Demography::PopSizeType& Demography::
  getPopSize () const
  {
    return this->popSize_.get ();
  }

  Demography::PopSizeType& Demography::
  getPopSize ()
  {
    return this->popSize_.get ();
  }

  void Demography::
  setPopSize (const PopSizeType& x)
  {
    this->popSize_.set (x);
  }

  const Demography::MaximumAgeYrsType& Demography::
  getMaximumAgeYrs () const
  {
    return this->maximumAgeYrs_.get ();
  }

  Demography::MaximumAgeYrsType& Demography::
  getMaximumAgeYrs ()
  {
    return this->maximumAgeYrs_.get ();
  }

  void Demography::
  setMaximumAgeYrs (const MaximumAgeYrsType& x)
  {
    this->maximumAgeYrs_.set (x);
  }

  const Demography::GrowthRateOptional& Demography::
  getGrowthRate () const
  {
    return this->growthRate_;
  }

  Demography::GrowthRateOptional& Demography::
  getGrowthRate ()
  {
    return this->growthRate_;
  }

  void Demography::
  setGrowthRate (const GrowthRateType& x)
  {
    this->growthRate_.set (x);
  }

  void Demography::
  setGrowthRate (const GrowthRateOptional& x)
  {
    this->growthRate_ = x;
  }


  // DemogAgeGroup
  // 

  const DemogAgeGroup::GroupSequence& DemogAgeGroup::
  getGroup () const
  {
    return this->group_;
  }

  DemogAgeGroup::GroupSequence& DemogAgeGroup::
  getGroup ()
  {
    return this->group_;
  }

  void DemogAgeGroup::
  setGroup (const GroupSequence& s)
  {
    this->group_ = s;
  }

  const DemogAgeGroup::LowerboundType& DemogAgeGroup::
  getLowerbound () const
  {
    return this->lowerbound_.get ();
  }

  DemogAgeGroup::LowerboundType& DemogAgeGroup::
  getLowerbound ()
  {
    return this->lowerbound_.get ();
  }

  void DemogAgeGroup::
  setLowerbound (const LowerboundType& x)
  {
    this->lowerbound_.set (x);
  }


  // DemogGroupBounds
  // 

  const DemogGroupBounds::PoppercentType& DemogGroupBounds::
  getPoppercent () const
  {
    return this->poppercent_.get ();
  }

  DemogGroupBounds::PoppercentType& DemogGroupBounds::
  getPoppercent ()
  {
    return this->poppercent_.get ();
  }

  void DemogGroupBounds::
  setPoppercent (const PoppercentType& x)
  {
    this->poppercent_.set (x);
  }

  const DemogGroupBounds::UpperboundType& DemogGroupBounds::
  getUpperbound () const
  {
    return this->upperbound_.get ();
  }

  DemogGroupBounds::UpperboundType& DemogGroupBounds::
  getUpperbound ()
  {
    return this->upperbound_.get ();
  }

  void DemogGroupBounds::
  setUpperbound (const UpperboundType& x)
  {
    this->upperbound_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace scnXml
{
  // Demography
  //

  Demography::
  Demography (const AgeGroupType& ageGroup,
              const NameType& name,
              const PopSizeType& popSize,
              const MaximumAgeYrsType& maximumAgeYrs)
  : ::xml_schema::Type (),
    ageGroup_ (ageGroup, this),
    name_ (name, this),
    popSize_ (popSize, this),
    maximumAgeYrs_ (maximumAgeYrs, this),
    growthRate_ (this)
  {
  }

  Demography::
  Demography (::std::unique_ptr< AgeGroupType > ageGroup,
              const NameType& name,
              const PopSizeType& popSize,
              const MaximumAgeYrsType& maximumAgeYrs)
  : ::xml_schema::Type (),
    ageGroup_ (std::move (ageGroup), this),
    name_ (name, this),
    popSize_ (popSize, this),
    maximumAgeYrs_ (maximumAgeYrs, this),
    growthRate_ (this)
  {
  }

  Demography::
  Demography (const Demography& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ageGroup_ (x.ageGroup_, f, this),
    name_ (x.name_, f, this),
    popSize_ (x.popSize_, f, this),
    maximumAgeYrs_ (x.maximumAgeYrs_, f, this),
    growthRate_ (x.growthRate_, f, this)
  {
  }

  Demography::
  Demography (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ageGroup_ (this),
    name_ (this),
    popSize_ (this),
    maximumAgeYrs_ (this),
    growthRate_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Demography::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ageGroup
      //
      if (n.name () == "ageGroup" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AgeGroupType > r (
          AgeGroupTraits::create (i, f, this));

        if (!ageGroup_.present ())
        {
          this->ageGroup_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!ageGroup_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ageGroup",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "popSize" && n.namespace_ ().empty ())
      {
        this->popSize_.set (PopSizeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "maximumAgeYrs" && n.namespace_ ().empty ())
      {
        this->maximumAgeYrs_.set (MaximumAgeYrsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "growthRate" && n.namespace_ ().empty ())
      {
        this->growthRate_.set (GrowthRateTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!popSize_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "popSize",
        "");
    }

    if (!maximumAgeYrs_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "maximumAgeYrs",
        "");
    }
  }

  Demography* Demography::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Demography (*this, f, c);
  }

  Demography& Demography::
  operator= (const Demography& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->ageGroup_ = x.ageGroup_;
      this->name_ = x.name_;
      this->popSize_ = x.popSize_;
      this->maximumAgeYrs_ = x.maximumAgeYrs_;
      this->growthRate_ = x.growthRate_;
    }

    return *this;
  }

  Demography::
  ~Demography ()
  {
  }

  // DemogAgeGroup
  //

  DemogAgeGroup::
  DemogAgeGroup (const LowerboundType& lowerbound)
  : ::xml_schema::Type (),
    group_ (this),
    lowerbound_ (lowerbound, this)
  {
  }

  DemogAgeGroup::
  DemogAgeGroup (const DemogAgeGroup& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    group_ (x.group_, f, this),
    lowerbound_ (x.lowerbound_, f, this)
  {
  }

  DemogAgeGroup::
  DemogAgeGroup (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    group_ (this),
    lowerbound_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DemogAgeGroup::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // group
      //
      if (n.name () == "group" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< GroupType > r (
          GroupTraits::create (i, f, this));

        this->group_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lowerbound" && n.namespace_ ().empty ())
      {
        this->lowerbound_.set (LowerboundTraits::create (i, f, this));
        continue;
      }
    }

    if (!lowerbound_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lowerbound",
        "");
    }
  }

  DemogAgeGroup* DemogAgeGroup::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DemogAgeGroup (*this, f, c);
  }

  DemogAgeGroup& DemogAgeGroup::
  operator= (const DemogAgeGroup& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->group_ = x.group_;
      this->lowerbound_ = x.lowerbound_;
    }

    return *this;
  }

  DemogAgeGroup::
  ~DemogAgeGroup ()
  {
  }

  // DemogGroupBounds
  //

  DemogGroupBounds::
  DemogGroupBounds (const PoppercentType& poppercent,
                    const UpperboundType& upperbound)
  : ::xml_schema::Type (),
    poppercent_ (poppercent, this),
    upperbound_ (upperbound, this)
  {
  }

  DemogGroupBounds::
  DemogGroupBounds (const DemogGroupBounds& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    poppercent_ (x.poppercent_, f, this),
    upperbound_ (x.upperbound_, f, this)
  {
  }

  DemogGroupBounds::
  DemogGroupBounds (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    poppercent_ (this),
    upperbound_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DemogGroupBounds::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "poppercent" && n.namespace_ ().empty ())
      {
        this->poppercent_.set (PoppercentTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "upperbound" && n.namespace_ ().empty ())
      {
        this->upperbound_.set (UpperboundTraits::create (i, f, this));
        continue;
      }
    }

    if (!poppercent_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "poppercent",
        "");
    }

    if (!upperbound_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "upperbound",
        "");
    }
  }

  DemogGroupBounds* DemogGroupBounds::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DemogGroupBounds (*this, f, c);
  }

  DemogGroupBounds& DemogGroupBounds::
  operator= (const DemogGroupBounds& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->poppercent_ = x.poppercent_;
      this->upperbound_ = x.upperbound_;
    }

    return *this;
  }

  DemogGroupBounds::
  ~DemogGroupBounds ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace scnXml
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


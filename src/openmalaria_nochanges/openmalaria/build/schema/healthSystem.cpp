// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "healthSystem.h"

namespace scnXml
{
  // Clinical
  // 

  const Clinical::NeonatalMortalityOptional& Clinical::
  getNeonatalMortality () const
  {
    return this->NeonatalMortality_;
  }

  Clinical::NeonatalMortalityOptional& Clinical::
  getNeonatalMortality ()
  {
    return this->NeonatalMortality_;
  }

  void Clinical::
  setNeonatalMortality (const NeonatalMortalityType& x)
  {
    this->NeonatalMortality_.set (x);
  }

  void Clinical::
  setNeonatalMortality (const NeonatalMortalityOptional& x)
  {
    this->NeonatalMortality_ = x;
  }

  void Clinical::
  setNeonatalMortality (::std::unique_ptr< NeonatalMortalityType > x)
  {
    this->NeonatalMortality_.set (std::move (x));
  }

  const Clinical::NonMalariaFeversOptional& Clinical::
  getNonMalariaFevers () const
  {
    return this->NonMalariaFevers_;
  }

  Clinical::NonMalariaFeversOptional& Clinical::
  getNonMalariaFevers ()
  {
    return this->NonMalariaFevers_;
  }

  void Clinical::
  setNonMalariaFevers (const NonMalariaFeversType& x)
  {
    this->NonMalariaFevers_.set (x);
  }

  void Clinical::
  setNonMalariaFevers (const NonMalariaFeversOptional& x)
  {
    this->NonMalariaFevers_ = x;
  }

  void Clinical::
  setNonMalariaFevers (::std::unique_ptr< NonMalariaFeversType > x)
  {
    this->NonMalariaFevers_.set (std::move (x));
  }

  const Clinical::HealthSystemMemoryType& Clinical::
  getHealthSystemMemory () const
  {
    return this->healthSystemMemory_.get ();
  }

  Clinical::HealthSystemMemoryType& Clinical::
  getHealthSystemMemory ()
  {
    return this->healthSystemMemory_.get ();
  }

  void Clinical::
  setHealthSystemMemory (const HealthSystemMemoryType& x)
  {
    this->healthSystemMemory_.set (x);
  }

  void Clinical::
  setHealthSystemMemory (::std::unique_ptr< HealthSystemMemoryType > x)
  {
    this->healthSystemMemory_.set (std::move (x));
  }


  // HealthSystem
  // 

  const HealthSystem::EventSchedulerOptional& HealthSystem::
  getEventScheduler () const
  {
    return this->EventScheduler_;
  }

  HealthSystem::EventSchedulerOptional& HealthSystem::
  getEventScheduler ()
  {
    return this->EventScheduler_;
  }

  void HealthSystem::
  setEventScheduler (const EventSchedulerType& x)
  {
    this->EventScheduler_.set (x);
  }

  void HealthSystem::
  setEventScheduler (const EventSchedulerOptional& x)
  {
    this->EventScheduler_ = x;
  }

  void HealthSystem::
  setEventScheduler (::std::unique_ptr< EventSchedulerType > x)
  {
    this->EventScheduler_.set (std::move (x));
  }

  const HealthSystem::ImmediateOutcomesOptional& HealthSystem::
  getImmediateOutcomes () const
  {
    return this->ImmediateOutcomes_;
  }

  HealthSystem::ImmediateOutcomesOptional& HealthSystem::
  getImmediateOutcomes ()
  {
    return this->ImmediateOutcomes_;
  }

  void HealthSystem::
  setImmediateOutcomes (const ImmediateOutcomesType& x)
  {
    this->ImmediateOutcomes_.set (x);
  }

  void HealthSystem::
  setImmediateOutcomes (const ImmediateOutcomesOptional& x)
  {
    this->ImmediateOutcomes_ = x;
  }

  void HealthSystem::
  setImmediateOutcomes (::std::unique_ptr< ImmediateOutcomesType > x)
  {
    this->ImmediateOutcomes_.set (std::move (x));
  }

  const HealthSystem::DecisionTree5DayOptional& HealthSystem::
  getDecisionTree5Day () const
  {
    return this->DecisionTree5Day_;
  }

  HealthSystem::DecisionTree5DayOptional& HealthSystem::
  getDecisionTree5Day ()
  {
    return this->DecisionTree5Day_;
  }

  void HealthSystem::
  setDecisionTree5Day (const DecisionTree5DayType& x)
  {
    this->DecisionTree5Day_.set (x);
  }

  void HealthSystem::
  setDecisionTree5Day (const DecisionTree5DayOptional& x)
  {
    this->DecisionTree5Day_ = x;
  }

  void HealthSystem::
  setDecisionTree5Day (::std::unique_ptr< DecisionTree5DayType > x)
  {
    this->DecisionTree5Day_.set (std::move (x));
  }

  const HealthSystem::CFRType& HealthSystem::
  getCFR () const
  {
    return this->CFR_.get ();
  }

  HealthSystem::CFRType& HealthSystem::
  getCFR ()
  {
    return this->CFR_.get ();
  }

  void HealthSystem::
  setCFR (const CFRType& x)
  {
    this->CFR_.set (x);
  }

  void HealthSystem::
  setCFR (::std::unique_ptr< CFRType > x)
  {
    this->CFR_.set (std::move (x));
  }

  const HealthSystem::PSequelaeInpatientType& HealthSystem::
  getPSequelaeInpatient () const
  {
    return this->pSequelaeInpatient_.get ();
  }

  HealthSystem::PSequelaeInpatientType& HealthSystem::
  getPSequelaeInpatient ()
  {
    return this->pSequelaeInpatient_.get ();
  }

  void HealthSystem::
  setPSequelaeInpatient (const PSequelaeInpatientType& x)
  {
    this->pSequelaeInpatient_.set (x);
  }

  void HealthSystem::
  setPSequelaeInpatient (::std::unique_ptr< PSequelaeInpatientType > x)
  {
    this->pSequelaeInpatient_.set (std::move (x));
  }


  // LiverStageDrug
  // 

  const LiverStageDrug::PHumanCannotReceiveType& LiverStageDrug::
  getPHumanCannotReceive () const
  {
    return this->pHumanCannotReceive_.get ();
  }

  LiverStageDrug::PHumanCannotReceiveType& LiverStageDrug::
  getPHumanCannotReceive ()
  {
    return this->pHumanCannotReceive_.get ();
  }

  void LiverStageDrug::
  setPHumanCannotReceive (const PHumanCannotReceiveType& x)
  {
    this->pHumanCannotReceive_.set (x);
  }

  void LiverStageDrug::
  setPHumanCannotReceive (::std::unique_ptr< PHumanCannotReceiveType > x)
  {
    this->pHumanCannotReceive_.set (std::move (x));
  }

  const LiverStageDrug::IgnoreCannotReceiveOptional& LiverStageDrug::
  getIgnoreCannotReceive () const
  {
    return this->ignoreCannotReceive_;
  }

  LiverStageDrug::IgnoreCannotReceiveOptional& LiverStageDrug::
  getIgnoreCannotReceive ()
  {
    return this->ignoreCannotReceive_;
  }

  void LiverStageDrug::
  setIgnoreCannotReceive (const IgnoreCannotReceiveType& x)
  {
    this->ignoreCannotReceive_.set (x);
  }

  void LiverStageDrug::
  setIgnoreCannotReceive (const IgnoreCannotReceiveOptional& x)
  {
    this->ignoreCannotReceive_ = x;
  }

  void LiverStageDrug::
  setIgnoreCannotReceive (::std::unique_ptr< IgnoreCannotReceiveType > x)
  {
    this->ignoreCannotReceive_.set (std::move (x));
  }

  const LiverStageDrug::PUseUncomplicatedOptional& LiverStageDrug::
  getPUseUncomplicated () const
  {
    return this->pUseUncomplicated_;
  }

  LiverStageDrug::PUseUncomplicatedOptional& LiverStageDrug::
  getPUseUncomplicated ()
  {
    return this->pUseUncomplicated_;
  }

  void LiverStageDrug::
  setPUseUncomplicated (const PUseUncomplicatedType& x)
  {
    this->pUseUncomplicated_.set (x);
  }

  void LiverStageDrug::
  setPUseUncomplicated (const PUseUncomplicatedOptional& x)
  {
    this->pUseUncomplicated_ = x;
  }

  void LiverStageDrug::
  setPUseUncomplicated (::std::unique_ptr< PUseUncomplicatedType > x)
  {
    this->pUseUncomplicated_.set (std::move (x));
  }

  const LiverStageDrug::EffectivenessOnUseType& LiverStageDrug::
  getEffectivenessOnUse () const
  {
    return this->effectivenessOnUse_.get ();
  }

  LiverStageDrug::EffectivenessOnUseType& LiverStageDrug::
  getEffectivenessOnUse ()
  {
    return this->effectivenessOnUse_.get ();
  }

  void LiverStageDrug::
  setEffectivenessOnUse (const EffectivenessOnUseType& x)
  {
    this->effectivenessOnUse_.set (x);
  }

  void LiverStageDrug::
  setEffectivenessOnUse (::std::unique_ptr< EffectivenessOnUseType > x)
  {
    this->effectivenessOnUse_.set (std::move (x));
  }


  // HSImmediateOutcomes
  // 

  const HSImmediateOutcomes::DrugRegimenType& HSImmediateOutcomes::
  getDrugRegimen () const
  {
    return this->drugRegimen_.get ();
  }

  HSImmediateOutcomes::DrugRegimenType& HSImmediateOutcomes::
  getDrugRegimen ()
  {
    return this->drugRegimen_.get ();
  }

  void HSImmediateOutcomes::
  setDrugRegimen (const DrugRegimenType& x)
  {
    this->drugRegimen_.set (x);
  }

  void HSImmediateOutcomes::
  setDrugRegimen (::std::unique_ptr< DrugRegimenType > x)
  {
    this->drugRegimen_.set (std::move (x));
  }

  const HSImmediateOutcomes::InitialACRType& HSImmediateOutcomes::
  getInitialACR () const
  {
    return this->initialACR_.get ();
  }

  HSImmediateOutcomes::InitialACRType& HSImmediateOutcomes::
  getInitialACR ()
  {
    return this->initialACR_.get ();
  }

  void HSImmediateOutcomes::
  setInitialACR (const InitialACRType& x)
  {
    this->initialACR_.set (x);
  }

  void HSImmediateOutcomes::
  setInitialACR (::std::unique_ptr< InitialACRType > x)
  {
    this->initialACR_.set (std::move (x));
  }

  const HSImmediateOutcomes::ComplianceType& HSImmediateOutcomes::
  getCompliance () const
  {
    return this->compliance_.get ();
  }

  HSImmediateOutcomes::ComplianceType& HSImmediateOutcomes::
  getCompliance ()
  {
    return this->compliance_.get ();
  }

  void HSImmediateOutcomes::
  setCompliance (const ComplianceType& x)
  {
    this->compliance_.set (x);
  }

  void HSImmediateOutcomes::
  setCompliance (::std::unique_ptr< ComplianceType > x)
  {
    this->compliance_.set (std::move (x));
  }

  const HSImmediateOutcomes::NonCompliersEffectiveType& HSImmediateOutcomes::
  getNonCompliersEffective () const
  {
    return this->nonCompliersEffective_.get ();
  }

  HSImmediateOutcomes::NonCompliersEffectiveType& HSImmediateOutcomes::
  getNonCompliersEffective ()
  {
    return this->nonCompliersEffective_.get ();
  }

  void HSImmediateOutcomes::
  setNonCompliersEffective (const NonCompliersEffectiveType& x)
  {
    this->nonCompliersEffective_.set (x);
  }

  void HSImmediateOutcomes::
  setNonCompliersEffective (::std::unique_ptr< NonCompliersEffectiveType > x)
  {
    this->nonCompliersEffective_.set (std::move (x));
  }

  const HSImmediateOutcomes::TreatmentActionsType& HSImmediateOutcomes::
  getTreatmentActions () const
  {
    return this->treatmentActions_.get ();
  }

  HSImmediateOutcomes::TreatmentActionsType& HSImmediateOutcomes::
  getTreatmentActions ()
  {
    return this->treatmentActions_.get ();
  }

  void HSImmediateOutcomes::
  setTreatmentActions (const TreatmentActionsType& x)
  {
    this->treatmentActions_.set (x);
  }

  void HSImmediateOutcomes::
  setTreatmentActions (::std::unique_ptr< TreatmentActionsType > x)
  {
    this->treatmentActions_.set (std::move (x));
  }

  const HSImmediateOutcomes::PSeekOfficialCareUncomplicated1Type& HSImmediateOutcomes::
  getPSeekOfficialCareUncomplicated1 () const
  {
    return this->pSeekOfficialCareUncomplicated1_.get ();
  }

  HSImmediateOutcomes::PSeekOfficialCareUncomplicated1Type& HSImmediateOutcomes::
  getPSeekOfficialCareUncomplicated1 ()
  {
    return this->pSeekOfficialCareUncomplicated1_.get ();
  }

  void HSImmediateOutcomes::
  setPSeekOfficialCareUncomplicated1 (const PSeekOfficialCareUncomplicated1Type& x)
  {
    this->pSeekOfficialCareUncomplicated1_.set (x);
  }

  void HSImmediateOutcomes::
  setPSeekOfficialCareUncomplicated1 (::std::unique_ptr< PSeekOfficialCareUncomplicated1Type > x)
  {
    this->pSeekOfficialCareUncomplicated1_.set (std::move (x));
  }

  const HSImmediateOutcomes::PSelfTreatUncomplicatedType& HSImmediateOutcomes::
  getPSelfTreatUncomplicated () const
  {
    return this->pSelfTreatUncomplicated_.get ();
  }

  HSImmediateOutcomes::PSelfTreatUncomplicatedType& HSImmediateOutcomes::
  getPSelfTreatUncomplicated ()
  {
    return this->pSelfTreatUncomplicated_.get ();
  }

  void HSImmediateOutcomes::
  setPSelfTreatUncomplicated (const PSelfTreatUncomplicatedType& x)
  {
    this->pSelfTreatUncomplicated_.set (x);
  }

  void HSImmediateOutcomes::
  setPSelfTreatUncomplicated (::std::unique_ptr< PSelfTreatUncomplicatedType > x)
  {
    this->pSelfTreatUncomplicated_.set (std::move (x));
  }

  const HSImmediateOutcomes::PSeekOfficialCareUncomplicated2Type& HSImmediateOutcomes::
  getPSeekOfficialCareUncomplicated2 () const
  {
    return this->pSeekOfficialCareUncomplicated2_.get ();
  }

  HSImmediateOutcomes::PSeekOfficialCareUncomplicated2Type& HSImmediateOutcomes::
  getPSeekOfficialCareUncomplicated2 ()
  {
    return this->pSeekOfficialCareUncomplicated2_.get ();
  }

  void HSImmediateOutcomes::
  setPSeekOfficialCareUncomplicated2 (const PSeekOfficialCareUncomplicated2Type& x)
  {
    this->pSeekOfficialCareUncomplicated2_.set (x);
  }

  void HSImmediateOutcomes::
  setPSeekOfficialCareUncomplicated2 (::std::unique_ptr< PSeekOfficialCareUncomplicated2Type > x)
  {
    this->pSeekOfficialCareUncomplicated2_.set (std::move (x));
  }

  const HSImmediateOutcomes::PSeekOfficialCareSevereType& HSImmediateOutcomes::
  getPSeekOfficialCareSevere () const
  {
    return this->pSeekOfficialCareSevere_.get ();
  }

  HSImmediateOutcomes::PSeekOfficialCareSevereType& HSImmediateOutcomes::
  getPSeekOfficialCareSevere ()
  {
    return this->pSeekOfficialCareSevere_.get ();
  }

  void HSImmediateOutcomes::
  setPSeekOfficialCareSevere (const PSeekOfficialCareSevereType& x)
  {
    this->pSeekOfficialCareSevere_.set (x);
  }

  void HSImmediateOutcomes::
  setPSeekOfficialCareSevere (::std::unique_ptr< PSeekOfficialCareSevereType > x)
  {
    this->pSeekOfficialCareSevere_.set (std::move (x));
  }

  const HSImmediateOutcomes::LiverStageDrugOptional& HSImmediateOutcomes::
  getLiverStageDrug () const
  {
    return this->liverStageDrug_;
  }

  HSImmediateOutcomes::LiverStageDrugOptional& HSImmediateOutcomes::
  getLiverStageDrug ()
  {
    return this->liverStageDrug_;
  }

  void HSImmediateOutcomes::
  setLiverStageDrug (const LiverStageDrugType& x)
  {
    this->liverStageDrug_.set (x);
  }

  void HSImmediateOutcomes::
  setLiverStageDrug (const LiverStageDrugOptional& x)
  {
    this->liverStageDrug_ = x;
  }

  void HSImmediateOutcomes::
  setLiverStageDrug (::std::unique_ptr< LiverStageDrugType > x)
  {
    this->liverStageDrug_.set (std::move (x));
  }

  const HSImmediateOutcomes::NameOptional& HSImmediateOutcomes::
  getName () const
  {
    return this->name_;
  }

  HSImmediateOutcomes::NameOptional& HSImmediateOutcomes::
  getName ()
  {
    return this->name_;
  }

  void HSImmediateOutcomes::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void HSImmediateOutcomes::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void HSImmediateOutcomes::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const HSImmediateOutcomes::UseDiagnosticUCType& HSImmediateOutcomes::
  getUseDiagnosticUC () const
  {
    return this->useDiagnosticUC_.get ();
  }

  HSImmediateOutcomes::UseDiagnosticUCType& HSImmediateOutcomes::
  getUseDiagnosticUC ()
  {
    return this->useDiagnosticUC_.get ();
  }

  void HSImmediateOutcomes::
  setUseDiagnosticUC (const UseDiagnosticUCType& x)
  {
    this->useDiagnosticUC_.set (x);
  }

  HSImmediateOutcomes::UseDiagnosticUCType HSImmediateOutcomes::
  getUseDiagnosticUCDefaultValue ()
  {
    return UseDiagnosticUCType (false);
  }


  // TreatmentDetails
  // 

  const TreatmentDetails::CQOptional& TreatmentDetails::
  getCQ () const
  {
    return this->CQ_;
  }

  TreatmentDetails::CQOptional& TreatmentDetails::
  getCQ ()
  {
    return this->CQ_;
  }

  void TreatmentDetails::
  setCQ (const CQType& x)
  {
    this->CQ_.set (x);
  }

  void TreatmentDetails::
  setCQ (const CQOptional& x)
  {
    this->CQ_ = x;
  }

  void TreatmentDetails::
  setCQ (::std::unique_ptr< CQType > x)
  {
    this->CQ_.set (std::move (x));
  }

  const TreatmentDetails::SPOptional& TreatmentDetails::
  getSP () const
  {
    return this->SP_;
  }

  TreatmentDetails::SPOptional& TreatmentDetails::
  getSP ()
  {
    return this->SP_;
  }

  void TreatmentDetails::
  setSP (const SPType& x)
  {
    this->SP_.set (x);
  }

  void TreatmentDetails::
  setSP (const SPOptional& x)
  {
    this->SP_ = x;
  }

  void TreatmentDetails::
  setSP (::std::unique_ptr< SPType > x)
  {
    this->SP_.set (std::move (x));
  }

  const TreatmentDetails::AQOptional& TreatmentDetails::
  getAQ () const
  {
    return this->AQ_;
  }

  TreatmentDetails::AQOptional& TreatmentDetails::
  getAQ ()
  {
    return this->AQ_;
  }

  void TreatmentDetails::
  setAQ (const AQType& x)
  {
    this->AQ_.set (x);
  }

  void TreatmentDetails::
  setAQ (const AQOptional& x)
  {
    this->AQ_ = x;
  }

  void TreatmentDetails::
  setAQ (::std::unique_ptr< AQType > x)
  {
    this->AQ_.set (std::move (x));
  }

  const TreatmentDetails::SPAQOptional& TreatmentDetails::
  getSPAQ () const
  {
    return this->SPAQ_;
  }

  TreatmentDetails::SPAQOptional& TreatmentDetails::
  getSPAQ ()
  {
    return this->SPAQ_;
  }

  void TreatmentDetails::
  setSPAQ (const SPAQType& x)
  {
    this->SPAQ_.set (x);
  }

  void TreatmentDetails::
  setSPAQ (const SPAQOptional& x)
  {
    this->SPAQ_ = x;
  }

  void TreatmentDetails::
  setSPAQ (::std::unique_ptr< SPAQType > x)
  {
    this->SPAQ_.set (std::move (x));
  }

  const TreatmentDetails::ACTOptional& TreatmentDetails::
  getACT () const
  {
    return this->ACT_;
  }

  TreatmentDetails::ACTOptional& TreatmentDetails::
  getACT ()
  {
    return this->ACT_;
  }

  void TreatmentDetails::
  setACT (const ACTType& x)
  {
    this->ACT_.set (x);
  }

  void TreatmentDetails::
  setACT (const ACTOptional& x)
  {
    this->ACT_ = x;
  }

  void TreatmentDetails::
  setACT (::std::unique_ptr< ACTType > x)
  {
    this->ACT_.set (std::move (x));
  }

  const TreatmentDetails::QNOptional& TreatmentDetails::
  getQN () const
  {
    return this->QN_;
  }

  TreatmentDetails::QNOptional& TreatmentDetails::
  getQN ()
  {
    return this->QN_;
  }

  void TreatmentDetails::
  setQN (const QNType& x)
  {
    this->QN_.set (x);
  }

  void TreatmentDetails::
  setQN (const QNOptional& x)
  {
    this->QN_ = x;
  }

  void TreatmentDetails::
  setQN (::std::unique_ptr< QNType > x)
  {
    this->QN_.set (std::move (x));
  }

  const TreatmentDetails::SelfTreatmentType& TreatmentDetails::
  getSelfTreatment () const
  {
    return this->selfTreatment_.get ();
  }

  TreatmentDetails::SelfTreatmentType& TreatmentDetails::
  getSelfTreatment ()
  {
    return this->selfTreatment_.get ();
  }

  void TreatmentDetails::
  setSelfTreatment (const SelfTreatmentType& x)
  {
    this->selfTreatment_.set (x);
  }

  void TreatmentDetails::
  setSelfTreatment (::std::unique_ptr< SelfTreatmentType > x)
  {
    this->selfTreatment_.set (std::move (x));
  }


  // HSDT5Day
  // 

  const HSDT5Day::PSeekOfficialCareUncomplicated1Type& HSDT5Day::
  getPSeekOfficialCareUncomplicated1 () const
  {
    return this->pSeekOfficialCareUncomplicated1_.get ();
  }

  HSDT5Day::PSeekOfficialCareUncomplicated1Type& HSDT5Day::
  getPSeekOfficialCareUncomplicated1 ()
  {
    return this->pSeekOfficialCareUncomplicated1_.get ();
  }

  void HSDT5Day::
  setPSeekOfficialCareUncomplicated1 (const PSeekOfficialCareUncomplicated1Type& x)
  {
    this->pSeekOfficialCareUncomplicated1_.set (x);
  }

  void HSDT5Day::
  setPSeekOfficialCareUncomplicated1 (::std::unique_ptr< PSeekOfficialCareUncomplicated1Type > x)
  {
    this->pSeekOfficialCareUncomplicated1_.set (std::move (x));
  }

  const HSDT5Day::PSelfTreatUncomplicatedType& HSDT5Day::
  getPSelfTreatUncomplicated () const
  {
    return this->pSelfTreatUncomplicated_.get ();
  }

  HSDT5Day::PSelfTreatUncomplicatedType& HSDT5Day::
  getPSelfTreatUncomplicated ()
  {
    return this->pSelfTreatUncomplicated_.get ();
  }

  void HSDT5Day::
  setPSelfTreatUncomplicated (const PSelfTreatUncomplicatedType& x)
  {
    this->pSelfTreatUncomplicated_.set (x);
  }

  void HSDT5Day::
  setPSelfTreatUncomplicated (::std::unique_ptr< PSelfTreatUncomplicatedType > x)
  {
    this->pSelfTreatUncomplicated_.set (std::move (x));
  }

  const HSDT5Day::PSeekOfficialCareUncomplicated2Type& HSDT5Day::
  getPSeekOfficialCareUncomplicated2 () const
  {
    return this->pSeekOfficialCareUncomplicated2_.get ();
  }

  HSDT5Day::PSeekOfficialCareUncomplicated2Type& HSDT5Day::
  getPSeekOfficialCareUncomplicated2 ()
  {
    return this->pSeekOfficialCareUncomplicated2_.get ();
  }

  void HSDT5Day::
  setPSeekOfficialCareUncomplicated2 (const PSeekOfficialCareUncomplicated2Type& x)
  {
    this->pSeekOfficialCareUncomplicated2_.set (x);
  }

  void HSDT5Day::
  setPSeekOfficialCareUncomplicated2 (::std::unique_ptr< PSeekOfficialCareUncomplicated2Type > x)
  {
    this->pSeekOfficialCareUncomplicated2_.set (std::move (x));
  }

  const HSDT5Day::PSeekOfficialCareSevereType& HSDT5Day::
  getPSeekOfficialCareSevere () const
  {
    return this->pSeekOfficialCareSevere_.get ();
  }

  HSDT5Day::PSeekOfficialCareSevereType& HSDT5Day::
  getPSeekOfficialCareSevere ()
  {
    return this->pSeekOfficialCareSevere_.get ();
  }

  void HSDT5Day::
  setPSeekOfficialCareSevere (const PSeekOfficialCareSevereType& x)
  {
    this->pSeekOfficialCareSevere_.set (x);
  }

  void HSDT5Day::
  setPSeekOfficialCareSevere (::std::unique_ptr< PSeekOfficialCareSevereType > x)
  {
    this->pSeekOfficialCareSevere_.set (std::move (x));
  }

  const HSDT5Day::LiverStageDrugOptional& HSDT5Day::
  getLiverStageDrug () const
  {
    return this->liverStageDrug_;
  }

  HSDT5Day::LiverStageDrugOptional& HSDT5Day::
  getLiverStageDrug ()
  {
    return this->liverStageDrug_;
  }

  void HSDT5Day::
  setLiverStageDrug (const LiverStageDrugType& x)
  {
    this->liverStageDrug_.set (x);
  }

  void HSDT5Day::
  setLiverStageDrug (const LiverStageDrugOptional& x)
  {
    this->liverStageDrug_ = x;
  }

  void HSDT5Day::
  setLiverStageDrug (::std::unique_ptr< LiverStageDrugType > x)
  {
    this->liverStageDrug_.set (std::move (x));
  }

  const HSDT5Day::TreeUCOfficialType& HSDT5Day::
  getTreeUCOfficial () const
  {
    return this->treeUCOfficial_.get ();
  }

  HSDT5Day::TreeUCOfficialType& HSDT5Day::
  getTreeUCOfficial ()
  {
    return this->treeUCOfficial_.get ();
  }

  void HSDT5Day::
  setTreeUCOfficial (const TreeUCOfficialType& x)
  {
    this->treeUCOfficial_.set (x);
  }

  void HSDT5Day::
  setTreeUCOfficial (::std::unique_ptr< TreeUCOfficialType > x)
  {
    this->treeUCOfficial_.set (std::move (x));
  }

  const HSDT5Day::TreeUCSelfTreatType& HSDT5Day::
  getTreeUCSelfTreat () const
  {
    return this->treeUCSelfTreat_.get ();
  }

  HSDT5Day::TreeUCSelfTreatType& HSDT5Day::
  getTreeUCSelfTreat ()
  {
    return this->treeUCSelfTreat_.get ();
  }

  void HSDT5Day::
  setTreeUCSelfTreat (const TreeUCSelfTreatType& x)
  {
    this->treeUCSelfTreat_.set (x);
  }

  void HSDT5Day::
  setTreeUCSelfTreat (::std::unique_ptr< TreeUCSelfTreatType > x)
  {
    this->treeUCSelfTreat_.set (std::move (x));
  }

  const HSDT5Day::CureRateSevereType& HSDT5Day::
  getCureRateSevere () const
  {
    return this->cureRateSevere_.get ();
  }

  HSDT5Day::CureRateSevereType& HSDT5Day::
  getCureRateSevere ()
  {
    return this->cureRateSevere_.get ();
  }

  void HSDT5Day::
  setCureRateSevere (const CureRateSevereType& x)
  {
    this->cureRateSevere_.set (x);
  }

  void HSDT5Day::
  setCureRateSevere (::std::unique_ptr< CureRateSevereType > x)
  {
    this->cureRateSevere_.set (std::move (x));
  }

  const HSDT5Day::TreatmentSevereType& HSDT5Day::
  getTreatmentSevere () const
  {
    return this->treatmentSevere_.get ();
  }

  HSDT5Day::TreatmentSevereType& HSDT5Day::
  getTreatmentSevere ()
  {
    return this->treatmentSevere_.get ();
  }

  void HSDT5Day::
  setTreatmentSevere (const TreatmentSevereType& x)
  {
    this->treatmentSevere_.set (x);
  }

  void HSDT5Day::
  setTreatmentSevere (::std::unique_ptr< TreatmentSevereType > x)
  {
    this->treatmentSevere_.set (std::move (x));
  }

  const HSDT5Day::NameOptional& HSDT5Day::
  getName () const
  {
    return this->name_;
  }

  HSDT5Day::NameOptional& HSDT5Day::
  getName ()
  {
    return this->name_;
  }

  void HSDT5Day::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void HSDT5Day::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void HSDT5Day::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // HSEventScheduler
  // 

  const HSEventScheduler::UncomplicatedType& HSEventScheduler::
  getUncomplicated () const
  {
    return this->uncomplicated_.get ();
  }

  HSEventScheduler::UncomplicatedType& HSEventScheduler::
  getUncomplicated ()
  {
    return this->uncomplicated_.get ();
  }

  void HSEventScheduler::
  setUncomplicated (const UncomplicatedType& x)
  {
    this->uncomplicated_.set (x);
  }

  void HSEventScheduler::
  setUncomplicated (::std::unique_ptr< UncomplicatedType > x)
  {
    this->uncomplicated_.set (std::move (x));
  }

  const HSEventScheduler::ComplicatedType& HSEventScheduler::
  getComplicated () const
  {
    return this->complicated_.get ();
  }

  HSEventScheduler::ComplicatedType& HSEventScheduler::
  getComplicated ()
  {
    return this->complicated_.get ();
  }

  void HSEventScheduler::
  setComplicated (const ComplicatedType& x)
  {
    this->complicated_.set (x);
  }

  void HSEventScheduler::
  setComplicated (::std::unique_ptr< ComplicatedType > x)
  {
    this->complicated_.set (std::move (x));
  }

  const HSEventScheduler::ClinicalOutcomesType& HSEventScheduler::
  getClinicalOutcomes () const
  {
    return this->ClinicalOutcomes_.get ();
  }

  HSEventScheduler::ClinicalOutcomesType& HSEventScheduler::
  getClinicalOutcomes ()
  {
    return this->ClinicalOutcomes_.get ();
  }

  void HSEventScheduler::
  setClinicalOutcomes (const ClinicalOutcomesType& x)
  {
    this->ClinicalOutcomes_.set (x);
  }

  void HSEventScheduler::
  setClinicalOutcomes (::std::unique_ptr< ClinicalOutcomesType > x)
  {
    this->ClinicalOutcomes_.set (std::move (x));
  }

  const HSEventScheduler::NonMalariaFeversOptional& HSEventScheduler::
  getNonMalariaFevers () const
  {
    return this->NonMalariaFevers_;
  }

  HSEventScheduler::NonMalariaFeversOptional& HSEventScheduler::
  getNonMalariaFevers ()
  {
    return this->NonMalariaFevers_;
  }

  void HSEventScheduler::
  setNonMalariaFevers (const NonMalariaFeversType& x)
  {
    this->NonMalariaFevers_.set (x);
  }

  void HSEventScheduler::
  setNonMalariaFevers (const NonMalariaFeversOptional& x)
  {
    this->NonMalariaFevers_ = x;
  }

  void HSEventScheduler::
  setNonMalariaFevers (::std::unique_ptr< NonMalariaFeversType > x)
  {
    this->NonMalariaFevers_.set (std::move (x));
  }


  // ClinicalOutcomes
  // 

  const ClinicalOutcomes::MaxUCSeekingMemoryType& ClinicalOutcomes::
  getMaxUCSeekingMemory () const
  {
    return this->maxUCSeekingMemory_.get ();
  }

  ClinicalOutcomes::MaxUCSeekingMemoryType& ClinicalOutcomes::
  getMaxUCSeekingMemory ()
  {
    return this->maxUCSeekingMemory_.get ();
  }

  void ClinicalOutcomes::
  setMaxUCSeekingMemory (const MaxUCSeekingMemoryType& x)
  {
    this->maxUCSeekingMemory_.set (x);
  }

  const ClinicalOutcomes::UncomplicatedCaseDurationType& ClinicalOutcomes::
  getUncomplicatedCaseDuration () const
  {
    return this->uncomplicatedCaseDuration_.get ();
  }

  ClinicalOutcomes::UncomplicatedCaseDurationType& ClinicalOutcomes::
  getUncomplicatedCaseDuration ()
  {
    return this->uncomplicatedCaseDuration_.get ();
  }

  void ClinicalOutcomes::
  setUncomplicatedCaseDuration (const UncomplicatedCaseDurationType& x)
  {
    this->uncomplicatedCaseDuration_.set (x);
  }

  const ClinicalOutcomes::ComplicatedCaseDurationType& ClinicalOutcomes::
  getComplicatedCaseDuration () const
  {
    return this->complicatedCaseDuration_.get ();
  }

  ClinicalOutcomes::ComplicatedCaseDurationType& ClinicalOutcomes::
  getComplicatedCaseDuration ()
  {
    return this->complicatedCaseDuration_.get ();
  }

  void ClinicalOutcomes::
  setComplicatedCaseDuration (const ComplicatedCaseDurationType& x)
  {
    this->complicatedCaseDuration_.set (x);
  }

  const ClinicalOutcomes::ComplicatedRiskDurationType& ClinicalOutcomes::
  getComplicatedRiskDuration () const
  {
    return this->complicatedRiskDuration_.get ();
  }

  ClinicalOutcomes::ComplicatedRiskDurationType& ClinicalOutcomes::
  getComplicatedRiskDuration ()
  {
    return this->complicatedRiskDuration_.get ();
  }

  void ClinicalOutcomes::
  setComplicatedRiskDuration (const ComplicatedRiskDurationType& x)
  {
    this->complicatedRiskDuration_.set (x);
  }

  const ClinicalOutcomes::DailyPrImmUCTSSequence& ClinicalOutcomes::
  getDailyPrImmUCTS () const
  {
    return this->dailyPrImmUCTS_;
  }

  ClinicalOutcomes::DailyPrImmUCTSSequence& ClinicalOutcomes::
  getDailyPrImmUCTS ()
  {
    return this->dailyPrImmUCTS_;
  }

  void ClinicalOutcomes::
  setDailyPrImmUCTS (const DailyPrImmUCTSSequence& s)
  {
    this->dailyPrImmUCTS_ = s;
  }


  // HSESNMF
  // 

  const HSESNMF::PrTreatmentType& HSESNMF::
  getPrTreatment () const
  {
    return this->prTreatment_.get ();
  }

  HSESNMF::PrTreatmentType& HSESNMF::
  getPrTreatment ()
  {
    return this->prTreatment_.get ();
  }

  void HSESNMF::
  setPrTreatment (const PrTreatmentType& x)
  {
    this->prTreatment_.set (x);
  }

  const HSESNMF::EffectNegativeTestType& HSESNMF::
  getEffectNegativeTest () const
  {
    return this->effectNegativeTest_.get ();
  }

  HSESNMF::EffectNegativeTestType& HSESNMF::
  getEffectNegativeTest ()
  {
    return this->effectNegativeTest_.get ();
  }

  void HSESNMF::
  setEffectNegativeTest (const EffectNegativeTestType& x)
  {
    this->effectNegativeTest_.set (x);
  }

  const HSESNMF::EffectPositiveTestType& HSESNMF::
  getEffectPositiveTest () const
  {
    return this->effectPositiveTest_.get ();
  }

  HSESNMF::EffectPositiveTestType& HSESNMF::
  getEffectPositiveTest ()
  {
    return this->effectPositiveTest_.get ();
  }

  void HSESNMF::
  setEffectPositiveTest (const EffectPositiveTestType& x)
  {
    this->effectPositiveTest_.set (x);
  }

  const HSESNMF::EffectNeedType& HSESNMF::
  getEffectNeed () const
  {
    return this->effectNeed_.get ();
  }

  HSESNMF::EffectNeedType& HSESNMF::
  getEffectNeed ()
  {
    return this->effectNeed_.get ();
  }

  void HSESNMF::
  setEffectNeed (const EffectNeedType& x)
  {
    this->effectNeed_.set (x);
  }

  const HSESNMF::EffectInformalType& HSESNMF::
  getEffectInformal () const
  {
    return this->effectInformal_.get ();
  }

  HSESNMF::EffectInformalType& HSESNMF::
  getEffectInformal ()
  {
    return this->effectInformal_.get ();
  }

  void HSESNMF::
  setEffectInformal (const EffectInformalType& x)
  {
    this->effectInformal_.set (x);
  }

  const HSESNMF::CFRType& HSESNMF::
  getCFR () const
  {
    return this->CFR_.get ();
  }

  HSESNMF::CFRType& HSESNMF::
  getCFR ()
  {
    return this->CFR_.get ();
  }

  void HSESNMF::
  setCFR (const CFRType& x)
  {
    this->CFR_.set (x);
  }

  void HSESNMF::
  setCFR (::std::unique_ptr< CFRType > x)
  {
    this->CFR_.set (std::move (x));
  }

  const HSESNMF::TreatmentEfficacyType& HSESNMF::
  getTreatmentEfficacy () const
  {
    return this->TreatmentEfficacy_.get ();
  }

  HSESNMF::TreatmentEfficacyType& HSESNMF::
  getTreatmentEfficacy ()
  {
    return this->TreatmentEfficacy_.get ();
  }

  void HSESNMF::
  setTreatmentEfficacy (const TreatmentEfficacyType& x)
  {
    this->TreatmentEfficacy_.set (x);
  }


  // DecisionTree
  // 

  const DecisionTree::MultipleOptional& DecisionTree::
  getMultiple () const
  {
    return this->multiple_;
  }

  DecisionTree::MultipleOptional& DecisionTree::
  getMultiple ()
  {
    return this->multiple_;
  }

  void DecisionTree::
  setMultiple (const MultipleType& x)
  {
    this->multiple_.set (x);
  }

  void DecisionTree::
  setMultiple (const MultipleOptional& x)
  {
    this->multiple_ = x;
  }

  void DecisionTree::
  setMultiple (::std::unique_ptr< MultipleType > x)
  {
    this->multiple_.set (std::move (x));
  }

  const DecisionTree::CaseTypeOptional& DecisionTree::
  getCaseType () const
  {
    return this->caseType_;
  }

  DecisionTree::CaseTypeOptional& DecisionTree::
  getCaseType ()
  {
    return this->caseType_;
  }

  void DecisionTree::
  setCaseType (const CaseTypeType& x)
  {
    this->caseType_.set (x);
  }

  void DecisionTree::
  setCaseType (const CaseTypeOptional& x)
  {
    this->caseType_ = x;
  }

  void DecisionTree::
  setCaseType (::std::unique_ptr< CaseTypeType > x)
  {
    this->caseType_.set (std::move (x));
  }

  const DecisionTree::DiagnosticOptional& DecisionTree::
  getDiagnostic () const
  {
    return this->diagnostic_;
  }

  DecisionTree::DiagnosticOptional& DecisionTree::
  getDiagnostic ()
  {
    return this->diagnostic_;
  }

  void DecisionTree::
  setDiagnostic (const DiagnosticType& x)
  {
    this->diagnostic_.set (x);
  }

  void DecisionTree::
  setDiagnostic (const DiagnosticOptional& x)
  {
    this->diagnostic_ = x;
  }

  void DecisionTree::
  setDiagnostic (::std::unique_ptr< DiagnosticType > x)
  {
    this->diagnostic_.set (std::move (x));
  }

  const DecisionTree::RandomOptional& DecisionTree::
  getRandom () const
  {
    return this->random_;
  }

  DecisionTree::RandomOptional& DecisionTree::
  getRandom ()
  {
    return this->random_;
  }

  void DecisionTree::
  setRandom (const RandomType& x)
  {
    this->random_.set (x);
  }

  void DecisionTree::
  setRandom (const RandomOptional& x)
  {
    this->random_ = x;
  }

  void DecisionTree::
  setRandom (::std::unique_ptr< RandomType > x)
  {
    this->random_.set (std::move (x));
  }

  const DecisionTree::AgeOptional& DecisionTree::
  getAge () const
  {
    return this->age_;
  }

  DecisionTree::AgeOptional& DecisionTree::
  getAge ()
  {
    return this->age_;
  }

  void DecisionTree::
  setAge (const AgeType& x)
  {
    this->age_.set (x);
  }

  void DecisionTree::
  setAge (const AgeOptional& x)
  {
    this->age_ = x;
  }

  void DecisionTree::
  setAge (::std::unique_ptr< AgeType > x)
  {
    this->age_.set (std::move (x));
  }

  const DecisionTree::NoTreatmentOptional& DecisionTree::
  getNoTreatment () const
  {
    return this->noTreatment_;
  }

  DecisionTree::NoTreatmentOptional& DecisionTree::
  getNoTreatment ()
  {
    return this->noTreatment_;
  }

  void DecisionTree::
  setNoTreatment (const NoTreatmentType& x)
  {
    this->noTreatment_.set (x);
  }

  void DecisionTree::
  setNoTreatment (const NoTreatmentOptional& x)
  {
    this->noTreatment_ = x;
  }

  void DecisionTree::
  setNoTreatment (::std::unique_ptr< NoTreatmentType > x)
  {
    this->noTreatment_.set (std::move (x));
  }

  const DecisionTree::TreatFailureOptional& DecisionTree::
  getTreatFailure () const
  {
    return this->treatFailure_;
  }

  DecisionTree::TreatFailureOptional& DecisionTree::
  getTreatFailure ()
  {
    return this->treatFailure_;
  }

  void DecisionTree::
  setTreatFailure (const TreatFailureType& x)
  {
    this->treatFailure_.set (x);
  }

  void DecisionTree::
  setTreatFailure (const TreatFailureOptional& x)
  {
    this->treatFailure_ = x;
  }

  void DecisionTree::
  setTreatFailure (::std::unique_ptr< TreatFailureType > x)
  {
    this->treatFailure_.set (std::move (x));
  }

  const DecisionTree::TreatPKPDSequence& DecisionTree::
  getTreatPKPD () const
  {
    return this->treatPKPD_;
  }

  DecisionTree::TreatPKPDSequence& DecisionTree::
  getTreatPKPD ()
  {
    return this->treatPKPD_;
  }

  void DecisionTree::
  setTreatPKPD (const TreatPKPDSequence& s)
  {
    this->treatPKPD_ = s;
  }

  const DecisionTree::TreatSimpleOptional& DecisionTree::
  getTreatSimple () const
  {
    return this->treatSimple_;
  }

  DecisionTree::TreatSimpleOptional& DecisionTree::
  getTreatSimple ()
  {
    return this->treatSimple_;
  }

  void DecisionTree::
  setTreatSimple (const TreatSimpleType& x)
  {
    this->treatSimple_.set (x);
  }

  void DecisionTree::
  setTreatSimple (const TreatSimpleOptional& x)
  {
    this->treatSimple_ = x;
  }

  void DecisionTree::
  setTreatSimple (::std::unique_ptr< TreatSimpleType > x)
  {
    this->treatSimple_.set (std::move (x));
  }

  const DecisionTree::DeploySequence& DecisionTree::
  getDeploy () const
  {
    return this->deploy_;
  }

  DecisionTree::DeploySequence& DecisionTree::
  getDeploy ()
  {
    return this->deploy_;
  }

  void DecisionTree::
  setDeploy (const DeploySequence& s)
  {
    this->deploy_ = s;
  }

  const DecisionTree::NameOptional& DecisionTree::
  getName () const
  {
    return this->name_;
  }

  DecisionTree::NameOptional& DecisionTree::
  getName ()
  {
    return this->name_;
  }

  void DecisionTree::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void DecisionTree::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void DecisionTree::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // DTMultiple
  // 

  const DTMultiple::CaseTypeSequence& DTMultiple::
  getCaseType () const
  {
    return this->caseType_;
  }

  DTMultiple::CaseTypeSequence& DTMultiple::
  getCaseType ()
  {
    return this->caseType_;
  }

  void DTMultiple::
  setCaseType (const CaseTypeSequence& s)
  {
    this->caseType_ = s;
  }

  const DTMultiple::DiagnosticSequence& DTMultiple::
  getDiagnostic () const
  {
    return this->diagnostic_;
  }

  DTMultiple::DiagnosticSequence& DTMultiple::
  getDiagnostic ()
  {
    return this->diagnostic_;
  }

  void DTMultiple::
  setDiagnostic (const DiagnosticSequence& s)
  {
    this->diagnostic_ = s;
  }

  const DTMultiple::RandomSequence& DTMultiple::
  getRandom () const
  {
    return this->random_;
  }

  DTMultiple::RandomSequence& DTMultiple::
  getRandom ()
  {
    return this->random_;
  }

  void DTMultiple::
  setRandom (const RandomSequence& s)
  {
    this->random_ = s;
  }

  const DTMultiple::AgeSequence& DTMultiple::
  getAge () const
  {
    return this->age_;
  }

  DTMultiple::AgeSequence& DTMultiple::
  getAge ()
  {
    return this->age_;
  }

  void DTMultiple::
  setAge (const AgeSequence& s)
  {
    this->age_ = s;
  }

  const DTMultiple::TreatPKPDSequence& DTMultiple::
  getTreatPKPD () const
  {
    return this->treatPKPD_;
  }

  DTMultiple::TreatPKPDSequence& DTMultiple::
  getTreatPKPD ()
  {
    return this->treatPKPD_;
  }

  void DTMultiple::
  setTreatPKPD (const TreatPKPDSequence& s)
  {
    this->treatPKPD_ = s;
  }

  const DTMultiple::TreatSimpleOptional& DTMultiple::
  getTreatSimple () const
  {
    return this->treatSimple_;
  }

  DTMultiple::TreatSimpleOptional& DTMultiple::
  getTreatSimple ()
  {
    return this->treatSimple_;
  }

  void DTMultiple::
  setTreatSimple (const TreatSimpleType& x)
  {
    this->treatSimple_.set (x);
  }

  void DTMultiple::
  setTreatSimple (const TreatSimpleOptional& x)
  {
    this->treatSimple_ = x;
  }

  void DTMultiple::
  setTreatSimple (::std::unique_ptr< TreatSimpleType > x)
  {
    this->treatSimple_.set (std::move (x));
  }

  const DTMultiple::DeploySequence& DTMultiple::
  getDeploy () const
  {
    return this->deploy_;
  }

  DTMultiple::DeploySequence& DTMultiple::
  getDeploy ()
  {
    return this->deploy_;
  }

  void DTMultiple::
  setDeploy (const DeploySequence& s)
  {
    this->deploy_ = s;
  }

  const DTMultiple::NameOptional& DTMultiple::
  getName () const
  {
    return this->name_;
  }

  DTMultiple::NameOptional& DTMultiple::
  getName ()
  {
    return this->name_;
  }

  void DTMultiple::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void DTMultiple::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void DTMultiple::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // DTCaseType
  // 

  const DTCaseType::FirstLineType& DTCaseType::
  getFirstLine () const
  {
    return this->firstLine_.get ();
  }

  DTCaseType::FirstLineType& DTCaseType::
  getFirstLine ()
  {
    return this->firstLine_.get ();
  }

  void DTCaseType::
  setFirstLine (const FirstLineType& x)
  {
    this->firstLine_.set (x);
  }

  void DTCaseType::
  setFirstLine (::std::unique_ptr< FirstLineType > x)
  {
    this->firstLine_.set (std::move (x));
  }

  const DTCaseType::SecondLineType& DTCaseType::
  getSecondLine () const
  {
    return this->secondLine_.get ();
  }

  DTCaseType::SecondLineType& DTCaseType::
  getSecondLine ()
  {
    return this->secondLine_.get ();
  }

  void DTCaseType::
  setSecondLine (const SecondLineType& x)
  {
    this->secondLine_.set (x);
  }

  void DTCaseType::
  setSecondLine (::std::unique_ptr< SecondLineType > x)
  {
    this->secondLine_.set (std::move (x));
  }

  const DTCaseType::NameOptional& DTCaseType::
  getName () const
  {
    return this->name_;
  }

  DTCaseType::NameOptional& DTCaseType::
  getName ()
  {
    return this->name_;
  }

  void DTCaseType::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void DTCaseType::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void DTCaseType::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // DTDiagnostic
  // 

  const DTDiagnostic::PositiveType& DTDiagnostic::
  getPositive () const
  {
    return this->positive_.get ();
  }

  DTDiagnostic::PositiveType& DTDiagnostic::
  getPositive ()
  {
    return this->positive_.get ();
  }

  void DTDiagnostic::
  setPositive (const PositiveType& x)
  {
    this->positive_.set (x);
  }

  void DTDiagnostic::
  setPositive (::std::unique_ptr< PositiveType > x)
  {
    this->positive_.set (std::move (x));
  }

  const DTDiagnostic::NegativeType& DTDiagnostic::
  getNegative () const
  {
    return this->negative_.get ();
  }

  DTDiagnostic::NegativeType& DTDiagnostic::
  getNegative ()
  {
    return this->negative_.get ();
  }

  void DTDiagnostic::
  setNegative (const NegativeType& x)
  {
    this->negative_.set (x);
  }

  void DTDiagnostic::
  setNegative (::std::unique_ptr< NegativeType > x)
  {
    this->negative_.set (std::move (x));
  }

  const DTDiagnostic::DiagnosticType& DTDiagnostic::
  getDiagnostic () const
  {
    return this->diagnostic_.get ();
  }

  DTDiagnostic::DiagnosticType& DTDiagnostic::
  getDiagnostic ()
  {
    return this->diagnostic_.get ();
  }

  void DTDiagnostic::
  setDiagnostic (const DiagnosticType& x)
  {
    this->diagnostic_.set (x);
  }

  void DTDiagnostic::
  setDiagnostic (::std::unique_ptr< DiagnosticType > x)
  {
    this->diagnostic_.set (std::move (x));
  }

  const DTDiagnostic::NameOptional& DTDiagnostic::
  getName () const
  {
    return this->name_;
  }

  DTDiagnostic::NameOptional& DTDiagnostic::
  getName ()
  {
    return this->name_;
  }

  void DTDiagnostic::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void DTDiagnostic::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void DTDiagnostic::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // DTRandom
  // 

  const DTRandom::OutcomeSequence& DTRandom::
  getOutcome () const
  {
    return this->outcome_;
  }

  DTRandom::OutcomeSequence& DTRandom::
  getOutcome ()
  {
    return this->outcome_;
  }

  void DTRandom::
  setOutcome (const OutcomeSequence& s)
  {
    this->outcome_ = s;
  }

  const DTRandom::NameOptional& DTRandom::
  getName () const
  {
    return this->name_;
  }

  DTRandom::NameOptional& DTRandom::
  getName ()
  {
    return this->name_;
  }

  void DTRandom::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void DTRandom::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void DTRandom::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // DTAge
  // 

  const DTAge::AgeSequence& DTAge::
  getAge () const
  {
    return this->age_;
  }

  DTAge::AgeSequence& DTAge::
  getAge ()
  {
    return this->age_;
  }

  void DTAge::
  setAge (const AgeSequence& s)
  {
    this->age_ = s;
  }

  const DTAge::NameOptional& DTAge::
  getName () const
  {
    return this->name_;
  }

  DTAge::NameOptional& DTAge::
  getName ()
  {
    return this->name_;
  }

  void DTAge::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void DTAge::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void DTAge::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // DTNoTreatment
  // 

  const DTNoTreatment::NameOptional& DTNoTreatment::
  getName () const
  {
    return this->name_;
  }

  DTNoTreatment::NameOptional& DTNoTreatment::
  getName ()
  {
    return this->name_;
  }

  void DTNoTreatment::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void DTNoTreatment::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void DTNoTreatment::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // DTTreatFailure
  // 

  const DTTreatFailure::NameOptional& DTTreatFailure::
  getName () const
  {
    return this->name_;
  }

  DTTreatFailure::NameOptional& DTTreatFailure::
  getName ()
  {
    return this->name_;
  }

  void DTTreatFailure::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void DTTreatFailure::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void DTTreatFailure::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // DTTreatPKPD
  // 

  const DTTreatPKPD::ScheduleType& DTTreatPKPD::
  getSchedule () const
  {
    return this->schedule_.get ();
  }

  DTTreatPKPD::ScheduleType& DTTreatPKPD::
  getSchedule ()
  {
    return this->schedule_.get ();
  }

  void DTTreatPKPD::
  setSchedule (const ScheduleType& x)
  {
    this->schedule_.set (x);
  }

  void DTTreatPKPD::
  setSchedule (::std::unique_ptr< ScheduleType > x)
  {
    this->schedule_.set (std::move (x));
  }

  const DTTreatPKPD::DosageType& DTTreatPKPD::
  getDosage () const
  {
    return this->dosage_.get ();
  }

  DTTreatPKPD::DosageType& DTTreatPKPD::
  getDosage ()
  {
    return this->dosage_.get ();
  }

  void DTTreatPKPD::
  setDosage (const DosageType& x)
  {
    this->dosage_.set (x);
  }

  void DTTreatPKPD::
  setDosage (::std::unique_ptr< DosageType > x)
  {
    this->dosage_.set (std::move (x));
  }

  const DTTreatPKPD::Delay_hType& DTTreatPKPD::
  getDelay_h () const
  {
    return this->delay_h_.get ();
  }

  DTTreatPKPD::Delay_hType& DTTreatPKPD::
  getDelay_h ()
  {
    return this->delay_h_.get ();
  }

  void DTTreatPKPD::
  setDelay_h (const Delay_hType& x)
  {
    this->delay_h_.set (x);
  }

  DTTreatPKPD::Delay_hType DTTreatPKPD::
  getDelay_hDefaultValue ()
  {
    return Delay_hType (0.0);
  }


  // DTTreatSimple
  // 

  const DTTreatSimple::DurationLiverType& DTTreatSimple::
  getDurationLiver () const
  {
    return this->durationLiver_.get ();
  }

  DTTreatSimple::DurationLiverType& DTTreatSimple::
  getDurationLiver ()
  {
    return this->durationLiver_.get ();
  }

  void DTTreatSimple::
  setDurationLiver (const DurationLiverType& x)
  {
    this->durationLiver_.set (x);
  }

  void DTTreatSimple::
  setDurationLiver (::std::unique_ptr< DurationLiverType > x)
  {
    this->durationLiver_.set (std::move (x));
  }

  const DTTreatSimple::DurationBloodType& DTTreatSimple::
  getDurationBlood () const
  {
    return this->durationBlood_.get ();
  }

  DTTreatSimple::DurationBloodType& DTTreatSimple::
  getDurationBlood ()
  {
    return this->durationBlood_.get ();
  }

  void DTTreatSimple::
  setDurationBlood (const DurationBloodType& x)
  {
    this->durationBlood_.set (x);
  }

  void DTTreatSimple::
  setDurationBlood (::std::unique_ptr< DurationBloodType > x)
  {
    this->durationBlood_.set (std::move (x));
  }


  // DTDeploy
  // 

  const DTDeploy::ComponentType& DTDeploy::
  getComponent () const
  {
    return this->component_.get ();
  }

  DTDeploy::ComponentType& DTDeploy::
  getComponent ()
  {
    return this->component_.get ();
  }

  void DTDeploy::
  setComponent (const ComponentType& x)
  {
    this->component_.set (x);
  }

  void DTDeploy::
  setComponent (::std::unique_ptr< ComponentType > x)
  {
    this->component_.set (std::move (x));
  }


  // TreatmentOption
  // 

  const TreatmentOption::ClearInfectionsSequence& TreatmentOption::
  getClearInfections () const
  {
    return this->clearInfections_;
  }

  TreatmentOption::ClearInfectionsSequence& TreatmentOption::
  getClearInfections ()
  {
    return this->clearInfections_;
  }

  void TreatmentOption::
  setClearInfections (const ClearInfectionsSequence& s)
  {
    this->clearInfections_ = s;
  }

  const TreatmentOption::NameOptional& TreatmentOption::
  getName () const
  {
    return this->name_;
  }

  TreatmentOption::NameOptional& TreatmentOption::
  getName ()
  {
    return this->name_;
  }

  void TreatmentOption::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void TreatmentOption::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void TreatmentOption::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // NeonatalMortality
  // 

  const NeonatalMortality::DiagnosticType& NeonatalMortality::
  getDiagnostic () const
  {
    return this->diagnostic_.get ();
  }

  NeonatalMortality::DiagnosticType& NeonatalMortality::
  getDiagnostic ()
  {
    return this->diagnostic_.get ();
  }

  void NeonatalMortality::
  setDiagnostic (const DiagnosticType& x)
  {
    this->diagnostic_.set (x);
  }

  void NeonatalMortality::
  setDiagnostic (::std::unique_ptr< DiagnosticType > x)
  {
    this->diagnostic_.set (std::move (x));
  }


  // NonMalariaFevers
  // 

  const NonMalariaFevers::IncidenceType& NonMalariaFevers::
  getIncidence () const
  {
    return this->incidence_.get ();
  }

  NonMalariaFevers::IncidenceType& NonMalariaFevers::
  getIncidence ()
  {
    return this->incidence_.get ();
  }

  void NonMalariaFevers::
  setIncidence (const IncidenceType& x)
  {
    this->incidence_.set (x);
  }

  void NonMalariaFevers::
  setIncidence (::std::unique_ptr< IncidenceType > x)
  {
    this->incidence_.set (std::move (x));
  }

  const NonMalariaFevers::PrNeedTreatmentNMFOptional& NonMalariaFevers::
  getPrNeedTreatmentNMF () const
  {
    return this->prNeedTreatmentNMF_;
  }

  NonMalariaFevers::PrNeedTreatmentNMFOptional& NonMalariaFevers::
  getPrNeedTreatmentNMF ()
  {
    return this->prNeedTreatmentNMF_;
  }

  void NonMalariaFevers::
  setPrNeedTreatmentNMF (const PrNeedTreatmentNMFType& x)
  {
    this->prNeedTreatmentNMF_.set (x);
  }

  void NonMalariaFevers::
  setPrNeedTreatmentNMF (const PrNeedTreatmentNMFOptional& x)
  {
    this->prNeedTreatmentNMF_ = x;
  }

  void NonMalariaFevers::
  setPrNeedTreatmentNMF (::std::unique_ptr< PrNeedTreatmentNMFType > x)
  {
    this->prNeedTreatmentNMF_.set (std::move (x));
  }

  const NonMalariaFevers::PrNeedTreatmentMFOptional& NonMalariaFevers::
  getPrNeedTreatmentMF () const
  {
    return this->prNeedTreatmentMF_;
  }

  NonMalariaFevers::PrNeedTreatmentMFOptional& NonMalariaFevers::
  getPrNeedTreatmentMF ()
  {
    return this->prNeedTreatmentMF_;
  }

  void NonMalariaFevers::
  setPrNeedTreatmentMF (const PrNeedTreatmentMFType& x)
  {
    this->prNeedTreatmentMF_.set (x);
  }

  void NonMalariaFevers::
  setPrNeedTreatmentMF (const PrNeedTreatmentMFOptional& x)
  {
    this->prNeedTreatmentMF_ = x;
  }

  void NonMalariaFevers::
  setPrNeedTreatmentMF (::std::unique_ptr< PrNeedTreatmentMFType > x)
  {
    this->prNeedTreatmentMF_.set (std::move (x));
  }


  // DrugRegimen
  // 

  const DrugRegimen::FirstLineType& DrugRegimen::
  getFirstLine () const
  {
    return this->firstLine_.get ();
  }

  DrugRegimen::FirstLineType& DrugRegimen::
  getFirstLine ()
  {
    return this->firstLine_.get ();
  }

  void DrugRegimen::
  setFirstLine (const FirstLineType& x)
  {
    this->firstLine_.set (x);
  }

  void DrugRegimen::
  setFirstLine (::std::unique_ptr< FirstLineType > x)
  {
    this->firstLine_.set (std::move (x));
  }

  const DrugRegimen::SecondLineType& DrugRegimen::
  getSecondLine () const
  {
    return this->secondLine_.get ();
  }

  DrugRegimen::SecondLineType& DrugRegimen::
  getSecondLine ()
  {
    return this->secondLine_.get ();
  }

  void DrugRegimen::
  setSecondLine (const SecondLineType& x)
  {
    this->secondLine_.set (x);
  }

  void DrugRegimen::
  setSecondLine (::std::unique_ptr< SecondLineType > x)
  {
    this->secondLine_.set (std::move (x));
  }

  const DrugRegimen::InpatientType& DrugRegimen::
  getInpatient () const
  {
    return this->inpatient_.get ();
  }

  DrugRegimen::InpatientType& DrugRegimen::
  getInpatient ()
  {
    return this->inpatient_.get ();
  }

  void DrugRegimen::
  setInpatient (const InpatientType& x)
  {
    this->inpatient_.set (x);
  }

  void DrugRegimen::
  setInpatient (::std::unique_ptr< InpatientType > x)
  {
    this->inpatient_.set (std::move (x));
  }


  // TreatmentActions
  // 

  const TreatmentActions::CQOptional& TreatmentActions::
  getCQ () const
  {
    return this->CQ_;
  }

  TreatmentActions::CQOptional& TreatmentActions::
  getCQ ()
  {
    return this->CQ_;
  }

  void TreatmentActions::
  setCQ (const CQType& x)
  {
    this->CQ_.set (x);
  }

  void TreatmentActions::
  setCQ (const CQOptional& x)
  {
    this->CQ_ = x;
  }

  void TreatmentActions::
  setCQ (::std::unique_ptr< CQType > x)
  {
    this->CQ_.set (std::move (x));
  }

  const TreatmentActions::SPOptional& TreatmentActions::
  getSP () const
  {
    return this->SP_;
  }

  TreatmentActions::SPOptional& TreatmentActions::
  getSP ()
  {
    return this->SP_;
  }

  void TreatmentActions::
  setSP (const SPType& x)
  {
    this->SP_.set (x);
  }

  void TreatmentActions::
  setSP (const SPOptional& x)
  {
    this->SP_ = x;
  }

  void TreatmentActions::
  setSP (::std::unique_ptr< SPType > x)
  {
    this->SP_.set (std::move (x));
  }

  const TreatmentActions::AQOptional& TreatmentActions::
  getAQ () const
  {
    return this->AQ_;
  }

  TreatmentActions::AQOptional& TreatmentActions::
  getAQ ()
  {
    return this->AQ_;
  }

  void TreatmentActions::
  setAQ (const AQType& x)
  {
    this->AQ_.set (x);
  }

  void TreatmentActions::
  setAQ (const AQOptional& x)
  {
    this->AQ_ = x;
  }

  void TreatmentActions::
  setAQ (::std::unique_ptr< AQType > x)
  {
    this->AQ_.set (std::move (x));
  }

  const TreatmentActions::SPAQOptional& TreatmentActions::
  getSPAQ () const
  {
    return this->SPAQ_;
  }

  TreatmentActions::SPAQOptional& TreatmentActions::
  getSPAQ ()
  {
    return this->SPAQ_;
  }

  void TreatmentActions::
  setSPAQ (const SPAQType& x)
  {
    this->SPAQ_.set (x);
  }

  void TreatmentActions::
  setSPAQ (const SPAQOptional& x)
  {
    this->SPAQ_ = x;
  }

  void TreatmentActions::
  setSPAQ (::std::unique_ptr< SPAQType > x)
  {
    this->SPAQ_.set (std::move (x));
  }

  const TreatmentActions::ACTOptional& TreatmentActions::
  getACT () const
  {
    return this->ACT_;
  }

  TreatmentActions::ACTOptional& TreatmentActions::
  getACT ()
  {
    return this->ACT_;
  }

  void TreatmentActions::
  setACT (const ACTType& x)
  {
    this->ACT_.set (x);
  }

  void TreatmentActions::
  setACT (const ACTOptional& x)
  {
    this->ACT_ = x;
  }

  void TreatmentActions::
  setACT (::std::unique_ptr< ACTType > x)
  {
    this->ACT_.set (std::move (x));
  }

  const TreatmentActions::QNOptional& TreatmentActions::
  getQN () const
  {
    return this->QN_;
  }

  TreatmentActions::QNOptional& TreatmentActions::
  getQN ()
  {
    return this->QN_;
  }

  void TreatmentActions::
  setQN (const QNType& x)
  {
    this->QN_.set (x);
  }

  void TreatmentActions::
  setQN (const QNOptional& x)
  {
    this->QN_ = x;
  }

  void TreatmentActions::
  setQN (::std::unique_ptr< QNType > x)
  {
    this->QN_.set (std::move (x));
  }


  // Outcome
  // 

  const Outcome::PType& Outcome::
  getP () const
  {
    return this->p_.get ();
  }

  Outcome::PType& Outcome::
  getP ()
  {
    return this->p_.get ();
  }

  void Outcome::
  setP (const PType& x)
  {
    this->p_.set (x);
  }


  // Age
  // 

  const Age::LbType& Age::
  getLb () const
  {
    return this->lb_.get ();
  }

  Age::LbType& Age::
  getLb ()
  {
    return this->lb_.get ();
  }

  void Age::
  setLb (const LbType& x)
  {
    this->lb_.set (x);
  }


  // ClearInfections
  // 

  const ClearInfections::TimestepsType& ClearInfections::
  getTimesteps () const
  {
    return this->timesteps_.get ();
  }

  ClearInfections::TimestepsType& ClearInfections::
  getTimesteps ()
  {
    return this->timesteps_.get ();
  }

  void ClearInfections::
  setTimesteps (const TimestepsType& x)
  {
    this->timesteps_.set (x);
  }

  void ClearInfections::
  setTimesteps (::std::unique_ptr< TimestepsType > x)
  {
    this->timesteps_.set (std::move (x));
  }

  const ClearInfections::StageType& ClearInfections::
  getStage () const
  {
    return this->stage_.get ();
  }

  ClearInfections::StageType& ClearInfections::
  getStage ()
  {
    return this->stage_.get ();
  }

  void ClearInfections::
  setStage (const StageType& x)
  {
    this->stage_.set (x);
  }

  void ClearInfections::
  setStage (::std::unique_ptr< StageType > x)
  {
    this->stage_.set (std::move (x));
  }


  // Stage
  // 

  Stage::
  Stage (Value v)
  : ::xml_schema::String (_xsd_Stage_literals_[v])
  {
  }

  Stage::
  Stage (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Stage::
  Stage (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Stage::
  Stage (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Stage::
  Stage (const Stage& v,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Stage& Stage::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Stage_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace scnXml
{
  // Clinical
  //

  Clinical::
  Clinical (const HealthSystemMemoryType& healthSystemMemory)
  : ::xml_schema::Type (),
    NeonatalMortality_ (this),
    NonMalariaFevers_ (this),
    healthSystemMemory_ (healthSystemMemory, this)
  {
  }

  Clinical::
  Clinical (const Clinical& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    NeonatalMortality_ (x.NeonatalMortality_, f, this),
    NonMalariaFevers_ (x.NonMalariaFevers_, f, this),
    healthSystemMemory_ (x.healthSystemMemory_, f, this)
  {
  }

  Clinical::
  Clinical (const xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    NeonatalMortality_ (this),
    NonMalariaFevers_ (this),
    healthSystemMemory_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Clinical::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // NeonatalMortality
      //
      if (n.name () == "NeonatalMortality" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< NeonatalMortalityType > r (
          NeonatalMortalityTraits::create (i, f, this));

        if (!this->NeonatalMortality_)
        {
          this->NeonatalMortality_.set (::std::move (r));
          continue;
        }
      }

      // NonMalariaFevers
      //
      if (n.name () == "NonMalariaFevers" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< NonMalariaFeversType > r (
          NonMalariaFeversTraits::create (i, f, this));

        if (!this->NonMalariaFevers_)
        {
          this->NonMalariaFevers_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "healthSystemMemory" && n.namespace_ ().empty ())
      {
        this->healthSystemMemory_.set (HealthSystemMemoryTraits::create (i, f, this));
        continue;
      }
    }

    if (!healthSystemMemory_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "healthSystemMemory",
        "");
    }
  }

  Clinical* Clinical::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Clinical (*this, f, c);
  }

  Clinical& Clinical::
  operator= (const Clinical& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->NeonatalMortality_ = x.NeonatalMortality_;
      this->NonMalariaFevers_ = x.NonMalariaFevers_;
      this->healthSystemMemory_ = x.healthSystemMemory_;
    }

    return *this;
  }

  Clinical::
  ~Clinical ()
  {
  }

  // HealthSystem
  //

  HealthSystem::
  HealthSystem (const CFRType& CFR,
                const PSequelaeInpatientType& pSequelaeInpatient)
  : ::xml_schema::Type (),
    EventScheduler_ (this),
    ImmediateOutcomes_ (this),
    DecisionTree5Day_ (this),
    CFR_ (CFR, this),
    pSequelaeInpatient_ (pSequelaeInpatient, this)
  {
  }

  HealthSystem::
  HealthSystem (::std::unique_ptr< CFRType > CFR,
                ::std::unique_ptr< PSequelaeInpatientType > pSequelaeInpatient)
  : ::xml_schema::Type (),
    EventScheduler_ (this),
    ImmediateOutcomes_ (this),
    DecisionTree5Day_ (this),
    CFR_ (std::move (CFR), this),
    pSequelaeInpatient_ (std::move (pSequelaeInpatient), this)
  {
  }

  HealthSystem::
  HealthSystem (const HealthSystem& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    EventScheduler_ (x.EventScheduler_, f, this),
    ImmediateOutcomes_ (x.ImmediateOutcomes_, f, this),
    DecisionTree5Day_ (x.DecisionTree5Day_, f, this),
    CFR_ (x.CFR_, f, this),
    pSequelaeInpatient_ (x.pSequelaeInpatient_, f, this)
  {
  }

  HealthSystem::
  HealthSystem (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    EventScheduler_ (this),
    ImmediateOutcomes_ (this),
    DecisionTree5Day_ (this),
    CFR_ (this),
    pSequelaeInpatient_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void HealthSystem::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // EventScheduler
      //
      if (n.name () == "EventScheduler" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< EventSchedulerType > r (
          EventSchedulerTraits::create (i, f, this));

        if (!this->EventScheduler_)
        {
          this->EventScheduler_.set (::std::move (r));
          continue;
        }
      }

      // ImmediateOutcomes
      //
      if (n.name () == "ImmediateOutcomes" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ImmediateOutcomesType > r (
          ImmediateOutcomesTraits::create (i, f, this));

        if (!this->ImmediateOutcomes_)
        {
          this->ImmediateOutcomes_.set (::std::move (r));
          continue;
        }
      }

      // DecisionTree5Day
      //
      if (n.name () == "DecisionTree5Day" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DecisionTree5DayType > r (
          DecisionTree5DayTraits::create (i, f, this));

        if (!this->DecisionTree5Day_)
        {
          this->DecisionTree5Day_.set (::std::move (r));
          continue;
        }
      }

      // CFR
      //
      if (n.name () == "CFR" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< CFRType > r (
          CFRTraits::create (i, f, this));

        if (!CFR_.present ())
        {
          this->CFR_.set (::std::move (r));
          continue;
        }
      }

      // pSequelaeInpatient
      //
      if (n.name () == "pSequelaeInpatient" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PSequelaeInpatientType > r (
          PSequelaeInpatientTraits::create (i, f, this));

        if (!pSequelaeInpatient_.present ())
        {
          this->pSequelaeInpatient_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!CFR_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CFR",
        "");
    }

    if (!pSequelaeInpatient_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pSequelaeInpatient",
        "");
    }
  }

  HealthSystem* HealthSystem::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HealthSystem (*this, f, c);
  }

  HealthSystem& HealthSystem::
  operator= (const HealthSystem& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->EventScheduler_ = x.EventScheduler_;
      this->ImmediateOutcomes_ = x.ImmediateOutcomes_;
      this->DecisionTree5Day_ = x.DecisionTree5Day_;
      this->CFR_ = x.CFR_;
      this->pSequelaeInpatient_ = x.pSequelaeInpatient_;
    }

    return *this;
  }

  HealthSystem::
  ~HealthSystem ()
  {
  }

  // LiverStageDrug
  //

  LiverStageDrug::
  LiverStageDrug (const PHumanCannotReceiveType& pHumanCannotReceive,
                  const EffectivenessOnUseType& effectivenessOnUse)
  : ::xml_schema::Type (),
    pHumanCannotReceive_ (pHumanCannotReceive, this),
    ignoreCannotReceive_ (this),
    pUseUncomplicated_ (this),
    effectivenessOnUse_ (effectivenessOnUse, this)
  {
  }

  LiverStageDrug::
  LiverStageDrug (::std::unique_ptr< PHumanCannotReceiveType > pHumanCannotReceive,
                  ::std::unique_ptr< EffectivenessOnUseType > effectivenessOnUse)
  : ::xml_schema::Type (),
    pHumanCannotReceive_ (std::move (pHumanCannotReceive), this),
    ignoreCannotReceive_ (this),
    pUseUncomplicated_ (this),
    effectivenessOnUse_ (std::move (effectivenessOnUse), this)
  {
  }

  LiverStageDrug::
  LiverStageDrug (const LiverStageDrug& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    pHumanCannotReceive_ (x.pHumanCannotReceive_, f, this),
    ignoreCannotReceive_ (x.ignoreCannotReceive_, f, this),
    pUseUncomplicated_ (x.pUseUncomplicated_, f, this),
    effectivenessOnUse_ (x.effectivenessOnUse_, f, this)
  {
  }

  LiverStageDrug::
  LiverStageDrug (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    pHumanCannotReceive_ (this),
    ignoreCannotReceive_ (this),
    pUseUncomplicated_ (this),
    effectivenessOnUse_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void LiverStageDrug::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // pHumanCannotReceive
      //
      if (n.name () == "pHumanCannotReceive" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PHumanCannotReceiveType > r (
          PHumanCannotReceiveTraits::create (i, f, this));

        if (!pHumanCannotReceive_.present ())
        {
          this->pHumanCannotReceive_.set (::std::move (r));
          continue;
        }
      }

      // ignoreCannotReceive
      //
      if (n.name () == "ignoreCannotReceive" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< IgnoreCannotReceiveType > r (
          IgnoreCannotReceiveTraits::create (i, f, this));

        if (!this->ignoreCannotReceive_)
        {
          this->ignoreCannotReceive_.set (::std::move (r));
          continue;
        }
      }

      // pUseUncomplicated
      //
      if (n.name () == "pUseUncomplicated" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PUseUncomplicatedType > r (
          PUseUncomplicatedTraits::create (i, f, this));

        if (!this->pUseUncomplicated_)
        {
          this->pUseUncomplicated_.set (::std::move (r));
          continue;
        }
      }

      // effectivenessOnUse
      //
      if (n.name () == "effectivenessOnUse" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< EffectivenessOnUseType > r (
          EffectivenessOnUseTraits::create (i, f, this));

        if (!effectivenessOnUse_.present ())
        {
          this->effectivenessOnUse_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!pHumanCannotReceive_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pHumanCannotReceive",
        "");
    }

    if (!effectivenessOnUse_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "effectivenessOnUse",
        "");
    }
  }

  LiverStageDrug* LiverStageDrug::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class LiverStageDrug (*this, f, c);
  }

  LiverStageDrug& LiverStageDrug::
  operator= (const LiverStageDrug& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->pHumanCannotReceive_ = x.pHumanCannotReceive_;
      this->ignoreCannotReceive_ = x.ignoreCannotReceive_;
      this->pUseUncomplicated_ = x.pUseUncomplicated_;
      this->effectivenessOnUse_ = x.effectivenessOnUse_;
    }

    return *this;
  }

  LiverStageDrug::
  ~LiverStageDrug ()
  {
  }

  // HSImmediateOutcomes
  //

  HSImmediateOutcomes::
  HSImmediateOutcomes (const DrugRegimenType& drugRegimen,
                       const InitialACRType& initialACR,
                       const ComplianceType& compliance,
                       const NonCompliersEffectiveType& nonCompliersEffective,
                       const TreatmentActionsType& treatmentActions,
                       const PSeekOfficialCareUncomplicated1Type& pSeekOfficialCareUncomplicated1,
                       const PSelfTreatUncomplicatedType& pSelfTreatUncomplicated,
                       const PSeekOfficialCareUncomplicated2Type& pSeekOfficialCareUncomplicated2,
                       const PSeekOfficialCareSevereType& pSeekOfficialCareSevere)
  : ::xml_schema::Type (),
    drugRegimen_ (drugRegimen, this),
    initialACR_ (initialACR, this),
    compliance_ (compliance, this),
    nonCompliersEffective_ (nonCompliersEffective, this),
    treatmentActions_ (treatmentActions, this),
    pSeekOfficialCareUncomplicated1_ (pSeekOfficialCareUncomplicated1, this),
    pSelfTreatUncomplicated_ (pSelfTreatUncomplicated, this),
    pSeekOfficialCareUncomplicated2_ (pSeekOfficialCareUncomplicated2, this),
    pSeekOfficialCareSevere_ (pSeekOfficialCareSevere, this),
    liverStageDrug_ (this),
    name_ (this),
    useDiagnosticUC_ (getUseDiagnosticUCDefaultValue (), this)
  {
  }

  HSImmediateOutcomes::
  HSImmediateOutcomes (::std::unique_ptr< DrugRegimenType > drugRegimen,
                       ::std::unique_ptr< InitialACRType > initialACR,
                       ::std::unique_ptr< ComplianceType > compliance,
                       ::std::unique_ptr< NonCompliersEffectiveType > nonCompliersEffective,
                       ::std::unique_ptr< TreatmentActionsType > treatmentActions,
                       ::std::unique_ptr< PSeekOfficialCareUncomplicated1Type > pSeekOfficialCareUncomplicated1,
                       ::std::unique_ptr< PSelfTreatUncomplicatedType > pSelfTreatUncomplicated,
                       ::std::unique_ptr< PSeekOfficialCareUncomplicated2Type > pSeekOfficialCareUncomplicated2,
                       ::std::unique_ptr< PSeekOfficialCareSevereType > pSeekOfficialCareSevere)
  : ::xml_schema::Type (),
    drugRegimen_ (std::move (drugRegimen), this),
    initialACR_ (std::move (initialACR), this),
    compliance_ (std::move (compliance), this),
    nonCompliersEffective_ (std::move (nonCompliersEffective), this),
    treatmentActions_ (std::move (treatmentActions), this),
    pSeekOfficialCareUncomplicated1_ (std::move (pSeekOfficialCareUncomplicated1), this),
    pSelfTreatUncomplicated_ (std::move (pSelfTreatUncomplicated), this),
    pSeekOfficialCareUncomplicated2_ (std::move (pSeekOfficialCareUncomplicated2), this),
    pSeekOfficialCareSevere_ (std::move (pSeekOfficialCareSevere), this),
    liverStageDrug_ (this),
    name_ (this),
    useDiagnosticUC_ (getUseDiagnosticUCDefaultValue (), this)
  {
  }

  HSImmediateOutcomes::
  HSImmediateOutcomes (const HSImmediateOutcomes& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    drugRegimen_ (x.drugRegimen_, f, this),
    initialACR_ (x.initialACR_, f, this),
    compliance_ (x.compliance_, f, this),
    nonCompliersEffective_ (x.nonCompliersEffective_, f, this),
    treatmentActions_ (x.treatmentActions_, f, this),
    pSeekOfficialCareUncomplicated1_ (x.pSeekOfficialCareUncomplicated1_, f, this),
    pSelfTreatUncomplicated_ (x.pSelfTreatUncomplicated_, f, this),
    pSeekOfficialCareUncomplicated2_ (x.pSeekOfficialCareUncomplicated2_, f, this),
    pSeekOfficialCareSevere_ (x.pSeekOfficialCareSevere_, f, this),
    liverStageDrug_ (x.liverStageDrug_, f, this),
    name_ (x.name_, f, this),
    useDiagnosticUC_ (x.useDiagnosticUC_, f, this)
  {
  }

  HSImmediateOutcomes::
  HSImmediateOutcomes (const xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    drugRegimen_ (this),
    initialACR_ (this),
    compliance_ (this),
    nonCompliersEffective_ (this),
    treatmentActions_ (this),
    pSeekOfficialCareUncomplicated1_ (this),
    pSelfTreatUncomplicated_ (this),
    pSeekOfficialCareUncomplicated2_ (this),
    pSeekOfficialCareSevere_ (this),
    liverStageDrug_ (this),
    name_ (this),
    useDiagnosticUC_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void HSImmediateOutcomes::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // drugRegimen
      //
      if (n.name () == "drugRegimen" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DrugRegimenType > r (
          DrugRegimenTraits::create (i, f, this));

        if (!drugRegimen_.present ())
        {
          this->drugRegimen_.set (::std::move (r));
          continue;
        }
      }

      // initialACR
      //
      if (n.name () == "initialACR" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< InitialACRType > r (
          InitialACRTraits::create (i, f, this));

        if (!initialACR_.present ())
        {
          this->initialACR_.set (::std::move (r));
          continue;
        }
      }

      // compliance
      //
      if (n.name () == "compliance" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ComplianceType > r (
          ComplianceTraits::create (i, f, this));

        if (!compliance_.present ())
        {
          this->compliance_.set (::std::move (r));
          continue;
        }
      }

      // nonCompliersEffective
      //
      if (n.name () == "nonCompliersEffective" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< NonCompliersEffectiveType > r (
          NonCompliersEffectiveTraits::create (i, f, this));

        if (!nonCompliersEffective_.present ())
        {
          this->nonCompliersEffective_.set (::std::move (r));
          continue;
        }
      }

      // treatmentActions
      //
      if (n.name () == "treatmentActions" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TreatmentActionsType > r (
          TreatmentActionsTraits::create (i, f, this));

        if (!treatmentActions_.present ())
        {
          this->treatmentActions_.set (::std::move (r));
          continue;
        }
      }

      // pSeekOfficialCareUncomplicated1
      //
      if (n.name () == "pSeekOfficialCareUncomplicated1" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PSeekOfficialCareUncomplicated1Type > r (
          PSeekOfficialCareUncomplicated1Traits::create (i, f, this));

        if (!pSeekOfficialCareUncomplicated1_.present ())
        {
          this->pSeekOfficialCareUncomplicated1_.set (::std::move (r));
          continue;
        }
      }

      // pSelfTreatUncomplicated
      //
      if (n.name () == "pSelfTreatUncomplicated" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PSelfTreatUncomplicatedType > r (
          PSelfTreatUncomplicatedTraits::create (i, f, this));

        if (!pSelfTreatUncomplicated_.present ())
        {
          this->pSelfTreatUncomplicated_.set (::std::move (r));
          continue;
        }
      }

      // pSeekOfficialCareUncomplicated2
      //
      if (n.name () == "pSeekOfficialCareUncomplicated2" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PSeekOfficialCareUncomplicated2Type > r (
          PSeekOfficialCareUncomplicated2Traits::create (i, f, this));

        if (!pSeekOfficialCareUncomplicated2_.present ())
        {
          this->pSeekOfficialCareUncomplicated2_.set (::std::move (r));
          continue;
        }
      }

      // pSeekOfficialCareSevere
      //
      if (n.name () == "pSeekOfficialCareSevere" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PSeekOfficialCareSevereType > r (
          PSeekOfficialCareSevereTraits::create (i, f, this));

        if (!pSeekOfficialCareSevere_.present ())
        {
          this->pSeekOfficialCareSevere_.set (::std::move (r));
          continue;
        }
      }

      // liverStageDrug
      //
      if (n.name () == "liverStageDrug" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< LiverStageDrugType > r (
          LiverStageDrugTraits::create (i, f, this));

        if (!this->liverStageDrug_)
        {
          this->liverStageDrug_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!drugRegimen_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "drugRegimen",
        "");
    }

    if (!initialACR_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "initialACR",
        "");
    }

    if (!compliance_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "compliance",
        "");
    }

    if (!nonCompliersEffective_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "nonCompliersEffective",
        "");
    }

    if (!treatmentActions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "treatmentActions",
        "");
    }

    if (!pSeekOfficialCareUncomplicated1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pSeekOfficialCareUncomplicated1",
        "");
    }

    if (!pSelfTreatUncomplicated_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pSelfTreatUncomplicated",
        "");
    }

    if (!pSeekOfficialCareUncomplicated2_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pSeekOfficialCareUncomplicated2",
        "");
    }

    if (!pSeekOfficialCareSevere_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pSeekOfficialCareSevere",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "useDiagnosticUC" && n.namespace_ ().empty ())
      {
        this->useDiagnosticUC_.set (UseDiagnosticUCTraits::create (i, f, this));
        continue;
      }
    }

    if (!useDiagnosticUC_.present ())
    {
      this->useDiagnosticUC_.set (getUseDiagnosticUCDefaultValue ());
    }
  }

  HSImmediateOutcomes* HSImmediateOutcomes::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HSImmediateOutcomes (*this, f, c);
  }

  HSImmediateOutcomes& HSImmediateOutcomes::
  operator= (const HSImmediateOutcomes& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->drugRegimen_ = x.drugRegimen_;
      this->initialACR_ = x.initialACR_;
      this->compliance_ = x.compliance_;
      this->nonCompliersEffective_ = x.nonCompliersEffective_;
      this->treatmentActions_ = x.treatmentActions_;
      this->pSeekOfficialCareUncomplicated1_ = x.pSeekOfficialCareUncomplicated1_;
      this->pSelfTreatUncomplicated_ = x.pSelfTreatUncomplicated_;
      this->pSeekOfficialCareUncomplicated2_ = x.pSeekOfficialCareUncomplicated2_;
      this->pSeekOfficialCareSevere_ = x.pSeekOfficialCareSevere_;
      this->liverStageDrug_ = x.liverStageDrug_;
      this->name_ = x.name_;
      this->useDiagnosticUC_ = x.useDiagnosticUC_;
    }

    return *this;
  }

  HSImmediateOutcomes::
  ~HSImmediateOutcomes ()
  {
  }

  // TreatmentDetails
  //

  TreatmentDetails::
  TreatmentDetails (const SelfTreatmentType& selfTreatment)
  : ::xml_schema::Type (),
    CQ_ (this),
    SP_ (this),
    AQ_ (this),
    SPAQ_ (this),
    ACT_ (this),
    QN_ (this),
    selfTreatment_ (selfTreatment, this)
  {
  }

  TreatmentDetails::
  TreatmentDetails (::std::unique_ptr< SelfTreatmentType > selfTreatment)
  : ::xml_schema::Type (),
    CQ_ (this),
    SP_ (this),
    AQ_ (this),
    SPAQ_ (this),
    ACT_ (this),
    QN_ (this),
    selfTreatment_ (std::move (selfTreatment), this)
  {
  }

  TreatmentDetails::
  TreatmentDetails (const TreatmentDetails& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    CQ_ (x.CQ_, f, this),
    SP_ (x.SP_, f, this),
    AQ_ (x.AQ_, f, this),
    SPAQ_ (x.SPAQ_, f, this),
    ACT_ (x.ACT_, f, this),
    QN_ (x.QN_, f, this),
    selfTreatment_ (x.selfTreatment_, f, this)
  {
  }

  TreatmentDetails::
  TreatmentDetails (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    CQ_ (this),
    SP_ (this),
    AQ_ (this),
    SPAQ_ (this),
    ACT_ (this),
    QN_ (this),
    selfTreatment_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TreatmentDetails::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CQ
      //
      if (n.name () == "CQ" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< CQType > r (
          CQTraits::create (i, f, this));

        if (!this->CQ_)
        {
          this->CQ_.set (::std::move (r));
          continue;
        }
      }

      // SP
      //
      if (n.name () == "SP" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SPType > r (
          SPTraits::create (i, f, this));

        if (!this->SP_)
        {
          this->SP_.set (::std::move (r));
          continue;
        }
      }

      // AQ
      //
      if (n.name () == "AQ" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AQType > r (
          AQTraits::create (i, f, this));

        if (!this->AQ_)
        {
          this->AQ_.set (::std::move (r));
          continue;
        }
      }

      // SPAQ
      //
      if (n.name () == "SPAQ" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SPAQType > r (
          SPAQTraits::create (i, f, this));

        if (!this->SPAQ_)
        {
          this->SPAQ_.set (::std::move (r));
          continue;
        }
      }

      // ACT
      //
      if (n.name () == "ACT" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ACTType > r (
          ACTTraits::create (i, f, this));

        if (!this->ACT_)
        {
          this->ACT_.set (::std::move (r));
          continue;
        }
      }

      // QN
      //
      if (n.name () == "QN" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< QNType > r (
          QNTraits::create (i, f, this));

        if (!this->QN_)
        {
          this->QN_.set (::std::move (r));
          continue;
        }
      }

      // selfTreatment
      //
      if (n.name () == "selfTreatment" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SelfTreatmentType > r (
          SelfTreatmentTraits::create (i, f, this));

        if (!selfTreatment_.present ())
        {
          this->selfTreatment_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!selfTreatment_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "selfTreatment",
        "");
    }
  }

  TreatmentDetails* TreatmentDetails::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TreatmentDetails (*this, f, c);
  }

  TreatmentDetails& TreatmentDetails::
  operator= (const TreatmentDetails& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->CQ_ = x.CQ_;
      this->SP_ = x.SP_;
      this->AQ_ = x.AQ_;
      this->SPAQ_ = x.SPAQ_;
      this->ACT_ = x.ACT_;
      this->QN_ = x.QN_;
      this->selfTreatment_ = x.selfTreatment_;
    }

    return *this;
  }

  TreatmentDetails::
  ~TreatmentDetails ()
  {
  }

  // HSDT5Day
  //

  HSDT5Day::
  HSDT5Day (const PSeekOfficialCareUncomplicated1Type& pSeekOfficialCareUncomplicated1,
            const PSelfTreatUncomplicatedType& pSelfTreatUncomplicated,
            const PSeekOfficialCareUncomplicated2Type& pSeekOfficialCareUncomplicated2,
            const PSeekOfficialCareSevereType& pSeekOfficialCareSevere,
            const TreeUCOfficialType& treeUCOfficial,
            const TreeUCSelfTreatType& treeUCSelfTreat,
            const CureRateSevereType& cureRateSevere,
            const TreatmentSevereType& treatmentSevere)
  : ::xml_schema::Type (),
    pSeekOfficialCareUncomplicated1_ (pSeekOfficialCareUncomplicated1, this),
    pSelfTreatUncomplicated_ (pSelfTreatUncomplicated, this),
    pSeekOfficialCareUncomplicated2_ (pSeekOfficialCareUncomplicated2, this),
    pSeekOfficialCareSevere_ (pSeekOfficialCareSevere, this),
    liverStageDrug_ (this),
    treeUCOfficial_ (treeUCOfficial, this),
    treeUCSelfTreat_ (treeUCSelfTreat, this),
    cureRateSevere_ (cureRateSevere, this),
    treatmentSevere_ (treatmentSevere, this),
    name_ (this)
  {
  }

  HSDT5Day::
  HSDT5Day (::std::unique_ptr< PSeekOfficialCareUncomplicated1Type > pSeekOfficialCareUncomplicated1,
            ::std::unique_ptr< PSelfTreatUncomplicatedType > pSelfTreatUncomplicated,
            ::std::unique_ptr< PSeekOfficialCareUncomplicated2Type > pSeekOfficialCareUncomplicated2,
            ::std::unique_ptr< PSeekOfficialCareSevereType > pSeekOfficialCareSevere,
            ::std::unique_ptr< TreeUCOfficialType > treeUCOfficial,
            ::std::unique_ptr< TreeUCSelfTreatType > treeUCSelfTreat,
            ::std::unique_ptr< CureRateSevereType > cureRateSevere,
            ::std::unique_ptr< TreatmentSevereType > treatmentSevere)
  : ::xml_schema::Type (),
    pSeekOfficialCareUncomplicated1_ (std::move (pSeekOfficialCareUncomplicated1), this),
    pSelfTreatUncomplicated_ (std::move (pSelfTreatUncomplicated), this),
    pSeekOfficialCareUncomplicated2_ (std::move (pSeekOfficialCareUncomplicated2), this),
    pSeekOfficialCareSevere_ (std::move (pSeekOfficialCareSevere), this),
    liverStageDrug_ (this),
    treeUCOfficial_ (std::move (treeUCOfficial), this),
    treeUCSelfTreat_ (std::move (treeUCSelfTreat), this),
    cureRateSevere_ (std::move (cureRateSevere), this),
    treatmentSevere_ (std::move (treatmentSevere), this),
    name_ (this)
  {
  }

  HSDT5Day::
  HSDT5Day (const HSDT5Day& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    pSeekOfficialCareUncomplicated1_ (x.pSeekOfficialCareUncomplicated1_, f, this),
    pSelfTreatUncomplicated_ (x.pSelfTreatUncomplicated_, f, this),
    pSeekOfficialCareUncomplicated2_ (x.pSeekOfficialCareUncomplicated2_, f, this),
    pSeekOfficialCareSevere_ (x.pSeekOfficialCareSevere_, f, this),
    liverStageDrug_ (x.liverStageDrug_, f, this),
    treeUCOfficial_ (x.treeUCOfficial_, f, this),
    treeUCSelfTreat_ (x.treeUCSelfTreat_, f, this),
    cureRateSevere_ (x.cureRateSevere_, f, this),
    treatmentSevere_ (x.treatmentSevere_, f, this),
    name_ (x.name_, f, this)
  {
  }

  HSDT5Day::
  HSDT5Day (const xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    pSeekOfficialCareUncomplicated1_ (this),
    pSelfTreatUncomplicated_ (this),
    pSeekOfficialCareUncomplicated2_ (this),
    pSeekOfficialCareSevere_ (this),
    liverStageDrug_ (this),
    treeUCOfficial_ (this),
    treeUCSelfTreat_ (this),
    cureRateSevere_ (this),
    treatmentSevere_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void HSDT5Day::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // pSeekOfficialCareUncomplicated1
      //
      if (n.name () == "pSeekOfficialCareUncomplicated1" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PSeekOfficialCareUncomplicated1Type > r (
          PSeekOfficialCareUncomplicated1Traits::create (i, f, this));

        if (!pSeekOfficialCareUncomplicated1_.present ())
        {
          this->pSeekOfficialCareUncomplicated1_.set (::std::move (r));
          continue;
        }
      }

      // pSelfTreatUncomplicated
      //
      if (n.name () == "pSelfTreatUncomplicated" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PSelfTreatUncomplicatedType > r (
          PSelfTreatUncomplicatedTraits::create (i, f, this));

        if (!pSelfTreatUncomplicated_.present ())
        {
          this->pSelfTreatUncomplicated_.set (::std::move (r));
          continue;
        }
      }

      // pSeekOfficialCareUncomplicated2
      //
      if (n.name () == "pSeekOfficialCareUncomplicated2" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PSeekOfficialCareUncomplicated2Type > r (
          PSeekOfficialCareUncomplicated2Traits::create (i, f, this));

        if (!pSeekOfficialCareUncomplicated2_.present ())
        {
          this->pSeekOfficialCareUncomplicated2_.set (::std::move (r));
          continue;
        }
      }

      // pSeekOfficialCareSevere
      //
      if (n.name () == "pSeekOfficialCareSevere" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PSeekOfficialCareSevereType > r (
          PSeekOfficialCareSevereTraits::create (i, f, this));

        if (!pSeekOfficialCareSevere_.present ())
        {
          this->pSeekOfficialCareSevere_.set (::std::move (r));
          continue;
        }
      }

      // liverStageDrug
      //
      if (n.name () == "liverStageDrug" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< LiverStageDrugType > r (
          LiverStageDrugTraits::create (i, f, this));

        if (!this->liverStageDrug_)
        {
          this->liverStageDrug_.set (::std::move (r));
          continue;
        }
      }

      // treeUCOfficial
      //
      if (n.name () == "treeUCOfficial" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TreeUCOfficialType > r (
          TreeUCOfficialTraits::create (i, f, this));

        if (!treeUCOfficial_.present ())
        {
          this->treeUCOfficial_.set (::std::move (r));
          continue;
        }
      }

      // treeUCSelfTreat
      //
      if (n.name () == "treeUCSelfTreat" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TreeUCSelfTreatType > r (
          TreeUCSelfTreatTraits::create (i, f, this));

        if (!treeUCSelfTreat_.present ())
        {
          this->treeUCSelfTreat_.set (::std::move (r));
          continue;
        }
      }

      // cureRateSevere
      //
      if (n.name () == "cureRateSevere" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< CureRateSevereType > r (
          CureRateSevereTraits::create (i, f, this));

        if (!cureRateSevere_.present ())
        {
          this->cureRateSevere_.set (::std::move (r));
          continue;
        }
      }

      // treatmentSevere
      //
      if (n.name () == "treatmentSevere" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TreatmentSevereType > r (
          TreatmentSevereTraits::create (i, f, this));

        if (!treatmentSevere_.present ())
        {
          this->treatmentSevere_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!pSeekOfficialCareUncomplicated1_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pSeekOfficialCareUncomplicated1",
        "");
    }

    if (!pSelfTreatUncomplicated_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pSelfTreatUncomplicated",
        "");
    }

    if (!pSeekOfficialCareUncomplicated2_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pSeekOfficialCareUncomplicated2",
        "");
    }

    if (!pSeekOfficialCareSevere_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pSeekOfficialCareSevere",
        "");
    }

    if (!treeUCOfficial_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "treeUCOfficial",
        "");
    }

    if (!treeUCSelfTreat_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "treeUCSelfTreat",
        "");
    }

    if (!cureRateSevere_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "cureRateSevere",
        "");
    }

    if (!treatmentSevere_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "treatmentSevere",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  HSDT5Day* HSDT5Day::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HSDT5Day (*this, f, c);
  }

  HSDT5Day& HSDT5Day::
  operator= (const HSDT5Day& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->pSeekOfficialCareUncomplicated1_ = x.pSeekOfficialCareUncomplicated1_;
      this->pSelfTreatUncomplicated_ = x.pSelfTreatUncomplicated_;
      this->pSeekOfficialCareUncomplicated2_ = x.pSeekOfficialCareUncomplicated2_;
      this->pSeekOfficialCareSevere_ = x.pSeekOfficialCareSevere_;
      this->liverStageDrug_ = x.liverStageDrug_;
      this->treeUCOfficial_ = x.treeUCOfficial_;
      this->treeUCSelfTreat_ = x.treeUCSelfTreat_;
      this->cureRateSevere_ = x.cureRateSevere_;
      this->treatmentSevere_ = x.treatmentSevere_;
      this->name_ = x.name_;
    }

    return *this;
  }

  HSDT5Day::
  ~HSDT5Day ()
  {
  }

  // HSEventScheduler
  //

  HSEventScheduler::
  HSEventScheduler (const UncomplicatedType& uncomplicated,
                    const ComplicatedType& complicated,
                    const ClinicalOutcomesType& ClinicalOutcomes)
  : ::xml_schema::Type (),
    uncomplicated_ (uncomplicated, this),
    complicated_ (complicated, this),
    ClinicalOutcomes_ (ClinicalOutcomes, this),
    NonMalariaFevers_ (this)
  {
  }

  HSEventScheduler::
  HSEventScheduler (::std::unique_ptr< UncomplicatedType > uncomplicated,
                    ::std::unique_ptr< ComplicatedType > complicated,
                    ::std::unique_ptr< ClinicalOutcomesType > ClinicalOutcomes)
  : ::xml_schema::Type (),
    uncomplicated_ (std::move (uncomplicated), this),
    complicated_ (std::move (complicated), this),
    ClinicalOutcomes_ (std::move (ClinicalOutcomes), this),
    NonMalariaFevers_ (this)
  {
  }

  HSEventScheduler::
  HSEventScheduler (const HSEventScheduler& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    uncomplicated_ (x.uncomplicated_, f, this),
    complicated_ (x.complicated_, f, this),
    ClinicalOutcomes_ (x.ClinicalOutcomes_, f, this),
    NonMalariaFevers_ (x.NonMalariaFevers_, f, this)
  {
  }

  HSEventScheduler::
  HSEventScheduler (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    uncomplicated_ (this),
    complicated_ (this),
    ClinicalOutcomes_ (this),
    NonMalariaFevers_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void HSEventScheduler::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // uncomplicated
      //
      if (n.name () == "uncomplicated" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< UncomplicatedType > r (
          UncomplicatedTraits::create (i, f, this));

        if (!uncomplicated_.present ())
        {
          this->uncomplicated_.set (::std::move (r));
          continue;
        }
      }

      // complicated
      //
      if (n.name () == "complicated" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ComplicatedType > r (
          ComplicatedTraits::create (i, f, this));

        if (!complicated_.present ())
        {
          this->complicated_.set (::std::move (r));
          continue;
        }
      }

      // ClinicalOutcomes
      //
      if (n.name () == "ClinicalOutcomes" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ClinicalOutcomesType > r (
          ClinicalOutcomesTraits::create (i, f, this));

        if (!ClinicalOutcomes_.present ())
        {
          this->ClinicalOutcomes_.set (::std::move (r));
          continue;
        }
      }

      // NonMalariaFevers
      //
      if (n.name () == "NonMalariaFevers" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< NonMalariaFeversType > r (
          NonMalariaFeversTraits::create (i, f, this));

        if (!this->NonMalariaFevers_)
        {
          this->NonMalariaFevers_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!uncomplicated_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "uncomplicated",
        "");
    }

    if (!complicated_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "complicated",
        "");
    }

    if (!ClinicalOutcomes_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ClinicalOutcomes",
        "");
    }
  }

  HSEventScheduler* HSEventScheduler::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HSEventScheduler (*this, f, c);
  }

  HSEventScheduler& HSEventScheduler::
  operator= (const HSEventScheduler& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->uncomplicated_ = x.uncomplicated_;
      this->complicated_ = x.complicated_;
      this->ClinicalOutcomes_ = x.ClinicalOutcomes_;
      this->NonMalariaFevers_ = x.NonMalariaFevers_;
    }

    return *this;
  }

  HSEventScheduler::
  ~HSEventScheduler ()
  {
  }

  // ClinicalOutcomes
  //

  ClinicalOutcomes::
  ClinicalOutcomes (const MaxUCSeekingMemoryType& maxUCSeekingMemory,
                    const UncomplicatedCaseDurationType& uncomplicatedCaseDuration,
                    const ComplicatedCaseDurationType& complicatedCaseDuration,
                    const ComplicatedRiskDurationType& complicatedRiskDuration)
  : ::xml_schema::Type (),
    maxUCSeekingMemory_ (maxUCSeekingMemory, this),
    uncomplicatedCaseDuration_ (uncomplicatedCaseDuration, this),
    complicatedCaseDuration_ (complicatedCaseDuration, this),
    complicatedRiskDuration_ (complicatedRiskDuration, this),
    dailyPrImmUCTS_ (this)
  {
  }

  ClinicalOutcomes::
  ClinicalOutcomes (const ClinicalOutcomes& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    maxUCSeekingMemory_ (x.maxUCSeekingMemory_, f, this),
    uncomplicatedCaseDuration_ (x.uncomplicatedCaseDuration_, f, this),
    complicatedCaseDuration_ (x.complicatedCaseDuration_, f, this),
    complicatedRiskDuration_ (x.complicatedRiskDuration_, f, this),
    dailyPrImmUCTS_ (x.dailyPrImmUCTS_, f, this)
  {
  }

  ClinicalOutcomes::
  ClinicalOutcomes (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    maxUCSeekingMemory_ (this),
    uncomplicatedCaseDuration_ (this),
    complicatedCaseDuration_ (this),
    complicatedRiskDuration_ (this),
    dailyPrImmUCTS_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClinicalOutcomes::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // maxUCSeekingMemory
      //
      if (n.name () == "maxUCSeekingMemory" && n.namespace_ ().empty ())
      {
        if (!maxUCSeekingMemory_.present ())
        {
          this->maxUCSeekingMemory_.set (MaxUCSeekingMemoryTraits::create (i, f, this));
          continue;
        }
      }

      // uncomplicatedCaseDuration
      //
      if (n.name () == "uncomplicatedCaseDuration" && n.namespace_ ().empty ())
      {
        if (!uncomplicatedCaseDuration_.present ())
        {
          this->uncomplicatedCaseDuration_.set (UncomplicatedCaseDurationTraits::create (i, f, this));
          continue;
        }
      }

      // complicatedCaseDuration
      //
      if (n.name () == "complicatedCaseDuration" && n.namespace_ ().empty ())
      {
        if (!complicatedCaseDuration_.present ())
        {
          this->complicatedCaseDuration_.set (ComplicatedCaseDurationTraits::create (i, f, this));
          continue;
        }
      }

      // complicatedRiskDuration
      //
      if (n.name () == "complicatedRiskDuration" && n.namespace_ ().empty ())
      {
        if (!complicatedRiskDuration_.present ())
        {
          this->complicatedRiskDuration_.set (ComplicatedRiskDurationTraits::create (i, f, this));
          continue;
        }
      }

      // dailyPrImmUCTS
      //
      if (n.name () == "dailyPrImmUCTS" && n.namespace_ ().empty ())
      {
        this->dailyPrImmUCTS_.push_back (DailyPrImmUCTSTraits::create (i, f, this));
        continue;
      }

      break;
    }

    if (!maxUCSeekingMemory_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "maxUCSeekingMemory",
        "");
    }

    if (!uncomplicatedCaseDuration_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "uncomplicatedCaseDuration",
        "");
    }

    if (!complicatedCaseDuration_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "complicatedCaseDuration",
        "");
    }

    if (!complicatedRiskDuration_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "complicatedRiskDuration",
        "");
    }
  }

  ClinicalOutcomes* ClinicalOutcomes::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ClinicalOutcomes (*this, f, c);
  }

  ClinicalOutcomes& ClinicalOutcomes::
  operator= (const ClinicalOutcomes& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->maxUCSeekingMemory_ = x.maxUCSeekingMemory_;
      this->uncomplicatedCaseDuration_ = x.uncomplicatedCaseDuration_;
      this->complicatedCaseDuration_ = x.complicatedCaseDuration_;
      this->complicatedRiskDuration_ = x.complicatedRiskDuration_;
      this->dailyPrImmUCTS_ = x.dailyPrImmUCTS_;
    }

    return *this;
  }

  ClinicalOutcomes::
  ~ClinicalOutcomes ()
  {
  }

  // HSESNMF
  //

  HSESNMF::
  HSESNMF (const PrTreatmentType& prTreatment,
           const EffectNegativeTestType& effectNegativeTest,
           const EffectPositiveTestType& effectPositiveTest,
           const EffectNeedType& effectNeed,
           const EffectInformalType& effectInformal,
           const CFRType& CFR,
           const TreatmentEfficacyType& TreatmentEfficacy)
  : ::xml_schema::Type (),
    prTreatment_ (prTreatment, this),
    effectNegativeTest_ (effectNegativeTest, this),
    effectPositiveTest_ (effectPositiveTest, this),
    effectNeed_ (effectNeed, this),
    effectInformal_ (effectInformal, this),
    CFR_ (CFR, this),
    TreatmentEfficacy_ (TreatmentEfficacy, this)
  {
  }

  HSESNMF::
  HSESNMF (const PrTreatmentType& prTreatment,
           const EffectNegativeTestType& effectNegativeTest,
           const EffectPositiveTestType& effectPositiveTest,
           const EffectNeedType& effectNeed,
           const EffectInformalType& effectInformal,
           ::std::unique_ptr< CFRType > CFR,
           const TreatmentEfficacyType& TreatmentEfficacy)
  : ::xml_schema::Type (),
    prTreatment_ (prTreatment, this),
    effectNegativeTest_ (effectNegativeTest, this),
    effectPositiveTest_ (effectPositiveTest, this),
    effectNeed_ (effectNeed, this),
    effectInformal_ (effectInformal, this),
    CFR_ (std::move (CFR), this),
    TreatmentEfficacy_ (TreatmentEfficacy, this)
  {
  }

  HSESNMF::
  HSESNMF (const HSESNMF& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    prTreatment_ (x.prTreatment_, f, this),
    effectNegativeTest_ (x.effectNegativeTest_, f, this),
    effectPositiveTest_ (x.effectPositiveTest_, f, this),
    effectNeed_ (x.effectNeed_, f, this),
    effectInformal_ (x.effectInformal_, f, this),
    CFR_ (x.CFR_, f, this),
    TreatmentEfficacy_ (x.TreatmentEfficacy_, f, this)
  {
  }

  HSESNMF::
  HSESNMF (const xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    prTreatment_ (this),
    effectNegativeTest_ (this),
    effectPositiveTest_ (this),
    effectNeed_ (this),
    effectInformal_ (this),
    CFR_ (this),
    TreatmentEfficacy_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void HSESNMF::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // prTreatment
      //
      if (n.name () == "prTreatment" && n.namespace_ ().empty ())
      {
        if (!prTreatment_.present ())
        {
          this->prTreatment_.set (PrTreatmentTraits::create (i, f, this));
          continue;
        }
      }

      // effectNegativeTest
      //
      if (n.name () == "effectNegativeTest" && n.namespace_ ().empty ())
      {
        if (!effectNegativeTest_.present ())
        {
          this->effectNegativeTest_.set (EffectNegativeTestTraits::create (i, f, this));
          continue;
        }
      }

      // effectPositiveTest
      //
      if (n.name () == "effectPositiveTest" && n.namespace_ ().empty ())
      {
        if (!effectPositiveTest_.present ())
        {
          this->effectPositiveTest_.set (EffectPositiveTestTraits::create (i, f, this));
          continue;
        }
      }

      // effectNeed
      //
      if (n.name () == "effectNeed" && n.namespace_ ().empty ())
      {
        if (!effectNeed_.present ())
        {
          this->effectNeed_.set (EffectNeedTraits::create (i, f, this));
          continue;
        }
      }

      // effectInformal
      //
      if (n.name () == "effectInformal" && n.namespace_ ().empty ())
      {
        if (!effectInformal_.present ())
        {
          this->effectInformal_.set (EffectInformalTraits::create (i, f, this));
          continue;
        }
      }

      // CFR
      //
      if (n.name () == "CFR" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< CFRType > r (
          CFRTraits::create (i, f, this));

        if (!CFR_.present ())
        {
          this->CFR_.set (::std::move (r));
          continue;
        }
      }

      // TreatmentEfficacy
      //
      if (n.name () == "TreatmentEfficacy" && n.namespace_ ().empty ())
      {
        if (!TreatmentEfficacy_.present ())
        {
          this->TreatmentEfficacy_.set (TreatmentEfficacyTraits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!prTreatment_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "prTreatment",
        "");
    }

    if (!effectNegativeTest_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "effectNegativeTest",
        "");
    }

    if (!effectPositiveTest_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "effectPositiveTest",
        "");
    }

    if (!effectNeed_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "effectNeed",
        "");
    }

    if (!effectInformal_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "effectInformal",
        "");
    }

    if (!CFR_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "CFR",
        "");
    }

    if (!TreatmentEfficacy_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TreatmentEfficacy",
        "");
    }
  }

  HSESNMF* HSESNMF::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HSESNMF (*this, f, c);
  }

  HSESNMF& HSESNMF::
  operator= (const HSESNMF& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->prTreatment_ = x.prTreatment_;
      this->effectNegativeTest_ = x.effectNegativeTest_;
      this->effectPositiveTest_ = x.effectPositiveTest_;
      this->effectNeed_ = x.effectNeed_;
      this->effectInformal_ = x.effectInformal_;
      this->CFR_ = x.CFR_;
      this->TreatmentEfficacy_ = x.TreatmentEfficacy_;
    }

    return *this;
  }

  HSESNMF::
  ~HSESNMF ()
  {
  }

  // DecisionTree
  //

  DecisionTree::
  DecisionTree ()
  : ::xml_schema::Type (),
    multiple_ (this),
    caseType_ (this),
    diagnostic_ (this),
    random_ (this),
    age_ (this),
    noTreatment_ (this),
    treatFailure_ (this),
    treatPKPD_ (this),
    treatSimple_ (this),
    deploy_ (this),
    name_ (this)
  {
  }

  DecisionTree::
  DecisionTree (const DecisionTree& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    multiple_ (x.multiple_, f, this),
    caseType_ (x.caseType_, f, this),
    diagnostic_ (x.diagnostic_, f, this),
    random_ (x.random_, f, this),
    age_ (x.age_, f, this),
    noTreatment_ (x.noTreatment_, f, this),
    treatFailure_ (x.treatFailure_, f, this),
    treatPKPD_ (x.treatPKPD_, f, this),
    treatSimple_ (x.treatSimple_, f, this),
    deploy_ (x.deploy_, f, this),
    name_ (x.name_, f, this)
  {
  }

  DecisionTree::
  DecisionTree (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    multiple_ (this),
    caseType_ (this),
    diagnostic_ (this),
    random_ (this),
    age_ (this),
    noTreatment_ (this),
    treatFailure_ (this),
    treatPKPD_ (this),
    treatSimple_ (this),
    deploy_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DecisionTree::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // multiple
      //
      if (n.name () == "multiple" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MultipleType > r (
          MultipleTraits::create (i, f, this));

        if (!this->multiple_)
        {
          this->multiple_.set (::std::move (r));
          continue;
        }
      }

      // caseType
      //
      if (n.name () == "caseType" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< CaseTypeType > r (
          CaseTypeTraits::create (i, f, this));

        if (!this->caseType_)
        {
          this->caseType_.set (::std::move (r));
          continue;
        }
      }

      // diagnostic
      //
      if (n.name () == "diagnostic" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DiagnosticType > r (
          DiagnosticTraits::create (i, f, this));

        if (!this->diagnostic_)
        {
          this->diagnostic_.set (::std::move (r));
          continue;
        }
      }

      // random
      //
      if (n.name () == "random" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< RandomType > r (
          RandomTraits::create (i, f, this));

        if (!this->random_)
        {
          this->random_.set (::std::move (r));
          continue;
        }
      }

      // age
      //
      if (n.name () == "age" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AgeType > r (
          AgeTraits::create (i, f, this));

        if (!this->age_)
        {
          this->age_.set (::std::move (r));
          continue;
        }
      }

      // noTreatment
      //
      if (n.name () == "noTreatment" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< NoTreatmentType > r (
          NoTreatmentTraits::create (i, f, this));

        if (!this->noTreatment_)
        {
          this->noTreatment_.set (::std::move (r));
          continue;
        }
      }

      // treatFailure
      //
      if (n.name () == "treatFailure" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TreatFailureType > r (
          TreatFailureTraits::create (i, f, this));

        if (!this->treatFailure_)
        {
          this->treatFailure_.set (::std::move (r));
          continue;
        }
      }

      // treatPKPD
      //
      if (n.name () == "treatPKPD" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TreatPKPDType > r (
          TreatPKPDTraits::create (i, f, this));

        this->treatPKPD_.push_back (::std::move (r));
        continue;
      }

      // treatSimple
      //
      if (n.name () == "treatSimple" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TreatSimpleType > r (
          TreatSimpleTraits::create (i, f, this));

        if (!this->treatSimple_)
        {
          this->treatSimple_.set (::std::move (r));
          continue;
        }
      }

      // deploy
      //
      if (n.name () == "deploy" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DeployType > r (
          DeployTraits::create (i, f, this));

        this->deploy_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  DecisionTree* DecisionTree::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DecisionTree (*this, f, c);
  }

  DecisionTree& DecisionTree::
  operator= (const DecisionTree& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->multiple_ = x.multiple_;
      this->caseType_ = x.caseType_;
      this->diagnostic_ = x.diagnostic_;
      this->random_ = x.random_;
      this->age_ = x.age_;
      this->noTreatment_ = x.noTreatment_;
      this->treatFailure_ = x.treatFailure_;
      this->treatPKPD_ = x.treatPKPD_;
      this->treatSimple_ = x.treatSimple_;
      this->deploy_ = x.deploy_;
      this->name_ = x.name_;
    }

    return *this;
  }

  DecisionTree::
  ~DecisionTree ()
  {
  }

  // DTMultiple
  //

  DTMultiple::
  DTMultiple ()
  : ::xml_schema::Type (),
    caseType_ (this),
    diagnostic_ (this),
    random_ (this),
    age_ (this),
    treatPKPD_ (this),
    treatSimple_ (this),
    deploy_ (this),
    name_ (this)
  {
  }

  DTMultiple::
  DTMultiple (const DTMultiple& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    caseType_ (x.caseType_, f, this),
    diagnostic_ (x.diagnostic_, f, this),
    random_ (x.random_, f, this),
    age_ (x.age_, f, this),
    treatPKPD_ (x.treatPKPD_, f, this),
    treatSimple_ (x.treatSimple_, f, this),
    deploy_ (x.deploy_, f, this),
    name_ (x.name_, f, this)
  {
  }

  DTMultiple::
  DTMultiple (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    caseType_ (this),
    diagnostic_ (this),
    random_ (this),
    age_ (this),
    treatPKPD_ (this),
    treatSimple_ (this),
    deploy_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DTMultiple::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // caseType
      //
      if (n.name () == "caseType" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< CaseTypeType > r (
          CaseTypeTraits::create (i, f, this));

        this->caseType_.push_back (::std::move (r));
        continue;
      }

      // diagnostic
      //
      if (n.name () == "diagnostic" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DiagnosticType > r (
          DiagnosticTraits::create (i, f, this));

        this->diagnostic_.push_back (::std::move (r));
        continue;
      }

      // random
      //
      if (n.name () == "random" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< RandomType > r (
          RandomTraits::create (i, f, this));

        this->random_.push_back (::std::move (r));
        continue;
      }

      // age
      //
      if (n.name () == "age" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AgeType > r (
          AgeTraits::create (i, f, this));

        this->age_.push_back (::std::move (r));
        continue;
      }

      // treatPKPD
      //
      if (n.name () == "treatPKPD" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TreatPKPDType > r (
          TreatPKPDTraits::create (i, f, this));

        this->treatPKPD_.push_back (::std::move (r));
        continue;
      }

      // treatSimple
      //
      if (n.name () == "treatSimple" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TreatSimpleType > r (
          TreatSimpleTraits::create (i, f, this));

        if (!this->treatSimple_)
        {
          this->treatSimple_.set (::std::move (r));
          continue;
        }
      }

      // deploy
      //
      if (n.name () == "deploy" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DeployType > r (
          DeployTraits::create (i, f, this));

        this->deploy_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  DTMultiple* DTMultiple::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DTMultiple (*this, f, c);
  }

  DTMultiple& DTMultiple::
  operator= (const DTMultiple& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->caseType_ = x.caseType_;
      this->diagnostic_ = x.diagnostic_;
      this->random_ = x.random_;
      this->age_ = x.age_;
      this->treatPKPD_ = x.treatPKPD_;
      this->treatSimple_ = x.treatSimple_;
      this->deploy_ = x.deploy_;
      this->name_ = x.name_;
    }

    return *this;
  }

  DTMultiple::
  ~DTMultiple ()
  {
  }

  // DTCaseType
  //

  DTCaseType::
  DTCaseType (const FirstLineType& firstLine,
              const SecondLineType& secondLine)
  : ::xml_schema::Type (),
    firstLine_ (firstLine, this),
    secondLine_ (secondLine, this),
    name_ (this)
  {
  }

  DTCaseType::
  DTCaseType (::std::unique_ptr< FirstLineType > firstLine,
              ::std::unique_ptr< SecondLineType > secondLine)
  : ::xml_schema::Type (),
    firstLine_ (std::move (firstLine), this),
    secondLine_ (std::move (secondLine), this),
    name_ (this)
  {
  }

  DTCaseType::
  DTCaseType (const DTCaseType& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    firstLine_ (x.firstLine_, f, this),
    secondLine_ (x.secondLine_, f, this),
    name_ (x.name_, f, this)
  {
  }

  DTCaseType::
  DTCaseType (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    firstLine_ (this),
    secondLine_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DTCaseType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // firstLine
      //
      if (n.name () == "firstLine" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< FirstLineType > r (
          FirstLineTraits::create (i, f, this));

        if (!firstLine_.present ())
        {
          this->firstLine_.set (::std::move (r));
          continue;
        }
      }

      // secondLine
      //
      if (n.name () == "secondLine" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SecondLineType > r (
          SecondLineTraits::create (i, f, this));

        if (!secondLine_.present ())
        {
          this->secondLine_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!firstLine_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "firstLine",
        "");
    }

    if (!secondLine_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "secondLine",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  DTCaseType* DTCaseType::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DTCaseType (*this, f, c);
  }

  DTCaseType& DTCaseType::
  operator= (const DTCaseType& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->firstLine_ = x.firstLine_;
      this->secondLine_ = x.secondLine_;
      this->name_ = x.name_;
    }

    return *this;
  }

  DTCaseType::
  ~DTCaseType ()
  {
  }

  // DTDiagnostic
  //

  DTDiagnostic::
  DTDiagnostic (const PositiveType& positive,
                const NegativeType& negative,
                const DiagnosticType& diagnostic)
  : ::xml_schema::Type (),
    positive_ (positive, this),
    negative_ (negative, this),
    diagnostic_ (diagnostic, this),
    name_ (this)
  {
  }

  DTDiagnostic::
  DTDiagnostic (::std::unique_ptr< PositiveType > positive,
                ::std::unique_ptr< NegativeType > negative,
                const DiagnosticType& diagnostic)
  : ::xml_schema::Type (),
    positive_ (std::move (positive), this),
    negative_ (std::move (negative), this),
    diagnostic_ (diagnostic, this),
    name_ (this)
  {
  }

  DTDiagnostic::
  DTDiagnostic (const DTDiagnostic& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    positive_ (x.positive_, f, this),
    negative_ (x.negative_, f, this),
    diagnostic_ (x.diagnostic_, f, this),
    name_ (x.name_, f, this)
  {
  }

  DTDiagnostic::
  DTDiagnostic (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    positive_ (this),
    negative_ (this),
    diagnostic_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DTDiagnostic::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // positive
      //
      if (n.name () == "positive" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PositiveType > r (
          PositiveTraits::create (i, f, this));

        if (!positive_.present ())
        {
          this->positive_.set (::std::move (r));
          continue;
        }
      }

      // negative
      //
      if (n.name () == "negative" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< NegativeType > r (
          NegativeTraits::create (i, f, this));

        if (!negative_.present ())
        {
          this->negative_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!positive_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "positive",
        "");
    }

    if (!negative_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "negative",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "diagnostic" && n.namespace_ ().empty ())
      {
        this->diagnostic_.set (DiagnosticTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }

    if (!diagnostic_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "diagnostic",
        "");
    }
  }

  DTDiagnostic* DTDiagnostic::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DTDiagnostic (*this, f, c);
  }

  DTDiagnostic& DTDiagnostic::
  operator= (const DTDiagnostic& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->positive_ = x.positive_;
      this->negative_ = x.negative_;
      this->diagnostic_ = x.diagnostic_;
      this->name_ = x.name_;
    }

    return *this;
  }

  DTDiagnostic::
  ~DTDiagnostic ()
  {
  }

  // DTRandom
  //

  DTRandom::
  DTRandom ()
  : ::xml_schema::Type (),
    outcome_ (this),
    name_ (this)
  {
  }

  DTRandom::
  DTRandom (const DTRandom& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    outcome_ (x.outcome_, f, this),
    name_ (x.name_, f, this)
  {
  }

  DTRandom::
  DTRandom (const xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    outcome_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DTRandom::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // outcome
      //
      if (n.name () == "outcome" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< OutcomeType > r (
          OutcomeTraits::create (i, f, this));

        this->outcome_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  DTRandom* DTRandom::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DTRandom (*this, f, c);
  }

  DTRandom& DTRandom::
  operator= (const DTRandom& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->outcome_ = x.outcome_;
      this->name_ = x.name_;
    }

    return *this;
  }

  DTRandom::
  ~DTRandom ()
  {
  }

  // DTAge
  //

  DTAge::
  DTAge ()
  : ::xml_schema::Type (),
    age_ (this),
    name_ (this)
  {
  }

  DTAge::
  DTAge (const DTAge& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    age_ (x.age_, f, this),
    name_ (x.name_, f, this)
  {
  }

  DTAge::
  DTAge (const xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    age_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void DTAge::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // age
      //
      if (n.name () == "age" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AgeType > r (
          AgeTraits::create (i, f, this));

        this->age_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  DTAge* DTAge::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DTAge (*this, f, c);
  }

  DTAge& DTAge::
  operator= (const DTAge& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->age_ = x.age_;
      this->name_ = x.name_;
    }

    return *this;
  }

  DTAge::
  ~DTAge ()
  {
  }

  // DTNoTreatment
  //

  DTNoTreatment::
  DTNoTreatment ()
  : ::xml_schema::Type (),
    name_ (this)
  {
  }

  DTNoTreatment::
  DTNoTreatment (const DTNoTreatment& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this)
  {
  }

  DTNoTreatment::
  DTNoTreatment (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DTNoTreatment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  DTNoTreatment* DTNoTreatment::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DTNoTreatment (*this, f, c);
  }

  DTNoTreatment& DTNoTreatment::
  operator= (const DTNoTreatment& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
    }

    return *this;
  }

  DTNoTreatment::
  ~DTNoTreatment ()
  {
  }

  // DTTreatFailure
  //

  DTTreatFailure::
  DTTreatFailure ()
  : ::xml_schema::Type (),
    name_ (this)
  {
  }

  DTTreatFailure::
  DTTreatFailure (const DTTreatFailure& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this)
  {
  }

  DTTreatFailure::
  DTTreatFailure (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DTTreatFailure::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  DTTreatFailure* DTTreatFailure::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DTTreatFailure (*this, f, c);
  }

  DTTreatFailure& DTTreatFailure::
  operator= (const DTTreatFailure& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
    }

    return *this;
  }

  DTTreatFailure::
  ~DTTreatFailure ()
  {
  }

  // DTTreatPKPD
  //

  DTTreatPKPD::
  DTTreatPKPD (const ScheduleType& schedule,
               const DosageType& dosage)
  : ::xml_schema::Type (),
    schedule_ (schedule, this),
    dosage_ (dosage, this),
    delay_h_ (getDelay_hDefaultValue (), this)
  {
  }

  DTTreatPKPD::
  DTTreatPKPD (const DTTreatPKPD& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    schedule_ (x.schedule_, f, this),
    dosage_ (x.dosage_, f, this),
    delay_h_ (x.delay_h_, f, this)
  {
  }

  DTTreatPKPD::
  DTTreatPKPD (const xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    schedule_ (this),
    dosage_ (this),
    delay_h_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DTTreatPKPD::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "schedule" && n.namespace_ ().empty ())
      {
        this->schedule_.set (ScheduleTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "dosage" && n.namespace_ ().empty ())
      {
        this->dosage_.set (DosageTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "delay_h" && n.namespace_ ().empty ())
      {
        this->delay_h_.set (Delay_hTraits::create (i, f, this));
        continue;
      }
    }

    if (!schedule_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "schedule",
        "");
    }

    if (!dosage_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "dosage",
        "");
    }

    if (!delay_h_.present ())
    {
      this->delay_h_.set (getDelay_hDefaultValue ());
    }
  }

  DTTreatPKPD* DTTreatPKPD::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DTTreatPKPD (*this, f, c);
  }

  DTTreatPKPD& DTTreatPKPD::
  operator= (const DTTreatPKPD& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->schedule_ = x.schedule_;
      this->dosage_ = x.dosage_;
      this->delay_h_ = x.delay_h_;
    }

    return *this;
  }

  DTTreatPKPD::
  ~DTTreatPKPD ()
  {
  }

  // DTTreatSimple
  //

  DTTreatSimple::
  DTTreatSimple (const DurationLiverType& durationLiver,
                 const DurationBloodType& durationBlood)
  : ::xml_schema::Type (),
    durationLiver_ (durationLiver, this),
    durationBlood_ (durationBlood, this)
  {
  }

  DTTreatSimple::
  DTTreatSimple (const DTTreatSimple& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    durationLiver_ (x.durationLiver_, f, this),
    durationBlood_ (x.durationBlood_, f, this)
  {
  }

  DTTreatSimple::
  DTTreatSimple (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    durationLiver_ (this),
    durationBlood_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DTTreatSimple::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "durationLiver" && n.namespace_ ().empty ())
      {
        this->durationLiver_.set (DurationLiverTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "durationBlood" && n.namespace_ ().empty ())
      {
        this->durationBlood_.set (DurationBloodTraits::create (i, f, this));
        continue;
      }
    }

    if (!durationLiver_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "durationLiver",
        "");
    }

    if (!durationBlood_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "durationBlood",
        "");
    }
  }

  DTTreatSimple* DTTreatSimple::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DTTreatSimple (*this, f, c);
  }

  DTTreatSimple& DTTreatSimple::
  operator= (const DTTreatSimple& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->durationLiver_ = x.durationLiver_;
      this->durationBlood_ = x.durationBlood_;
    }

    return *this;
  }

  DTTreatSimple::
  ~DTTreatSimple ()
  {
  }

  // DTDeploy
  //

  DTDeploy::
  DTDeploy (const ComponentType& component)
  : ::xml_schema::Type (),
    component_ (component, this)
  {
  }

  DTDeploy::
  DTDeploy (const DTDeploy& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    component_ (x.component_, f, this)
  {
  }

  DTDeploy::
  DTDeploy (const xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    component_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DTDeploy::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "component" && n.namespace_ ().empty ())
      {
        this->component_.set (ComponentTraits::create (i, f, this));
        continue;
      }
    }

    if (!component_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "component",
        "");
    }
  }

  DTDeploy* DTDeploy::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DTDeploy (*this, f, c);
  }

  DTDeploy& DTDeploy::
  operator= (const DTDeploy& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->component_ = x.component_;
    }

    return *this;
  }

  DTDeploy::
  ~DTDeploy ()
  {
  }

  // TreatmentOption
  //

  TreatmentOption::
  TreatmentOption ()
  : ::scnXml::TriggeredDeployments (),
    clearInfections_ (this),
    name_ (this)
  {
  }

  TreatmentOption::
  TreatmentOption (const TreatmentOption& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::scnXml::TriggeredDeployments (x, f, c),
    clearInfections_ (x.clearInfections_, f, this),
    name_ (x.name_, f, this)
  {
  }

  TreatmentOption::
  TreatmentOption (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::scnXml::TriggeredDeployments (e, f | ::xml_schema::Flags::base, c),
    clearInfections_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void TreatmentOption::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::TriggeredDeployments::parse (p, f);

    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // clearInfections
      //
      if (n.name () == "clearInfections" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ClearInfectionsType > r (
          ClearInfectionsTraits::create (i, f, this));

        this->clearInfections_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  TreatmentOption* TreatmentOption::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TreatmentOption (*this, f, c);
  }

  TreatmentOption& TreatmentOption::
  operator= (const TreatmentOption& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::TriggeredDeployments& > (*this) = x;
      this->clearInfections_ = x.clearInfections_;
      this->name_ = x.name_;
    }

    return *this;
  }

  TreatmentOption::
  ~TreatmentOption ()
  {
  }

  // NeonatalMortality
  //

  NeonatalMortality::
  NeonatalMortality (const DiagnosticType& diagnostic)
  : ::xml_schema::Type (),
    diagnostic_ (diagnostic, this)
  {
  }

  NeonatalMortality::
  NeonatalMortality (const NeonatalMortality& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    diagnostic_ (x.diagnostic_, f, this)
  {
  }

  NeonatalMortality::
  NeonatalMortality (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    diagnostic_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void NeonatalMortality::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "diagnostic" && n.namespace_ ().empty ())
      {
        this->diagnostic_.set (DiagnosticTraits::create (i, f, this));
        continue;
      }
    }

    if (!diagnostic_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "diagnostic",
        "");
    }
  }

  NeonatalMortality* NeonatalMortality::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NeonatalMortality (*this, f, c);
  }

  NeonatalMortality& NeonatalMortality::
  operator= (const NeonatalMortality& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->diagnostic_ = x.diagnostic_;
    }

    return *this;
  }

  NeonatalMortality::
  ~NeonatalMortality ()
  {
  }

  // NonMalariaFevers
  //

  NonMalariaFevers::
  NonMalariaFevers (const IncidenceType& incidence)
  : ::xml_schema::Type (),
    incidence_ (incidence, this),
    prNeedTreatmentNMF_ (this),
    prNeedTreatmentMF_ (this)
  {
  }

  NonMalariaFevers::
  NonMalariaFevers (::std::unique_ptr< IncidenceType > incidence)
  : ::xml_schema::Type (),
    incidence_ (std::move (incidence), this),
    prNeedTreatmentNMF_ (this),
    prNeedTreatmentMF_ (this)
  {
  }

  NonMalariaFevers::
  NonMalariaFevers (const NonMalariaFevers& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    incidence_ (x.incidence_, f, this),
    prNeedTreatmentNMF_ (x.prNeedTreatmentNMF_, f, this),
    prNeedTreatmentMF_ (x.prNeedTreatmentMF_, f, this)
  {
  }

  NonMalariaFevers::
  NonMalariaFevers (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    incidence_ (this),
    prNeedTreatmentNMF_ (this),
    prNeedTreatmentMF_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void NonMalariaFevers::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // incidence
      //
      if (n.name () == "incidence" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< IncidenceType > r (
          IncidenceTraits::create (i, f, this));

        if (!incidence_.present ())
        {
          this->incidence_.set (::std::move (r));
          continue;
        }
      }

      // prNeedTreatmentNMF
      //
      if (n.name () == "prNeedTreatmentNMF" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PrNeedTreatmentNMFType > r (
          PrNeedTreatmentNMFTraits::create (i, f, this));

        if (!this->prNeedTreatmentNMF_)
        {
          this->prNeedTreatmentNMF_.set (::std::move (r));
          continue;
        }
      }

      // prNeedTreatmentMF
      //
      if (n.name () == "prNeedTreatmentMF" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PrNeedTreatmentMFType > r (
          PrNeedTreatmentMFTraits::create (i, f, this));

        if (!this->prNeedTreatmentMF_)
        {
          this->prNeedTreatmentMF_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!incidence_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "incidence",
        "");
    }
  }

  NonMalariaFevers* NonMalariaFevers::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NonMalariaFevers (*this, f, c);
  }

  NonMalariaFevers& NonMalariaFevers::
  operator= (const NonMalariaFevers& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->incidence_ = x.incidence_;
      this->prNeedTreatmentNMF_ = x.prNeedTreatmentNMF_;
      this->prNeedTreatmentMF_ = x.prNeedTreatmentMF_;
    }

    return *this;
  }

  NonMalariaFevers::
  ~NonMalariaFevers ()
  {
  }

  // DrugRegimen
  //

  DrugRegimen::
  DrugRegimen (const FirstLineType& firstLine,
               const SecondLineType& secondLine,
               const InpatientType& inpatient)
  : ::xml_schema::Type (),
    firstLine_ (firstLine, this),
    secondLine_ (secondLine, this),
    inpatient_ (inpatient, this)
  {
  }

  DrugRegimen::
  DrugRegimen (const DrugRegimen& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    firstLine_ (x.firstLine_, f, this),
    secondLine_ (x.secondLine_, f, this),
    inpatient_ (x.inpatient_, f, this)
  {
  }

  DrugRegimen::
  DrugRegimen (const xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    firstLine_ (this),
    secondLine_ (this),
    inpatient_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DrugRegimen::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "firstLine" && n.namespace_ ().empty ())
      {
        this->firstLine_.set (FirstLineTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "secondLine" && n.namespace_ ().empty ())
      {
        this->secondLine_.set (SecondLineTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "inpatient" && n.namespace_ ().empty ())
      {
        this->inpatient_.set (InpatientTraits::create (i, f, this));
        continue;
      }
    }

    if (!firstLine_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "firstLine",
        "");
    }

    if (!secondLine_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "secondLine",
        "");
    }

    if (!inpatient_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "inpatient",
        "");
    }
  }

  DrugRegimen* DrugRegimen::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DrugRegimen (*this, f, c);
  }

  DrugRegimen& DrugRegimen::
  operator= (const DrugRegimen& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->firstLine_ = x.firstLine_;
      this->secondLine_ = x.secondLine_;
      this->inpatient_ = x.inpatient_;
    }

    return *this;
  }

  DrugRegimen::
  ~DrugRegimen ()
  {
  }

  // TreatmentActions
  //

  TreatmentActions::
  TreatmentActions ()
  : ::xml_schema::Type (),
    CQ_ (this),
    SP_ (this),
    AQ_ (this),
    SPAQ_ (this),
    ACT_ (this),
    QN_ (this)
  {
  }

  TreatmentActions::
  TreatmentActions (const TreatmentActions& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    CQ_ (x.CQ_, f, this),
    SP_ (x.SP_, f, this),
    AQ_ (x.AQ_, f, this),
    SPAQ_ (x.SPAQ_, f, this),
    ACT_ (x.ACT_, f, this),
    QN_ (x.QN_, f, this)
  {
  }

  TreatmentActions::
  TreatmentActions (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    CQ_ (this),
    SP_ (this),
    AQ_ (this),
    SPAQ_ (this),
    ACT_ (this),
    QN_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TreatmentActions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // CQ
      //
      if (n.name () == "CQ" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< CQType > r (
          CQTraits::create (i, f, this));

        if (!this->CQ_)
        {
          this->CQ_.set (::std::move (r));
          continue;
        }
      }

      // SP
      //
      if (n.name () == "SP" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SPType > r (
          SPTraits::create (i, f, this));

        if (!this->SP_)
        {
          this->SP_.set (::std::move (r));
          continue;
        }
      }

      // AQ
      //
      if (n.name () == "AQ" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AQType > r (
          AQTraits::create (i, f, this));

        if (!this->AQ_)
        {
          this->AQ_.set (::std::move (r));
          continue;
        }
      }

      // SPAQ
      //
      if (n.name () == "SPAQ" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SPAQType > r (
          SPAQTraits::create (i, f, this));

        if (!this->SPAQ_)
        {
          this->SPAQ_.set (::std::move (r));
          continue;
        }
      }

      // ACT
      //
      if (n.name () == "ACT" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ACTType > r (
          ACTTraits::create (i, f, this));

        if (!this->ACT_)
        {
          this->ACT_.set (::std::move (r));
          continue;
        }
      }

      // QN
      //
      if (n.name () == "QN" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< QNType > r (
          QNTraits::create (i, f, this));

        if (!this->QN_)
        {
          this->QN_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  TreatmentActions* TreatmentActions::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TreatmentActions (*this, f, c);
  }

  TreatmentActions& TreatmentActions::
  operator= (const TreatmentActions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->CQ_ = x.CQ_;
      this->SP_ = x.SP_;
      this->AQ_ = x.AQ_;
      this->SPAQ_ = x.SPAQ_;
      this->ACT_ = x.ACT_;
      this->QN_ = x.QN_;
    }

    return *this;
  }

  TreatmentActions::
  ~TreatmentActions ()
  {
  }

  // Outcome
  //

  Outcome::
  Outcome (const PType& p)
  : ::scnXml::DecisionTree (),
    p_ (p, this)
  {
  }

  Outcome::
  Outcome (const Outcome& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::scnXml::DecisionTree (x, f, c),
    p_ (x.p_, f, this)
  {
  }

  Outcome::
  Outcome (const xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::scnXml::DecisionTree (e, f | ::xml_schema::Flags::base, c),
    p_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Outcome::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::DecisionTree::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "p" && n.namespace_ ().empty ())
      {
        this->p_.set (PTraits::create (i, f, this));
        continue;
      }
    }

    if (!p_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "p",
        "");
    }
  }

  Outcome* Outcome::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Outcome (*this, f, c);
  }

  Outcome& Outcome::
  operator= (const Outcome& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::DecisionTree& > (*this) = x;
      this->p_ = x.p_;
    }

    return *this;
  }

  Outcome::
  ~Outcome ()
  {
  }

  // Age
  //

  Age::
  Age (const LbType& lb)
  : ::scnXml::DecisionTree (),
    lb_ (lb, this)
  {
  }

  Age::
  Age (const Age& x,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::scnXml::DecisionTree (x, f, c),
    lb_ (x.lb_, f, this)
  {
  }

  Age::
  Age (const xercesc::DOMElement& e,
       ::xml_schema::Flags f,
       ::xml_schema::Container* c)
  : ::scnXml::DecisionTree (e, f | ::xml_schema::Flags::base, c),
    lb_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Age::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::DecisionTree::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "lb" && n.namespace_ ().empty ())
      {
        this->lb_.set (LbTraits::create (i, f, this));
        continue;
      }
    }

    if (!lb_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lb",
        "");
    }
  }

  Age* Age::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Age (*this, f, c);
  }

  Age& Age::
  operator= (const Age& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::DecisionTree& > (*this) = x;
      this->lb_ = x.lb_;
    }

    return *this;
  }

  Age::
  ~Age ()
  {
  }

  // ClearInfections
  //

  ClearInfections::
  ClearInfections (const TimestepsType& timesteps,
                   const StageType& stage)
  : ::xml_schema::Type (),
    timesteps_ (timesteps, this),
    stage_ (stage, this)
  {
  }

  ClearInfections::
  ClearInfections (const ClearInfections& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    timesteps_ (x.timesteps_, f, this),
    stage_ (x.stage_, f, this)
  {
  }

  ClearInfections::
  ClearInfections (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    timesteps_ (this),
    stage_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ClearInfections::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "timesteps" && n.namespace_ ().empty ())
      {
        this->timesteps_.set (TimestepsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "stage" && n.namespace_ ().empty ())
      {
        this->stage_.set (StageTraits::create (i, f, this));
        continue;
      }
    }

    if (!timesteps_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "timesteps",
        "");
    }

    if (!stage_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "stage",
        "");
    }
  }

  ClearInfections* ClearInfections::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ClearInfections (*this, f, c);
  }

  ClearInfections& ClearInfections::
  operator= (const ClearInfections& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->timesteps_ = x.timesteps_;
      this->stage_ = x.stage_;
    }

    return *this;
  }

  ClearInfections::
  ~ClearInfections ()
  {
  }

  // Stage
  //

  Stage::
  Stage (const xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Stage_convert ();
  }

  Stage::
  Stage (const xercesc::DOMAttr& a,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Stage_convert ();
  }

  Stage::
  Stage (const ::std::string& s,
         const xercesc::DOMElement* e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Stage_convert ();
  }

  Stage* Stage::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Stage (*this, f, c);
  }

  Stage::Value Stage::
  _xsd_Stage_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Stage_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Stage_indexes_,
                      _xsd_Stage_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_Stage_indexes_ + 3 || _xsd_Stage_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Stage::
  _xsd_Stage_literals_[3] =
  {
    "liver",
    "blood",
    "both"
  };

  const Stage::Value Stage::
  _xsd_Stage_indexes_[3] =
  {
    ::scnXml::Stage::blood,
    ::scnXml::Stage::both,
    ::scnXml::Stage::liver
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace scnXml
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


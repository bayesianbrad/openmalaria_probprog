// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "scenario.h"

namespace scnXml
{
  // Parameter
  // 

  const Parameter::NameOptional& Parameter::
  getName () const
  {
    return this->name_;
  }

  Parameter::NameOptional& Parameter::
  getName ()
  {
    return this->name_;
  }

  void Parameter::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Parameter::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void Parameter::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const Parameter::NumberType& Parameter::
  getNumber () const
  {
    return this->number_.get ();
  }

  Parameter::NumberType& Parameter::
  getNumber ()
  {
    return this->number_.get ();
  }

  void Parameter::
  setNumber (const NumberType& x)
  {
    this->number_.set (x);
  }

  const Parameter::ValueType& Parameter::
  getValue () const
  {
    return this->value_.get ();
  }

  Parameter::ValueType& Parameter::
  getValue ()
  {
    return this->value_.get ();
  }

  void Parameter::
  setValue (const ValueType& x)
  {
    this->value_.set (x);
  }

  const Parameter::IncludeOptional& Parameter::
  getInclude () const
  {
    return this->include_;
  }

  Parameter::IncludeOptional& Parameter::
  getInclude ()
  {
    return this->include_;
  }

  void Parameter::
  setInclude (const IncludeType& x)
  {
    this->include_.set (x);
  }

  void Parameter::
  setInclude (const IncludeOptional& x)
  {
    this->include_ = x;
  }


  // Parameters
  // 

  const Parameters::ParameterSequence& Parameters::
  getParameter () const
  {
    return this->parameter_;
  }

  Parameters::ParameterSequence& Parameters::
  getParameter ()
  {
    return this->parameter_;
  }

  void Parameters::
  setParameter (const ParameterSequence& s)
  {
    this->parameter_ = s;
  }

  const Parameters::IntervalType& Parameters::
  getInterval () const
  {
    return this->interval_.get ();
  }

  Parameters::IntervalType& Parameters::
  getInterval ()
  {
    return this->interval_.get ();
  }

  void Parameters::
  setInterval (const IntervalType& x)
  {
    this->interval_.set (x);
  }

  const Parameters::IseedType& Parameters::
  getIseed () const
  {
    return this->iseed_.get ();
  }

  Parameters::IseedType& Parameters::
  getIseed ()
  {
    return this->iseed_.get ();
  }

  void Parameters::
  setIseed (const IseedType& x)
  {
    this->iseed_.set (x);
  }

  const Parameters::LatentpType& Parameters::
  getLatentp () const
  {
    return this->latentp_.get ();
  }

  Parameters::LatentpType& Parameters::
  getLatentp ()
  {
    return this->latentp_.get ();
  }

  void Parameters::
  setLatentp (const LatentpType& x)
  {
    this->latentp_.set (x);
  }

  void Parameters::
  setLatentp (::std::unique_ptr< LatentpType > x)
  {
    this->latentp_.set (std::move (x));
  }


  // Human
  // 

  const Human::AvailabilityToMosquitoesType& Human::
  getAvailabilityToMosquitoes () const
  {
    return this->availabilityToMosquitoes_.get ();
  }

  Human::AvailabilityToMosquitoesType& Human::
  getAvailabilityToMosquitoes ()
  {
    return this->availabilityToMosquitoes_.get ();
  }

  void Human::
  setAvailabilityToMosquitoes (const AvailabilityToMosquitoesType& x)
  {
    this->availabilityToMosquitoes_.set (x);
  }

  void Human::
  setAvailabilityToMosquitoes (::std::unique_ptr< AvailabilityToMosquitoesType > x)
  {
    this->availabilityToMosquitoes_.set (std::move (x));
  }

  const Human::WeightOptional& Human::
  getWeight () const
  {
    return this->weight_;
  }

  Human::WeightOptional& Human::
  getWeight ()
  {
    return this->weight_;
  }

  void Human::
  setWeight (const WeightType& x)
  {
    this->weight_.set (x);
  }

  void Human::
  setWeight (const WeightOptional& x)
  {
    this->weight_ = x;
  }

  void Human::
  setWeight (::std::unique_ptr< WeightType > x)
  {
    this->weight_.set (std::move (x));
  }


  // Vivax
  // 

  const Vivax::ProbBloodStageInfectiousToMosqType& Vivax::
  getProbBloodStageInfectiousToMosq () const
  {
    return this->probBloodStageInfectiousToMosq_.get ();
  }

  Vivax::ProbBloodStageInfectiousToMosqType& Vivax::
  getProbBloodStageInfectiousToMosq ()
  {
    return this->probBloodStageInfectiousToMosq_.get ();
  }

  void Vivax::
  setProbBloodStageInfectiousToMosq (const ProbBloodStageInfectiousToMosqType& x)
  {
    this->probBloodStageInfectiousToMosq_.set (x);
  }

  void Vivax::
  setProbBloodStageInfectiousToMosq (::std::unique_ptr< ProbBloodStageInfectiousToMosqType > x)
  {
    this->probBloodStageInfectiousToMosq_.set (std::move (x));
  }

  const Vivax::HypnozoiteReleaseType& Vivax::
  getHypnozoiteRelease () const
  {
    return this->hypnozoiteRelease_.get ();
  }

  Vivax::HypnozoiteReleaseType& Vivax::
  getHypnozoiteRelease ()
  {
    return this->hypnozoiteRelease_.get ();
  }

  void Vivax::
  setHypnozoiteRelease (const HypnozoiteReleaseType& x)
  {
    this->hypnozoiteRelease_.set (x);
  }

  void Vivax::
  setHypnozoiteRelease (::std::unique_ptr< HypnozoiteReleaseType > x)
  {
    this->hypnozoiteRelease_.set (std::move (x));
  }

  const Vivax::BloodStageProtectionLatencyType& Vivax::
  getBloodStageProtectionLatency () const
  {
    return this->bloodStageProtectionLatency_.get ();
  }

  Vivax::BloodStageProtectionLatencyType& Vivax::
  getBloodStageProtectionLatency ()
  {
    return this->bloodStageProtectionLatency_.get ();
  }

  void Vivax::
  setBloodStageProtectionLatency (const BloodStageProtectionLatencyType& x)
  {
    this->bloodStageProtectionLatency_.set (x);
  }

  void Vivax::
  setBloodStageProtectionLatency (::std::unique_ptr< BloodStageProtectionLatencyType > x)
  {
    this->bloodStageProtectionLatency_.set (std::move (x));
  }

  const Vivax::BloodStageLengthDaysType& Vivax::
  getBloodStageLengthDays () const
  {
    return this->bloodStageLengthDays_.get ();
  }

  Vivax::BloodStageLengthDaysType& Vivax::
  getBloodStageLengthDays ()
  {
    return this->bloodStageLengthDays_.get ();
  }

  void Vivax::
  setBloodStageLengthDays (const BloodStageLengthDaysType& x)
  {
    this->bloodStageLengthDays_.set (x);
  }

  void Vivax::
  setBloodStageLengthDays (::std::unique_ptr< BloodStageLengthDaysType > x)
  {
    this->bloodStageLengthDays_.set (std::move (x));
  }

  const Vivax::ClinicalEventsType& Vivax::
  getClinicalEvents () const
  {
    return this->clinicalEvents_.get ();
  }

  Vivax::ClinicalEventsType& Vivax::
  getClinicalEvents ()
  {
    return this->clinicalEvents_.get ();
  }

  void Vivax::
  setClinicalEvents (const ClinicalEventsType& x)
  {
    this->clinicalEvents_.set (x);
  }

  void Vivax::
  setClinicalEvents (::std::unique_ptr< ClinicalEventsType > x)
  {
    this->clinicalEvents_.set (std::move (x));
  }


  // HypnozoiteRelease
  // 

  const HypnozoiteRelease::NumberHypnozoitesType& HypnozoiteRelease::
  getNumberHypnozoites () const
  {
    return this->numberHypnozoites_.get ();
  }

  HypnozoiteRelease::NumberHypnozoitesType& HypnozoiteRelease::
  getNumberHypnozoites ()
  {
    return this->numberHypnozoites_.get ();
  }

  void HypnozoiteRelease::
  setNumberHypnozoites (const NumberHypnozoitesType& x)
  {
    this->numberHypnozoites_.set (x);
  }

  void HypnozoiteRelease::
  setNumberHypnozoites (::std::unique_ptr< NumberHypnozoitesType > x)
  {
    this->numberHypnozoites_.set (std::move (x));
  }

  const HypnozoiteRelease::FirstReleaseType& HypnozoiteRelease::
  getFirstRelease () const
  {
    return this->firstRelease_.get ();
  }

  HypnozoiteRelease::FirstReleaseType& HypnozoiteRelease::
  getFirstRelease ()
  {
    return this->firstRelease_.get ();
  }

  void HypnozoiteRelease::
  setFirstRelease (const FirstReleaseType& x)
  {
    this->firstRelease_.set (x);
  }

  void HypnozoiteRelease::
  setFirstRelease (::std::unique_ptr< FirstReleaseType > x)
  {
    this->firstRelease_.set (std::move (x));
  }

  const HypnozoiteRelease::SecondReleaseOptional& HypnozoiteRelease::
  getSecondRelease () const
  {
    return this->secondRelease_;
  }

  HypnozoiteRelease::SecondReleaseOptional& HypnozoiteRelease::
  getSecondRelease ()
  {
    return this->secondRelease_;
  }

  void HypnozoiteRelease::
  setSecondRelease (const SecondReleaseType& x)
  {
    this->secondRelease_.set (x);
  }

  void HypnozoiteRelease::
  setSecondRelease (const SecondReleaseOptional& x)
  {
    this->secondRelease_ = x;
  }

  void HypnozoiteRelease::
  setSecondRelease (::std::unique_ptr< SecondReleaseType > x)
  {
    this->secondRelease_.set (std::move (x));
  }

  const HypnozoiteRelease::PSecondReleaseType& HypnozoiteRelease::
  getPSecondRelease () const
  {
    return this->pSecondRelease_.get ();
  }

  HypnozoiteRelease::PSecondReleaseType& HypnozoiteRelease::
  getPSecondRelease ()
  {
    return this->pSecondRelease_.get ();
  }

  void HypnozoiteRelease::
  setPSecondRelease (const PSecondReleaseType& x)
  {
    this->pSecondRelease_.set (x);
  }

  HypnozoiteRelease::PSecondReleaseType HypnozoiteRelease::
  getPSecondReleaseDefaultValue ()
  {
    return PSecondReleaseType (0.0);
  }


  // HypnozoiteReleaseDistribution
  // 

  const HypnozoiteReleaseDistribution::LatentRelapseDaysType& HypnozoiteReleaseDistribution::
  getLatentRelapseDays () const
  {
    return this->latentRelapseDays_.get ();
  }

  HypnozoiteReleaseDistribution::LatentRelapseDaysType& HypnozoiteReleaseDistribution::
  getLatentRelapseDays ()
  {
    return this->latentRelapseDays_.get ();
  }

  void HypnozoiteReleaseDistribution::
  setLatentRelapseDays (const LatentRelapseDaysType& x)
  {
    this->latentRelapseDays_.set (x);
  }


  // ClinicalEvents
  // 

  const ClinicalEvents::PPrimaryInfectionType& ClinicalEvents::
  getPPrimaryInfection () const
  {
    return this->pPrimaryInfection_.get ();
  }

  ClinicalEvents::PPrimaryInfectionType& ClinicalEvents::
  getPPrimaryInfection ()
  {
    return this->pPrimaryInfection_.get ();
  }

  void ClinicalEvents::
  setPPrimaryInfection (const PPrimaryInfectionType& x)
  {
    this->pPrimaryInfection_.set (x);
  }

  void ClinicalEvents::
  setPPrimaryInfection (::std::unique_ptr< PPrimaryInfectionType > x)
  {
    this->pPrimaryInfection_.set (std::move (x));
  }

  const ClinicalEvents::PRelapseOneType& ClinicalEvents::
  getPRelapseOne () const
  {
    return this->pRelapseOne_.get ();
  }

  ClinicalEvents::PRelapseOneType& ClinicalEvents::
  getPRelapseOne ()
  {
    return this->pRelapseOne_.get ();
  }

  void ClinicalEvents::
  setPRelapseOne (const PRelapseOneType& x)
  {
    this->pRelapseOne_.set (x);
  }

  void ClinicalEvents::
  setPRelapseOne (::std::unique_ptr< PRelapseOneType > x)
  {
    this->pRelapseOne_.set (std::move (x));
  }

  const ClinicalEvents::PRelapseTwoPlusType& ClinicalEvents::
  getPRelapseTwoPlus () const
  {
    return this->pRelapseTwoPlus_.get ();
  }

  ClinicalEvents::PRelapseTwoPlusType& ClinicalEvents::
  getPRelapseTwoPlus ()
  {
    return this->pRelapseTwoPlus_.get ();
  }

  void ClinicalEvents::
  setPRelapseTwoPlus (const PRelapseTwoPlusType& x)
  {
    this->pRelapseTwoPlus_.set (x);
  }

  void ClinicalEvents::
  setPRelapseTwoPlus (::std::unique_ptr< PRelapseTwoPlusType > x)
  {
    this->pRelapseTwoPlus_.set (std::move (x));
  }

  const ClinicalEvents::PEventIsSevereType& ClinicalEvents::
  getPEventIsSevere () const
  {
    return this->pEventIsSevere_.get ();
  }

  ClinicalEvents::PEventIsSevereType& ClinicalEvents::
  getPEventIsSevere ()
  {
    return this->pEventIsSevere_.get ();
  }

  void ClinicalEvents::
  setPEventIsSevere (const PEventIsSevereType& x)
  {
    this->pEventIsSevere_.set (x);
  }

  void ClinicalEvents::
  setPEventIsSevere (::std::unique_ptr< PEventIsSevereType > x)
  {
    this->pEventIsSevere_.set (std::move (x));
  }


  // ProbVivaxEvent
  // 

  const ProbVivaxEvent::AType& ProbVivaxEvent::
  getA () const
  {
    return this->a_.get ();
  }

  ProbVivaxEvent::AType& ProbVivaxEvent::
  getA ()
  {
    return this->a_.get ();
  }

  void ProbVivaxEvent::
  setA (const AType& x)
  {
    this->a_.set (x);
  }

  const ProbVivaxEvent::BType& ProbVivaxEvent::
  getB () const
  {
    return this->b_.get ();
  }

  ProbVivaxEvent::BType& ProbVivaxEvent::
  getB ()
  {
    return this->b_.get ();
  }

  void ProbVivaxEvent::
  setB (const BType& x)
  {
    this->b_.set (x);
  }


  // ParasiteGenetics
  // 

  const ParasiteGenetics::LocusSequence& ParasiteGenetics::
  getLocus () const
  {
    return this->locus_;
  }

  ParasiteGenetics::LocusSequence& ParasiteGenetics::
  getLocus ()
  {
    return this->locus_;
  }

  void ParasiteGenetics::
  setLocus (const LocusSequence& s)
  {
    this->locus_ = s;
  }

  const ParasiteGenetics::SamplingModeType& ParasiteGenetics::
  getSamplingMode () const
  {
    return this->samplingMode_.get ();
  }

  ParasiteGenetics::SamplingModeType& ParasiteGenetics::
  getSamplingMode ()
  {
    return this->samplingMode_.get ();
  }

  void ParasiteGenetics::
  setSamplingMode (const SamplingModeType& x)
  {
    this->samplingMode_.set (x);
  }

  void ParasiteGenetics::
  setSamplingMode (::std::unique_ptr< SamplingModeType > x)
  {
    this->samplingMode_.set (std::move (x));
  }


  // ParasiteGenotype
  // 

  const ParasiteGenotype::NameType& ParasiteGenotype::
  getName () const
  {
    return this->name_.get ();
  }

  ParasiteGenotype::NameType& ParasiteGenotype::
  getName ()
  {
    return this->name_.get ();
  }

  void ParasiteGenotype::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ParasiteGenotype::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const ParasiteGenotype::InitialFrequencyType& ParasiteGenotype::
  getInitialFrequency () const
  {
    return this->initialFrequency_.get ();
  }

  ParasiteGenotype::InitialFrequencyType& ParasiteGenotype::
  getInitialFrequency ()
  {
    return this->initialFrequency_.get ();
  }

  void ParasiteGenotype::
  setInitialFrequency (const InitialFrequencyType& x)
  {
    this->initialFrequency_.set (x);
  }

  const ParasiteGenotype::FitnessType& ParasiteGenotype::
  getFitness () const
  {
    return this->fitness_.get ();
  }

  ParasiteGenotype::FitnessType& ParasiteGenotype::
  getFitness ()
  {
    return this->fitness_.get ();
  }

  void ParasiteGenotype::
  setFitness (const FitnessType& x)
  {
    this->fitness_.set (x);
  }


  // ParasiteLocus
  // 

  const ParasiteLocus::AlleleSequence& ParasiteLocus::
  getAllele () const
  {
    return this->allele_;
  }

  ParasiteLocus::AlleleSequence& ParasiteLocus::
  getAllele ()
  {
    return this->allele_;
  }

  void ParasiteLocus::
  setAllele (const AlleleSequence& s)
  {
    this->allele_ = s;
  }

  const ParasiteLocus::NameType& ParasiteLocus::
  getName () const
  {
    return this->name_.get ();
  }

  ParasiteLocus::NameType& ParasiteLocus::
  getName ()
  {
    return this->name_.get ();
  }

  void ParasiteLocus::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ParasiteLocus::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // ParasiteAllele
  // 

  const ParasiteAllele::NameType& ParasiteAllele::
  getName () const
  {
    return this->name_.get ();
  }

  ParasiteAllele::NameType& ParasiteAllele::
  getName ()
  {
    return this->name_.get ();
  }

  void ParasiteAllele::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ParasiteAllele::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const ParasiteAllele::InitialFrequencyType& ParasiteAllele::
  getInitialFrequency () const
  {
    return this->initialFrequency_.get ();
  }

  ParasiteAllele::InitialFrequencyType& ParasiteAllele::
  getInitialFrequency ()
  {
    return this->initialFrequency_.get ();
  }

  void ParasiteAllele::
  setInitialFrequency (const InitialFrequencyType& x)
  {
    this->initialFrequency_.set (x);
  }

  const ParasiteAllele::FitnessType& ParasiteAllele::
  getFitness () const
  {
    return this->fitness_.get ();
  }

  ParasiteAllele::FitnessType& ParasiteAllele::
  getFitness ()
  {
    return this->fitness_.get ();
  }

  void ParasiteAllele::
  setFitness (const FitnessType& x)
  {
    this->fitness_.set (x);
  }


  // Diagnostics
  // 

  const Diagnostics::DiagnosticSequence& Diagnostics::
  getDiagnostic () const
  {
    return this->diagnostic_;
  }

  Diagnostics::DiagnosticSequence& Diagnostics::
  getDiagnostic ()
  {
    return this->diagnostic_;
  }

  void Diagnostics::
  setDiagnostic (const DiagnosticSequence& s)
  {
    this->diagnostic_ = s;
  }


  // Diagnostic
  // 

  const Diagnostic::DeterministicOptional& Diagnostic::
  getDeterministic () const
  {
    return this->deterministic_;
  }

  Diagnostic::DeterministicOptional& Diagnostic::
  getDeterministic ()
  {
    return this->deterministic_;
  }

  void Diagnostic::
  setDeterministic (const DeterministicType& x)
  {
    this->deterministic_.set (x);
  }

  void Diagnostic::
  setDeterministic (const DeterministicOptional& x)
  {
    this->deterministic_ = x;
  }

  void Diagnostic::
  setDeterministic (::std::unique_ptr< DeterministicType > x)
  {
    this->deterministic_.set (std::move (x));
  }

  const Diagnostic::StochasticOptional& Diagnostic::
  getStochastic () const
  {
    return this->stochastic_;
  }

  Diagnostic::StochasticOptional& Diagnostic::
  getStochastic ()
  {
    return this->stochastic_;
  }

  void Diagnostic::
  setStochastic (const StochasticType& x)
  {
    this->stochastic_.set (x);
  }

  void Diagnostic::
  setStochastic (const StochasticOptional& x)
  {
    this->stochastic_ = x;
  }

  void Diagnostic::
  setStochastic (::std::unique_ptr< StochasticType > x)
  {
    this->stochastic_.set (std::move (x));
  }

  const Diagnostic::NameType& Diagnostic::
  getName () const
  {
    return this->name_.get ();
  }

  Diagnostic::NameType& Diagnostic::
  getName ()
  {
    return this->name_.get ();
  }

  void Diagnostic::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Diagnostic::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const Diagnostic::UnitsOptional& Diagnostic::
  getUnits () const
  {
    return this->units_;
  }

  Diagnostic::UnitsOptional& Diagnostic::
  getUnits ()
  {
    return this->units_;
  }

  void Diagnostic::
  setUnits (const UnitsType& x)
  {
    this->units_.set (x);
  }

  void Diagnostic::
  setUnits (const UnitsOptional& x)
  {
    this->units_ = x;
  }

  void Diagnostic::
  setUnits (::std::unique_ptr< UnitsType > x)
  {
    this->units_.set (std::move (x));
  }


  // Scenario
  // 

  const Scenario::DemographyType& Scenario::
  getDemography () const
  {
    return this->demography_.get ();
  }

  Scenario::DemographyType& Scenario::
  getDemography ()
  {
    return this->demography_.get ();
  }

  void Scenario::
  setDemography (const DemographyType& x)
  {
    this->demography_.set (x);
  }

  void Scenario::
  setDemography (::std::unique_ptr< DemographyType > x)
  {
    this->demography_.set (std::move (x));
  }

  const Scenario::MonitoringType& Scenario::
  getMonitoring () const
  {
    return this->monitoring_.get ();
  }

  Scenario::MonitoringType& Scenario::
  getMonitoring ()
  {
    return this->monitoring_.get ();
  }

  void Scenario::
  setMonitoring (const MonitoringType& x)
  {
    this->monitoring_.set (x);
  }

  void Scenario::
  setMonitoring (::std::unique_ptr< MonitoringType > x)
  {
    this->monitoring_.set (std::move (x));
  }

  const Scenario::InterventionsType& Scenario::
  getInterventions () const
  {
    return this->interventions_.get ();
  }

  Scenario::InterventionsType& Scenario::
  getInterventions ()
  {
    return this->interventions_.get ();
  }

  void Scenario::
  setInterventions (const InterventionsType& x)
  {
    this->interventions_.set (x);
  }

  void Scenario::
  setInterventions (::std::unique_ptr< InterventionsType > x)
  {
    this->interventions_.set (std::move (x));
  }

  const Scenario::HealthSystemType& Scenario::
  getHealthSystem () const
  {
    return this->healthSystem_.get ();
  }

  Scenario::HealthSystemType& Scenario::
  getHealthSystem ()
  {
    return this->healthSystem_.get ();
  }

  void Scenario::
  setHealthSystem (const HealthSystemType& x)
  {
    this->healthSystem_.set (x);
  }

  void Scenario::
  setHealthSystem (::std::unique_ptr< HealthSystemType > x)
  {
    this->healthSystem_.set (std::move (x));
  }

  const Scenario::EntomologyType& Scenario::
  getEntomology () const
  {
    return this->entomology_.get ();
  }

  Scenario::EntomologyType& Scenario::
  getEntomology ()
  {
    return this->entomology_.get ();
  }

  void Scenario::
  setEntomology (const EntomologyType& x)
  {
    this->entomology_.set (x);
  }

  void Scenario::
  setEntomology (::std::unique_ptr< EntomologyType > x)
  {
    this->entomology_.set (std::move (x));
  }

  const Scenario::ParasiteGeneticsOptional& Scenario::
  getParasiteGenetics () const
  {
    return this->parasiteGenetics_;
  }

  Scenario::ParasiteGeneticsOptional& Scenario::
  getParasiteGenetics ()
  {
    return this->parasiteGenetics_;
  }

  void Scenario::
  setParasiteGenetics (const ParasiteGeneticsType& x)
  {
    this->parasiteGenetics_.set (x);
  }

  void Scenario::
  setParasiteGenetics (const ParasiteGeneticsOptional& x)
  {
    this->parasiteGenetics_ = x;
  }

  void Scenario::
  setParasiteGenetics (::std::unique_ptr< ParasiteGeneticsType > x)
  {
    this->parasiteGenetics_.set (std::move (x));
  }

  const Scenario::PharmacologyOptional& Scenario::
  getPharmacology () const
  {
    return this->pharmacology_;
  }

  Scenario::PharmacologyOptional& Scenario::
  getPharmacology ()
  {
    return this->pharmacology_;
  }

  void Scenario::
  setPharmacology (const PharmacologyType& x)
  {
    this->pharmacology_.set (x);
  }

  void Scenario::
  setPharmacology (const PharmacologyOptional& x)
  {
    this->pharmacology_ = x;
  }

  void Scenario::
  setPharmacology (::std::unique_ptr< PharmacologyType > x)
  {
    this->pharmacology_.set (std::move (x));
  }

  const Scenario::DiagnosticsOptional& Scenario::
  getDiagnostics () const
  {
    return this->diagnostics_;
  }

  Scenario::DiagnosticsOptional& Scenario::
  getDiagnostics ()
  {
    return this->diagnostics_;
  }

  void Scenario::
  setDiagnostics (const DiagnosticsType& x)
  {
    this->diagnostics_.set (x);
  }

  void Scenario::
  setDiagnostics (const DiagnosticsOptional& x)
  {
    this->diagnostics_ = x;
  }

  void Scenario::
  setDiagnostics (::std::unique_ptr< DiagnosticsType > x)
  {
    this->diagnostics_.set (std::move (x));
  }

  const Scenario::ModelType& Scenario::
  getModel () const
  {
    return this->model_.get ();
  }

  Scenario::ModelType& Scenario::
  getModel ()
  {
    return this->model_.get ();
  }

  void Scenario::
  setModel (const ModelType& x)
  {
    this->model_.set (x);
  }

  void Scenario::
  setModel (::std::unique_ptr< ModelType > x)
  {
    this->model_.set (std::move (x));
  }

  const Scenario::SchemaVersionType& Scenario::
  getSchemaVersion () const
  {
    return this->schemaVersion_.get ();
  }

  Scenario::SchemaVersionType& Scenario::
  getSchemaVersion ()
  {
    return this->schemaVersion_.get ();
  }

  void Scenario::
  setSchemaVersion (const SchemaVersionType& x)
  {
    this->schemaVersion_.set (x);
  }

  const Scenario::AnalysisNoOptional& Scenario::
  getAnalysisNo () const
  {
    return this->analysisNo_;
  }

  Scenario::AnalysisNoOptional& Scenario::
  getAnalysisNo ()
  {
    return this->analysisNo_;
  }

  void Scenario::
  setAnalysisNo (const AnalysisNoType& x)
  {
    this->analysisNo_.set (x);
  }

  void Scenario::
  setAnalysisNo (const AnalysisNoOptional& x)
  {
    this->analysisNo_ = x;
  }

  const Scenario::NameType& Scenario::
  getName () const
  {
    return this->name_.get ();
  }

  Scenario::NameType& Scenario::
  getName ()
  {
    return this->name_.get ();
  }

  void Scenario::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Scenario::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }

  const Scenario::WuIDOptional& Scenario::
  getWuID () const
  {
    return this->wuID_;
  }

  Scenario::WuIDOptional& Scenario::
  getWuID ()
  {
    return this->wuID_;
  }

  void Scenario::
  setWuID (const WuIDType& x)
  {
    this->wuID_.set (x);
  }

  void Scenario::
  setWuID (const WuIDOptional& x)
  {
    this->wuID_ = x;
  }


  // Weight
  // 

  const Weight::MultStdDevType& Weight::
  getMultStdDev () const
  {
    return this->multStdDev_.get ();
  }

  Weight::MultStdDevType& Weight::
  getMultStdDev ()
  {
    return this->multStdDev_.get ();
  }

  void Weight::
  setMultStdDev (const MultStdDevType& x)
  {
    this->multStdDev_.set (x);
  }


  // BloodStageLengthDays
  // 

  const BloodStageLengthDays::WeibullScaleType& BloodStageLengthDays::
  getWeibullScale () const
  {
    return this->weibullScale_.get ();
  }

  BloodStageLengthDays::WeibullScaleType& BloodStageLengthDays::
  getWeibullScale ()
  {
    return this->weibullScale_.get ();
  }

  void BloodStageLengthDays::
  setWeibullScale (const WeibullScaleType& x)
  {
    this->weibullScale_.set (x);
  }

  const BloodStageLengthDays::WeibullShapeType& BloodStageLengthDays::
  getWeibullShape () const
  {
    return this->weibullShape_.get ();
  }

  BloodStageLengthDays::WeibullShapeType& BloodStageLengthDays::
  getWeibullShape ()
  {
    return this->weibullShape_.get ();
  }

  void BloodStageLengthDays::
  setWeibullShape (const WeibullShapeType& x)
  {
    this->weibullShape_.set (x);
  }


  // NumberHypnozoites
  // 

  const NumberHypnozoites::MaxType& NumberHypnozoites::
  getMax () const
  {
    return this->max_.get ();
  }

  NumberHypnozoites::MaxType& NumberHypnozoites::
  getMax ()
  {
    return this->max_.get ();
  }

  void NumberHypnozoites::
  setMax (const MaxType& x)
  {
    this->max_.set (x);
  }

  const NumberHypnozoites::BaseType& NumberHypnozoites::
  getBase () const
  {
    return this->base_.get ();
  }

  NumberHypnozoites::BaseType& NumberHypnozoites::
  getBase ()
  {
    return this->base_.get ();
  }

  void NumberHypnozoites::
  setBase (const BaseType& x)
  {
    this->base_.set (x);
  }


  // SamplingMode
  // 

  SamplingMode::
  SamplingMode (Value v)
  : ::xml_schema::String (_xsd_SamplingMode_literals_[v])
  {
  }

  SamplingMode::
  SamplingMode (const char* v)
  : ::xml_schema::String (v)
  {
  }

  SamplingMode::
  SamplingMode (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  SamplingMode::
  SamplingMode (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  SamplingMode::
  SamplingMode (const SamplingMode& v,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  SamplingMode& SamplingMode::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_SamplingMode_literals_[v]);

    return *this;
  }


  // Deterministic
  // 

  const Deterministic::MinDensityType& Deterministic::
  getMinDensity () const
  {
    return this->minDensity_.get ();
  }

  Deterministic::MinDensityType& Deterministic::
  getMinDensity ()
  {
    return this->minDensity_.get ();
  }

  void Deterministic::
  setMinDensity (const MinDensityType& x)
  {
    this->minDensity_.set (x);
  }


  // Stochastic
  // 

  const Stochastic::Dens_50Type& Stochastic::
  getDens_50 () const
  {
    return this->dens_50_.get ();
  }

  Stochastic::Dens_50Type& Stochastic::
  getDens_50 ()
  {
    return this->dens_50_.get ();
  }

  void Stochastic::
  setDens_50 (const Dens_50Type& x)
  {
    this->dens_50_.set (x);
  }

  const Stochastic::SpecificityType& Stochastic::
  getSpecificity () const
  {
    return this->specificity_.get ();
  }

  Stochastic::SpecificityType& Stochastic::
  getSpecificity ()
  {
    return this->specificity_.get ();
  }

  void Stochastic::
  setSpecificity (const SpecificityType& x)
  {
    this->specificity_.set (x);
  }


  // Units
  // 

  Units::
  Units (Value v)
  : ::xml_schema::String (_xsd_Units_literals_[v])
  {
  }

  Units::
  Units (const char* v)
  : ::xml_schema::String (v)
  {
  }

  Units::
  Units (const ::std::string& v)
  : ::xml_schema::String (v)
  {
  }

  Units::
  Units (const ::xml_schema::String& v)
  : ::xml_schema::String (v)
  {
  }

  Units::
  Units (const Units& v,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (v, f, c)
  {
  }

  Units& Units::
  operator= (Value v)
  {
    static_cast< ::xml_schema::String& > (*this) = 
    ::xml_schema::String (_xsd_Units_literals_[v]);

    return *this;
  }


  // Model
  // 

  const Model::ModelOptionsType& Model::
  getModelOptions () const
  {
    return this->ModelOptions_.get ();
  }

  Model::ModelOptionsType& Model::
  getModelOptions ()
  {
    return this->ModelOptions_.get ();
  }

  void Model::
  setModelOptions (const ModelOptionsType& x)
  {
    this->ModelOptions_.set (x);
  }

  void Model::
  setModelOptions (::std::unique_ptr< ModelOptionsType > x)
  {
    this->ModelOptions_.set (std::move (x));
  }

  const Model::ClinicalType& Model::
  getClinical () const
  {
    return this->clinical_.get ();
  }

  Model::ClinicalType& Model::
  getClinical ()
  {
    return this->clinical_.get ();
  }

  void Model::
  setClinical (const ClinicalType& x)
  {
    this->clinical_.set (x);
  }

  void Model::
  setClinical (::std::unique_ptr< ClinicalType > x)
  {
    this->clinical_.set (std::move (x));
  }

  const Model::HumanType& Model::
  getHuman () const
  {
    return this->human_.get ();
  }

  Model::HumanType& Model::
  getHuman ()
  {
    return this->human_.get ();
  }

  void Model::
  setHuman (const HumanType& x)
  {
    this->human_.set (x);
  }

  void Model::
  setHuman (::std::unique_ptr< HumanType > x)
  {
    this->human_.set (std::move (x));
  }

  const Model::VivaxOptional& Model::
  getVivax () const
  {
    return this->vivax_;
  }

  Model::VivaxOptional& Model::
  getVivax ()
  {
    return this->vivax_;
  }

  void Model::
  setVivax (const VivaxType& x)
  {
    this->vivax_.set (x);
  }

  void Model::
  setVivax (const VivaxOptional& x)
  {
    this->vivax_ = x;
  }

  void Model::
  setVivax (::std::unique_ptr< VivaxType > x)
  {
    this->vivax_.set (std::move (x));
  }

  const Model::ParametersType& Model::
  getParameters () const
  {
    return this->parameters_.get ();
  }

  Model::ParametersType& Model::
  getParameters ()
  {
    return this->parameters_.get ();
  }

  void Model::
  setParameters (const ParametersType& x)
  {
    this->parameters_.set (x);
  }

  void Model::
  setParameters (::std::unique_ptr< ParametersType > x)
  {
    this->parameters_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace scnXml
{
  // Parameter
  //

  Parameter::
  Parameter (const NumberType& number,
             const ValueType& value)
  : ::xml_schema::Type (),
    name_ (this),
    number_ (number, this),
    value_ (value, this),
    include_ (this)
  {
  }

  Parameter::
  Parameter (const Parameter& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    number_ (x.number_, f, this),
    value_ (x.value_, f, this),
    include_ (x.include_, f, this)
  {
  }

  Parameter::
  Parameter (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    number_ (this),
    value_ (this),
    include_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Parameter::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "number" && n.namespace_ ().empty ())
      {
        this->number_.set (NumberTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "value" && n.namespace_ ().empty ())
      {
        this->value_.set (ValueTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "include" && n.namespace_ ().empty ())
      {
        this->include_.set (IncludeTraits::create (i, f, this));
        continue;
      }
    }

    if (!number_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "number",
        "");
    }

    if (!value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "value",
        "");
    }
  }

  Parameter* Parameter::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Parameter (*this, f, c);
  }

  Parameter& Parameter::
  operator= (const Parameter& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->number_ = x.number_;
      this->value_ = x.value_;
      this->include_ = x.include_;
    }

    return *this;
  }

  Parameter::
  ~Parameter ()
  {
  }

  // Parameters
  //

  Parameters::
  Parameters (const IntervalType& interval,
              const IseedType& iseed,
              const LatentpType& latentp)
  : ::xml_schema::Type (),
    parameter_ (this),
    interval_ (interval, this),
    iseed_ (iseed, this),
    latentp_ (latentp, this)
  {
  }

  Parameters::
  Parameters (const Parameters& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    parameter_ (x.parameter_, f, this),
    interval_ (x.interval_, f, this),
    iseed_ (x.iseed_, f, this),
    latentp_ (x.latentp_, f, this)
  {
  }

  Parameters::
  Parameters (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    parameter_ (this),
    interval_ (this),
    iseed_ (this),
    latentp_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Parameters::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // parameter
      //
      if (n.name () == "parameter" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ParameterType > r (
          ParameterTraits::create (i, f, this));

        this->parameter_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "interval" && n.namespace_ ().empty ())
      {
        this->interval_.set (IntervalTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "iseed" && n.namespace_ ().empty ())
      {
        this->iseed_.set (IseedTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "latentp" && n.namespace_ ().empty ())
      {
        this->latentp_.set (LatentpTraits::create (i, f, this));
        continue;
      }
    }

    if (!interval_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "interval",
        "");
    }

    if (!iseed_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "iseed",
        "");
    }

    if (!latentp_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "latentp",
        "");
    }
  }

  Parameters* Parameters::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Parameters (*this, f, c);
  }

  Parameters& Parameters::
  operator= (const Parameters& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->parameter_ = x.parameter_;
      this->interval_ = x.interval_;
      this->iseed_ = x.iseed_;
      this->latentp_ = x.latentp_;
    }

    return *this;
  }

  Parameters::
  ~Parameters ()
  {
  }

  // Human
  //

  Human::
  Human (const AvailabilityToMosquitoesType& availabilityToMosquitoes)
  : ::xml_schema::Type (),
    availabilityToMosquitoes_ (availabilityToMosquitoes, this),
    weight_ (this)
  {
  }

  Human::
  Human (::std::unique_ptr< AvailabilityToMosquitoesType > availabilityToMosquitoes)
  : ::xml_schema::Type (),
    availabilityToMosquitoes_ (std::move (availabilityToMosquitoes), this),
    weight_ (this)
  {
  }

  Human::
  Human (const Human& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    availabilityToMosquitoes_ (x.availabilityToMosquitoes_, f, this),
    weight_ (x.weight_, f, this)
  {
  }

  Human::
  Human (const xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    availabilityToMosquitoes_ (this),
    weight_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Human::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // availabilityToMosquitoes
      //
      if (n.name () == "availabilityToMosquitoes" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AvailabilityToMosquitoesType > r (
          AvailabilityToMosquitoesTraits::create (i, f, this));

        if (!availabilityToMosquitoes_.present ())
        {
          this->availabilityToMosquitoes_.set (::std::move (r));
          continue;
        }
      }

      // weight
      //
      if (n.name () == "weight" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< WeightType > r (
          WeightTraits::create (i, f, this));

        if (!this->weight_)
        {
          this->weight_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!availabilityToMosquitoes_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "availabilityToMosquitoes",
        "");
    }
  }

  Human* Human::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Human (*this, f, c);
  }

  Human& Human::
  operator= (const Human& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->availabilityToMosquitoes_ = x.availabilityToMosquitoes_;
      this->weight_ = x.weight_;
    }

    return *this;
  }

  Human::
  ~Human ()
  {
  }

  // Vivax
  //

  Vivax::
  Vivax (const ProbBloodStageInfectiousToMosqType& probBloodStageInfectiousToMosq,
         const HypnozoiteReleaseType& hypnozoiteRelease,
         const BloodStageProtectionLatencyType& bloodStageProtectionLatency,
         const BloodStageLengthDaysType& bloodStageLengthDays,
         const ClinicalEventsType& clinicalEvents)
  : ::xml_schema::Type (),
    probBloodStageInfectiousToMosq_ (probBloodStageInfectiousToMosq, this),
    hypnozoiteRelease_ (hypnozoiteRelease, this),
    bloodStageProtectionLatency_ (bloodStageProtectionLatency, this),
    bloodStageLengthDays_ (bloodStageLengthDays, this),
    clinicalEvents_ (clinicalEvents, this)
  {
  }

  Vivax::
  Vivax (::std::unique_ptr< ProbBloodStageInfectiousToMosqType > probBloodStageInfectiousToMosq,
         ::std::unique_ptr< HypnozoiteReleaseType > hypnozoiteRelease,
         ::std::unique_ptr< BloodStageProtectionLatencyType > bloodStageProtectionLatency,
         ::std::unique_ptr< BloodStageLengthDaysType > bloodStageLengthDays,
         ::std::unique_ptr< ClinicalEventsType > clinicalEvents)
  : ::xml_schema::Type (),
    probBloodStageInfectiousToMosq_ (std::move (probBloodStageInfectiousToMosq), this),
    hypnozoiteRelease_ (std::move (hypnozoiteRelease), this),
    bloodStageProtectionLatency_ (std::move (bloodStageProtectionLatency), this),
    bloodStageLengthDays_ (std::move (bloodStageLengthDays), this),
    clinicalEvents_ (std::move (clinicalEvents), this)
  {
  }

  Vivax::
  Vivax (const Vivax& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    probBloodStageInfectiousToMosq_ (x.probBloodStageInfectiousToMosq_, f, this),
    hypnozoiteRelease_ (x.hypnozoiteRelease_, f, this),
    bloodStageProtectionLatency_ (x.bloodStageProtectionLatency_, f, this),
    bloodStageLengthDays_ (x.bloodStageLengthDays_, f, this),
    clinicalEvents_ (x.clinicalEvents_, f, this)
  {
  }

  Vivax::
  Vivax (const xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    probBloodStageInfectiousToMosq_ (this),
    hypnozoiteRelease_ (this),
    bloodStageProtectionLatency_ (this),
    bloodStageLengthDays_ (this),
    clinicalEvents_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Vivax::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // probBloodStageInfectiousToMosq
      //
      if (n.name () == "probBloodStageInfectiousToMosq" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ProbBloodStageInfectiousToMosqType > r (
          ProbBloodStageInfectiousToMosqTraits::create (i, f, this));

        if (!probBloodStageInfectiousToMosq_.present ())
        {
          this->probBloodStageInfectiousToMosq_.set (::std::move (r));
          continue;
        }
      }

      // hypnozoiteRelease
      //
      if (n.name () == "hypnozoiteRelease" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< HypnozoiteReleaseType > r (
          HypnozoiteReleaseTraits::create (i, f, this));

        if (!hypnozoiteRelease_.present ())
        {
          this->hypnozoiteRelease_.set (::std::move (r));
          continue;
        }
      }

      // bloodStageProtectionLatency
      //
      if (n.name () == "bloodStageProtectionLatency" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< BloodStageProtectionLatencyType > r (
          BloodStageProtectionLatencyTraits::create (i, f, this));

        if (!bloodStageProtectionLatency_.present ())
        {
          this->bloodStageProtectionLatency_.set (::std::move (r));
          continue;
        }
      }

      // bloodStageLengthDays
      //
      if (n.name () == "bloodStageLengthDays" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< BloodStageLengthDaysType > r (
          BloodStageLengthDaysTraits::create (i, f, this));

        if (!bloodStageLengthDays_.present ())
        {
          this->bloodStageLengthDays_.set (::std::move (r));
          continue;
        }
      }

      // clinicalEvents
      //
      if (n.name () == "clinicalEvents" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ClinicalEventsType > r (
          ClinicalEventsTraits::create (i, f, this));

        if (!clinicalEvents_.present ())
        {
          this->clinicalEvents_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!probBloodStageInfectiousToMosq_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "probBloodStageInfectiousToMosq",
        "");
    }

    if (!hypnozoiteRelease_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "hypnozoiteRelease",
        "");
    }

    if (!bloodStageProtectionLatency_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "bloodStageProtectionLatency",
        "");
    }

    if (!bloodStageLengthDays_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "bloodStageLengthDays",
        "");
    }

    if (!clinicalEvents_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "clinicalEvents",
        "");
    }
  }

  Vivax* Vivax::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Vivax (*this, f, c);
  }

  Vivax& Vivax::
  operator= (const Vivax& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->probBloodStageInfectiousToMosq_ = x.probBloodStageInfectiousToMosq_;
      this->hypnozoiteRelease_ = x.hypnozoiteRelease_;
      this->bloodStageProtectionLatency_ = x.bloodStageProtectionLatency_;
      this->bloodStageLengthDays_ = x.bloodStageLengthDays_;
      this->clinicalEvents_ = x.clinicalEvents_;
    }

    return *this;
  }

  Vivax::
  ~Vivax ()
  {
  }

  // HypnozoiteRelease
  //

  HypnozoiteRelease::
  HypnozoiteRelease (const NumberHypnozoitesType& numberHypnozoites,
                     const FirstReleaseType& firstRelease)
  : ::xml_schema::Type (),
    numberHypnozoites_ (numberHypnozoites, this),
    firstRelease_ (firstRelease, this),
    secondRelease_ (this),
    pSecondRelease_ (getPSecondReleaseDefaultValue (), this)
  {
  }

  HypnozoiteRelease::
  HypnozoiteRelease (::std::unique_ptr< NumberHypnozoitesType > numberHypnozoites,
                     ::std::unique_ptr< FirstReleaseType > firstRelease)
  : ::xml_schema::Type (),
    numberHypnozoites_ (std::move (numberHypnozoites), this),
    firstRelease_ (std::move (firstRelease), this),
    secondRelease_ (this),
    pSecondRelease_ (getPSecondReleaseDefaultValue (), this)
  {
  }

  HypnozoiteRelease::
  HypnozoiteRelease (const HypnozoiteRelease& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    numberHypnozoites_ (x.numberHypnozoites_, f, this),
    firstRelease_ (x.firstRelease_, f, this),
    secondRelease_ (x.secondRelease_, f, this),
    pSecondRelease_ (x.pSecondRelease_, f, this)
  {
  }

  HypnozoiteRelease::
  HypnozoiteRelease (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    numberHypnozoites_ (this),
    firstRelease_ (this),
    secondRelease_ (this),
    pSecondRelease_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void HypnozoiteRelease::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // numberHypnozoites
      //
      if (n.name () == "numberHypnozoites" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< NumberHypnozoitesType > r (
          NumberHypnozoitesTraits::create (i, f, this));

        if (!numberHypnozoites_.present ())
        {
          this->numberHypnozoites_.set (::std::move (r));
          continue;
        }
      }

      // firstRelease
      //
      if (n.name () == "firstRelease" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< FirstReleaseType > r (
          FirstReleaseTraits::create (i, f, this));

        if (!firstRelease_.present ())
        {
          this->firstRelease_.set (::std::move (r));
          continue;
        }
      }

      // secondRelease
      //
      if (n.name () == "secondRelease" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SecondReleaseType > r (
          SecondReleaseTraits::create (i, f, this));

        if (!this->secondRelease_)
        {
          this->secondRelease_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!numberHypnozoites_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "numberHypnozoites",
        "");
    }

    if (!firstRelease_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "firstRelease",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "pSecondRelease" && n.namespace_ ().empty ())
      {
        this->pSecondRelease_.set (PSecondReleaseTraits::create (i, f, this));
        continue;
      }
    }

    if (!pSecondRelease_.present ())
    {
      this->pSecondRelease_.set (getPSecondReleaseDefaultValue ());
    }
  }

  HypnozoiteRelease* HypnozoiteRelease::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HypnozoiteRelease (*this, f, c);
  }

  HypnozoiteRelease& HypnozoiteRelease::
  operator= (const HypnozoiteRelease& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->numberHypnozoites_ = x.numberHypnozoites_;
      this->firstRelease_ = x.firstRelease_;
      this->secondRelease_ = x.secondRelease_;
      this->pSecondRelease_ = x.pSecondRelease_;
    }

    return *this;
  }

  HypnozoiteRelease::
  ~HypnozoiteRelease ()
  {
  }

  // HypnozoiteReleaseDistribution
  //

  HypnozoiteReleaseDistribution::
  HypnozoiteReleaseDistribution (const MuType& mu,
                                 const SigmaType& sigma,
                                 const LatentRelapseDaysType& latentRelapseDays)
  : ::scnXml::NormalSample (mu,
                            sigma),
    latentRelapseDays_ (latentRelapseDays, this)
  {
  }

  HypnozoiteReleaseDistribution::
  HypnozoiteReleaseDistribution (const HypnozoiteReleaseDistribution& x,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::scnXml::NormalSample (x, f, c),
    latentRelapseDays_ (x.latentRelapseDays_, f, this)
  {
  }

  HypnozoiteReleaseDistribution::
  HypnozoiteReleaseDistribution (const xercesc::DOMElement& e,
                                 ::xml_schema::Flags f,
                                 ::xml_schema::Container* c)
  : ::scnXml::NormalSample (e, f | ::xml_schema::Flags::base, c),
    latentRelapseDays_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void HypnozoiteReleaseDistribution::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::NormalSample::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "latentRelapseDays" && n.namespace_ ().empty ())
      {
        this->latentRelapseDays_.set (LatentRelapseDaysTraits::create (i, f, this));
        continue;
      }
    }

    if (!latentRelapseDays_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "latentRelapseDays",
        "");
    }
  }

  HypnozoiteReleaseDistribution* HypnozoiteReleaseDistribution::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HypnozoiteReleaseDistribution (*this, f, c);
  }

  HypnozoiteReleaseDistribution& HypnozoiteReleaseDistribution::
  operator= (const HypnozoiteReleaseDistribution& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::NormalSample& > (*this) = x;
      this->latentRelapseDays_ = x.latentRelapseDays_;
    }

    return *this;
  }

  HypnozoiteReleaseDistribution::
  ~HypnozoiteReleaseDistribution ()
  {
  }

  // ClinicalEvents
  //

  ClinicalEvents::
  ClinicalEvents (const PPrimaryInfectionType& pPrimaryInfection,
                  const PRelapseOneType& pRelapseOne,
                  const PRelapseTwoPlusType& pRelapseTwoPlus,
                  const PEventIsSevereType& pEventIsSevere)
  : ::xml_schema::Type (),
    pPrimaryInfection_ (pPrimaryInfection, this),
    pRelapseOne_ (pRelapseOne, this),
    pRelapseTwoPlus_ (pRelapseTwoPlus, this),
    pEventIsSevere_ (pEventIsSevere, this)
  {
  }

  ClinicalEvents::
  ClinicalEvents (::std::unique_ptr< PPrimaryInfectionType > pPrimaryInfection,
                  ::std::unique_ptr< PRelapseOneType > pRelapseOne,
                  ::std::unique_ptr< PRelapseTwoPlusType > pRelapseTwoPlus,
                  ::std::unique_ptr< PEventIsSevereType > pEventIsSevere)
  : ::xml_schema::Type (),
    pPrimaryInfection_ (std::move (pPrimaryInfection), this),
    pRelapseOne_ (std::move (pRelapseOne), this),
    pRelapseTwoPlus_ (std::move (pRelapseTwoPlus), this),
    pEventIsSevere_ (std::move (pEventIsSevere), this)
  {
  }

  ClinicalEvents::
  ClinicalEvents (const ClinicalEvents& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    pPrimaryInfection_ (x.pPrimaryInfection_, f, this),
    pRelapseOne_ (x.pRelapseOne_, f, this),
    pRelapseTwoPlus_ (x.pRelapseTwoPlus_, f, this),
    pEventIsSevere_ (x.pEventIsSevere_, f, this)
  {
  }

  ClinicalEvents::
  ClinicalEvents (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    pPrimaryInfection_ (this),
    pRelapseOne_ (this),
    pRelapseTwoPlus_ (this),
    pEventIsSevere_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ClinicalEvents::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // pPrimaryInfection
      //
      if (n.name () == "pPrimaryInfection" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PPrimaryInfectionType > r (
          PPrimaryInfectionTraits::create (i, f, this));

        if (!pPrimaryInfection_.present ())
        {
          this->pPrimaryInfection_.set (::std::move (r));
          continue;
        }
      }

      // pRelapseOne
      //
      if (n.name () == "pRelapseOne" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PRelapseOneType > r (
          PRelapseOneTraits::create (i, f, this));

        if (!pRelapseOne_.present ())
        {
          this->pRelapseOne_.set (::std::move (r));
          continue;
        }
      }

      // pRelapseTwoPlus
      //
      if (n.name () == "pRelapseTwoPlus" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PRelapseTwoPlusType > r (
          PRelapseTwoPlusTraits::create (i, f, this));

        if (!pRelapseTwoPlus_.present ())
        {
          this->pRelapseTwoPlus_.set (::std::move (r));
          continue;
        }
      }

      // pEventIsSevere
      //
      if (n.name () == "pEventIsSevere" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PEventIsSevereType > r (
          PEventIsSevereTraits::create (i, f, this));

        if (!pEventIsSevere_.present ())
        {
          this->pEventIsSevere_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!pPrimaryInfection_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pPrimaryInfection",
        "");
    }

    if (!pRelapseOne_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pRelapseOne",
        "");
    }

    if (!pRelapseTwoPlus_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pRelapseTwoPlus",
        "");
    }

    if (!pEventIsSevere_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "pEventIsSevere",
        "");
    }
  }

  ClinicalEvents* ClinicalEvents::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ClinicalEvents (*this, f, c);
  }

  ClinicalEvents& ClinicalEvents::
  operator= (const ClinicalEvents& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->pPrimaryInfection_ = x.pPrimaryInfection_;
      this->pRelapseOne_ = x.pRelapseOne_;
      this->pRelapseTwoPlus_ = x.pRelapseTwoPlus_;
      this->pEventIsSevere_ = x.pEventIsSevere_;
    }

    return *this;
  }

  ClinicalEvents::
  ~ClinicalEvents ()
  {
  }

  // ProbVivaxEvent
  //

  ProbVivaxEvent::
  ProbVivaxEvent (const AType& a,
                  const BType& b)
  : ::xml_schema::Type (),
    a_ (a, this),
    b_ (b, this)
  {
  }

  ProbVivaxEvent::
  ProbVivaxEvent (const ProbVivaxEvent& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    a_ (x.a_, f, this),
    b_ (x.b_, f, this)
  {
  }

  ProbVivaxEvent::
  ProbVivaxEvent (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    a_ (this),
    b_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ProbVivaxEvent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "a" && n.namespace_ ().empty ())
      {
        this->a_.set (ATraits::create (i, f, this));
        continue;
      }

      if (n.name () == "b" && n.namespace_ ().empty ())
      {
        this->b_.set (BTraits::create (i, f, this));
        continue;
      }
    }

    if (!a_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "a",
        "");
    }

    if (!b_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "b",
        "");
    }
  }

  ProbVivaxEvent* ProbVivaxEvent::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ProbVivaxEvent (*this, f, c);
  }

  ProbVivaxEvent& ProbVivaxEvent::
  operator= (const ProbVivaxEvent& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->a_ = x.a_;
      this->b_ = x.b_;
    }

    return *this;
  }

  ProbVivaxEvent::
  ~ProbVivaxEvent ()
  {
  }

  // ParasiteGenetics
  //

  ParasiteGenetics::
  ParasiteGenetics (const SamplingModeType& samplingMode)
  : ::xml_schema::Type (),
    locus_ (this),
    samplingMode_ (samplingMode, this)
  {
  }

  ParasiteGenetics::
  ParasiteGenetics (const ParasiteGenetics& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    locus_ (x.locus_, f, this),
    samplingMode_ (x.samplingMode_, f, this)
  {
  }

  ParasiteGenetics::
  ParasiteGenetics (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    locus_ (this),
    samplingMode_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ParasiteGenetics::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // locus
      //
      if (n.name () == "locus" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< LocusType > r (
          LocusTraits::create (i, f, this));

        this->locus_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "samplingMode" && n.namespace_ ().empty ())
      {
        this->samplingMode_.set (SamplingModeTraits::create (i, f, this));
        continue;
      }
    }

    if (!samplingMode_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "samplingMode",
        "");
    }
  }

  ParasiteGenetics* ParasiteGenetics::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParasiteGenetics (*this, f, c);
  }

  ParasiteGenetics& ParasiteGenetics::
  operator= (const ParasiteGenetics& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->locus_ = x.locus_;
      this->samplingMode_ = x.samplingMode_;
    }

    return *this;
  }

  ParasiteGenetics::
  ~ParasiteGenetics ()
  {
  }

  // ParasiteGenotype
  //

  ParasiteGenotype::
  ParasiteGenotype (const NameType& name,
                    const InitialFrequencyType& initialFrequency,
                    const FitnessType& fitness)
  : ::xml_schema::Type (),
    name_ (name, this),
    initialFrequency_ (initialFrequency, this),
    fitness_ (fitness, this)
  {
  }

  ParasiteGenotype::
  ParasiteGenotype (const ParasiteGenotype& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    initialFrequency_ (x.initialFrequency_, f, this),
    fitness_ (x.fitness_, f, this)
  {
  }

  ParasiteGenotype::
  ParasiteGenotype (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    initialFrequency_ (this),
    fitness_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ParasiteGenotype::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "initialFrequency" && n.namespace_ ().empty ())
      {
        this->initialFrequency_.set (InitialFrequencyTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "fitness" && n.namespace_ ().empty ())
      {
        this->fitness_.set (FitnessTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!initialFrequency_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "initialFrequency",
        "");
    }

    if (!fitness_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "fitness",
        "");
    }
  }

  ParasiteGenotype* ParasiteGenotype::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParasiteGenotype (*this, f, c);
  }

  ParasiteGenotype& ParasiteGenotype::
  operator= (const ParasiteGenotype& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->initialFrequency_ = x.initialFrequency_;
      this->fitness_ = x.fitness_;
    }

    return *this;
  }

  ParasiteGenotype::
  ~ParasiteGenotype ()
  {
  }

  // ParasiteLocus
  //

  ParasiteLocus::
  ParasiteLocus (const NameType& name)
  : ::xml_schema::Type (),
    allele_ (this),
    name_ (name, this)
  {
  }

  ParasiteLocus::
  ParasiteLocus (const ParasiteLocus& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    allele_ (x.allele_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ParasiteLocus::
  ParasiteLocus (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    allele_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ParasiteLocus::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // allele
      //
      if (n.name () == "allele" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AlleleType > r (
          AlleleTraits::create (i, f, this));

        this->allele_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  ParasiteLocus* ParasiteLocus::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParasiteLocus (*this, f, c);
  }

  ParasiteLocus& ParasiteLocus::
  operator= (const ParasiteLocus& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->allele_ = x.allele_;
      this->name_ = x.name_;
    }

    return *this;
  }

  ParasiteLocus::
  ~ParasiteLocus ()
  {
  }

  // ParasiteAllele
  //

  ParasiteAllele::
  ParasiteAllele (const NameType& name,
                  const InitialFrequencyType& initialFrequency,
                  const FitnessType& fitness)
  : ::xml_schema::Type (),
    name_ (name, this),
    initialFrequency_ (initialFrequency, this),
    fitness_ (fitness, this)
  {
  }

  ParasiteAllele::
  ParasiteAllele (const ParasiteAllele& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    name_ (x.name_, f, this),
    initialFrequency_ (x.initialFrequency_, f, this),
    fitness_ (x.fitness_, f, this)
  {
  }

  ParasiteAllele::
  ParasiteAllele (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    name_ (this),
    initialFrequency_ (this),
    fitness_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ParasiteAllele::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "initialFrequency" && n.namespace_ ().empty ())
      {
        this->initialFrequency_.set (InitialFrequencyTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "fitness" && n.namespace_ ().empty ())
      {
        this->fitness_.set (FitnessTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }

    if (!initialFrequency_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "initialFrequency",
        "");
    }

    if (!fitness_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "fitness",
        "");
    }
  }

  ParasiteAllele* ParasiteAllele::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ParasiteAllele (*this, f, c);
  }

  ParasiteAllele& ParasiteAllele::
  operator= (const ParasiteAllele& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->name_ = x.name_;
      this->initialFrequency_ = x.initialFrequency_;
      this->fitness_ = x.fitness_;
    }

    return *this;
  }

  ParasiteAllele::
  ~ParasiteAllele ()
  {
  }

  // Diagnostics
  //

  Diagnostics::
  Diagnostics ()
  : ::xml_schema::Type (),
    diagnostic_ (this)
  {
  }

  Diagnostics::
  Diagnostics (const Diagnostics& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    diagnostic_ (x.diagnostic_, f, this)
  {
  }

  Diagnostics::
  Diagnostics (const xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    diagnostic_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Diagnostics::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // diagnostic
      //
      if (n.name () == "diagnostic" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DiagnosticType > r (
          DiagnosticTraits::create (i, f, this));

        this->diagnostic_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Diagnostics* Diagnostics::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Diagnostics (*this, f, c);
  }

  Diagnostics& Diagnostics::
  operator= (const Diagnostics& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->diagnostic_ = x.diagnostic_;
    }

    return *this;
  }

  Diagnostics::
  ~Diagnostics ()
  {
  }

  // Diagnostic
  //

  Diagnostic::
  Diagnostic (const NameType& name)
  : ::xml_schema::Type (),
    deterministic_ (this),
    stochastic_ (this),
    name_ (name, this),
    units_ (this)
  {
  }

  Diagnostic::
  Diagnostic (const Diagnostic& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    deterministic_ (x.deterministic_, f, this),
    stochastic_ (x.stochastic_, f, this),
    name_ (x.name_, f, this),
    units_ (x.units_, f, this)
  {
  }

  Diagnostic::
  Diagnostic (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    deterministic_ (this),
    stochastic_ (this),
    name_ (this),
    units_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Diagnostic::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // deterministic
      //
      if (n.name () == "deterministic" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DeterministicType > r (
          DeterministicTraits::create (i, f, this));

        if (!this->deterministic_)
        {
          this->deterministic_.set (::std::move (r));
          continue;
        }
      }

      // stochastic
      //
      if (n.name () == "stochastic" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< StochasticType > r (
          StochasticTraits::create (i, f, this));

        if (!this->stochastic_)
        {
          this->stochastic_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "units" && n.namespace_ ().empty ())
      {
        this->units_.set (UnitsTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  Diagnostic* Diagnostic::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Diagnostic (*this, f, c);
  }

  Diagnostic& Diagnostic::
  operator= (const Diagnostic& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->deterministic_ = x.deterministic_;
      this->stochastic_ = x.stochastic_;
      this->name_ = x.name_;
      this->units_ = x.units_;
    }

    return *this;
  }

  Diagnostic::
  ~Diagnostic ()
  {
  }

  // Scenario
  //

  Scenario::
  Scenario (const DemographyType& demography,
            const MonitoringType& monitoring,
            const InterventionsType& interventions,
            const HealthSystemType& healthSystem,
            const EntomologyType& entomology,
            const ModelType& model,
            const SchemaVersionType& schemaVersion,
            const NameType& name)
  : ::xml_schema::Type (),
    demography_ (demography, this),
    monitoring_ (monitoring, this),
    interventions_ (interventions, this),
    healthSystem_ (healthSystem, this),
    entomology_ (entomology, this),
    parasiteGenetics_ (this),
    pharmacology_ (this),
    diagnostics_ (this),
    model_ (model, this),
    schemaVersion_ (schemaVersion, this),
    analysisNo_ (this),
    name_ (name, this),
    wuID_ (this)
  {
  }

  Scenario::
  Scenario (::std::unique_ptr< DemographyType > demography,
            ::std::unique_ptr< MonitoringType > monitoring,
            ::std::unique_ptr< InterventionsType > interventions,
            ::std::unique_ptr< HealthSystemType > healthSystem,
            ::std::unique_ptr< EntomologyType > entomology,
            ::std::unique_ptr< ModelType > model,
            const SchemaVersionType& schemaVersion,
            const NameType& name)
  : ::xml_schema::Type (),
    demography_ (std::move (demography), this),
    monitoring_ (std::move (monitoring), this),
    interventions_ (std::move (interventions), this),
    healthSystem_ (std::move (healthSystem), this),
    entomology_ (std::move (entomology), this),
    parasiteGenetics_ (this),
    pharmacology_ (this),
    diagnostics_ (this),
    model_ (std::move (model), this),
    schemaVersion_ (schemaVersion, this),
    analysisNo_ (this),
    name_ (name, this),
    wuID_ (this)
  {
  }

  Scenario::
  Scenario (const Scenario& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    demography_ (x.demography_, f, this),
    monitoring_ (x.monitoring_, f, this),
    interventions_ (x.interventions_, f, this),
    healthSystem_ (x.healthSystem_, f, this),
    entomology_ (x.entomology_, f, this),
    parasiteGenetics_ (x.parasiteGenetics_, f, this),
    pharmacology_ (x.pharmacology_, f, this),
    diagnostics_ (x.diagnostics_, f, this),
    model_ (x.model_, f, this),
    schemaVersion_ (x.schemaVersion_, f, this),
    analysisNo_ (x.analysisNo_, f, this),
    name_ (x.name_, f, this),
    wuID_ (x.wuID_, f, this)
  {
  }

  Scenario::
  Scenario (const xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    demography_ (this),
    monitoring_ (this),
    interventions_ (this),
    healthSystem_ (this),
    entomology_ (this),
    parasiteGenetics_ (this),
    pharmacology_ (this),
    diagnostics_ (this),
    model_ (this),
    schemaVersion_ (this),
    analysisNo_ (this),
    name_ (this),
    wuID_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Scenario::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // demography
      //
      if (n.name () == "demography" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DemographyType > r (
          DemographyTraits::create (i, f, this));

        if (!demography_.present ())
        {
          this->demography_.set (::std::move (r));
          continue;
        }
      }

      // monitoring
      //
      if (n.name () == "monitoring" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< MonitoringType > r (
          MonitoringTraits::create (i, f, this));

        if (!monitoring_.present ())
        {
          this->monitoring_.set (::std::move (r));
          continue;
        }
      }

      // interventions
      //
      if (n.name () == "interventions" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< InterventionsType > r (
          InterventionsTraits::create (i, f, this));

        if (!interventions_.present ())
        {
          this->interventions_.set (::std::move (r));
          continue;
        }
      }

      // healthSystem
      //
      if (n.name () == "healthSystem" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< HealthSystemType > r (
          HealthSystemTraits::create (i, f, this));

        if (!healthSystem_.present ())
        {
          this->healthSystem_.set (::std::move (r));
          continue;
        }
      }

      // entomology
      //
      if (n.name () == "entomology" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< EntomologyType > r (
          EntomologyTraits::create (i, f, this));

        if (!entomology_.present ())
        {
          this->entomology_.set (::std::move (r));
          continue;
        }
      }

      // parasiteGenetics
      //
      if (n.name () == "parasiteGenetics" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ParasiteGeneticsType > r (
          ParasiteGeneticsTraits::create (i, f, this));

        if (!this->parasiteGenetics_)
        {
          this->parasiteGenetics_.set (::std::move (r));
          continue;
        }
      }

      // pharmacology
      //
      if (n.name () == "pharmacology" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PharmacologyType > r (
          PharmacologyTraits::create (i, f, this));

        if (!this->pharmacology_)
        {
          this->pharmacology_.set (::std::move (r));
          continue;
        }
      }

      // diagnostics
      //
      if (n.name () == "diagnostics" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DiagnosticsType > r (
          DiagnosticsTraits::create (i, f, this));

        if (!this->diagnostics_)
        {
          this->diagnostics_.set (::std::move (r));
          continue;
        }
      }

      // model
      //
      if (n.name () == "model" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ModelType > r (
          ModelTraits::create (i, f, this));

        if (!model_.present ())
        {
          this->model_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!demography_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "demography",
        "");
    }

    if (!monitoring_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "monitoring",
        "");
    }

    if (!interventions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "interventions",
        "");
    }

    if (!healthSystem_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "healthSystem",
        "");
    }

    if (!entomology_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "entomology",
        "");
    }

    if (!model_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "model",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "schemaVersion" && n.namespace_ ().empty ())
      {
        this->schemaVersion_.set (SchemaVersionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "analysisNo" && n.namespace_ ().empty ())
      {
        this->analysisNo_.set (AnalysisNoTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "wuID" && n.namespace_ ().empty ())
      {
        this->wuID_.set (WuIDTraits::create (i, f, this));
        continue;
      }
    }

    if (!schemaVersion_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "schemaVersion",
        "");
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  Scenario* Scenario::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Scenario (*this, f, c);
  }

  Scenario& Scenario::
  operator= (const Scenario& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->demography_ = x.demography_;
      this->monitoring_ = x.monitoring_;
      this->interventions_ = x.interventions_;
      this->healthSystem_ = x.healthSystem_;
      this->entomology_ = x.entomology_;
      this->parasiteGenetics_ = x.parasiteGenetics_;
      this->pharmacology_ = x.pharmacology_;
      this->diagnostics_ = x.diagnostics_;
      this->model_ = x.model_;
      this->schemaVersion_ = x.schemaVersion_;
      this->analysisNo_ = x.analysisNo_;
      this->name_ = x.name_;
      this->wuID_ = x.wuID_;
    }

    return *this;
  }

  Scenario::
  ~Scenario ()
  {
  }

  // Weight
  //

  Weight::
  Weight (const MultStdDevType& multStdDev)
  : ::scnXml::AgeGroupValues (),
    multStdDev_ (multStdDev, this)
  {
  }

  Weight::
  Weight (const Weight& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::scnXml::AgeGroupValues (x, f, c),
    multStdDev_ (x.multStdDev_, f, this)
  {
  }

  Weight::
  Weight (const xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::scnXml::AgeGroupValues (e, f | ::xml_schema::Flags::base, c),
    multStdDev_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Weight::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::AgeGroupValues::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "multStdDev" && n.namespace_ ().empty ())
      {
        this->multStdDev_.set (MultStdDevTraits::create (i, f, this));
        continue;
      }
    }

    if (!multStdDev_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "multStdDev",
        "");
    }
  }

  Weight* Weight::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Weight (*this, f, c);
  }

  Weight& Weight::
  operator= (const Weight& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::AgeGroupValues& > (*this) = x;
      this->multStdDev_ = x.multStdDev_;
    }

    return *this;
  }

  Weight::
  ~Weight ()
  {
  }

  // BloodStageLengthDays
  //

  BloodStageLengthDays::
  BloodStageLengthDays (const WeibullScaleType& weibullScale,
                        const WeibullShapeType& weibullShape)
  : ::xml_schema::Type (),
    weibullScale_ (weibullScale, this),
    weibullShape_ (weibullShape, this)
  {
  }

  BloodStageLengthDays::
  BloodStageLengthDays (const BloodStageLengthDays& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    weibullScale_ (x.weibullScale_, f, this),
    weibullShape_ (x.weibullShape_, f, this)
  {
  }

  BloodStageLengthDays::
  BloodStageLengthDays (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    weibullScale_ (this),
    weibullShape_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void BloodStageLengthDays::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "weibullScale" && n.namespace_ ().empty ())
      {
        this->weibullScale_.set (WeibullScaleTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "weibullShape" && n.namespace_ ().empty ())
      {
        this->weibullShape_.set (WeibullShapeTraits::create (i, f, this));
        continue;
      }
    }

    if (!weibullScale_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "weibullScale",
        "");
    }

    if (!weibullShape_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "weibullShape",
        "");
    }
  }

  BloodStageLengthDays* BloodStageLengthDays::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class BloodStageLengthDays (*this, f, c);
  }

  BloodStageLengthDays& BloodStageLengthDays::
  operator= (const BloodStageLengthDays& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->weibullScale_ = x.weibullScale_;
      this->weibullShape_ = x.weibullShape_;
    }

    return *this;
  }

  BloodStageLengthDays::
  ~BloodStageLengthDays ()
  {
  }

  // NumberHypnozoites
  //

  NumberHypnozoites::
  NumberHypnozoites (const MaxType& max,
                     const BaseType& base)
  : ::xml_schema::Type (),
    max_ (max, this),
    base_ (base, this)
  {
  }

  NumberHypnozoites::
  NumberHypnozoites (const NumberHypnozoites& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    max_ (x.max_, f, this),
    base_ (x.base_, f, this)
  {
  }

  NumberHypnozoites::
  NumberHypnozoites (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    max_ (this),
    base_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void NumberHypnozoites::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "max" && n.namespace_ ().empty ())
      {
        this->max_.set (MaxTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "base" && n.namespace_ ().empty ())
      {
        this->base_.set (BaseTraits::create (i, f, this));
        continue;
      }
    }

    if (!max_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "max",
        "");
    }

    if (!base_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "base",
        "");
    }
  }

  NumberHypnozoites* NumberHypnozoites::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class NumberHypnozoites (*this, f, c);
  }

  NumberHypnozoites& NumberHypnozoites::
  operator= (const NumberHypnozoites& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->max_ = x.max_;
      this->base_ = x.base_;
    }

    return *this;
  }

  NumberHypnozoites::
  ~NumberHypnozoites ()
  {
  }

  // SamplingMode
  //

  SamplingMode::
  SamplingMode (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_SamplingMode_convert ();
  }

  SamplingMode::
  SamplingMode (const xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_SamplingMode_convert ();
  }

  SamplingMode::
  SamplingMode (const ::std::string& s,
                const xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_SamplingMode_convert ();
  }

  SamplingMode* SamplingMode::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SamplingMode (*this, f, c);
  }

  SamplingMode::Value SamplingMode::
  _xsd_SamplingMode_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_SamplingMode_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_SamplingMode_indexes_,
                      _xsd_SamplingMode_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_SamplingMode_indexes_ + 2 || _xsd_SamplingMode_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const SamplingMode::
  _xsd_SamplingMode_literals_[2] =
  {
    "initial",
    "tracking"
  };

  const SamplingMode::Value SamplingMode::
  _xsd_SamplingMode_indexes_[2] =
  {
    ::scnXml::SamplingMode::initial,
    ::scnXml::SamplingMode::tracking
  };

  // Deterministic
  //

  Deterministic::
  Deterministic (const MinDensityType& minDensity)
  : ::xml_schema::Type (),
    minDensity_ (minDensity, this)
  {
  }

  Deterministic::
  Deterministic (const Deterministic& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    minDensity_ (x.minDensity_, f, this)
  {
  }

  Deterministic::
  Deterministic (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    minDensity_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Deterministic::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "minDensity" && n.namespace_ ().empty ())
      {
        this->minDensity_.set (MinDensityTraits::create (i, f, this));
        continue;
      }
    }

    if (!minDensity_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "minDensity",
        "");
    }
  }

  Deterministic* Deterministic::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Deterministic (*this, f, c);
  }

  Deterministic& Deterministic::
  operator= (const Deterministic& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->minDensity_ = x.minDensity_;
    }

    return *this;
  }

  Deterministic::
  ~Deterministic ()
  {
  }

  // Stochastic
  //

  Stochastic::
  Stochastic (const Dens_50Type& dens_50,
              const SpecificityType& specificity)
  : ::xml_schema::Type (),
    dens_50_ (dens_50, this),
    specificity_ (specificity, this)
  {
  }

  Stochastic::
  Stochastic (const Stochastic& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    dens_50_ (x.dens_50_, f, this),
    specificity_ (x.specificity_, f, this)
  {
  }

  Stochastic::
  Stochastic (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    dens_50_ (this),
    specificity_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Stochastic::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "dens_50" && n.namespace_ ().empty ())
      {
        this->dens_50_.set (Dens_50Traits::create (i, f, this));
        continue;
      }

      if (n.name () == "specificity" && n.namespace_ ().empty ())
      {
        this->specificity_.set (SpecificityTraits::create (i, f, this));
        continue;
      }
    }

    if (!dens_50_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "dens_50",
        "");
    }

    if (!specificity_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "specificity",
        "");
    }
  }

  Stochastic* Stochastic::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Stochastic (*this, f, c);
  }

  Stochastic& Stochastic::
  operator= (const Stochastic& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->dens_50_ = x.dens_50_;
      this->specificity_ = x.specificity_;
    }

    return *this;
  }

  Stochastic::
  ~Stochastic ()
  {
  }

  // Units
  //

  Units::
  Units (const xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (e, f, c)
  {
    _xsd_Units_convert ();
  }

  Units::
  Units (const xercesc::DOMAttr& a,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (a, f, c)
  {
    _xsd_Units_convert ();
  }

  Units::
  Units (const ::std::string& s,
         const xercesc::DOMElement* e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::String (s, e, f, c)
  {
    _xsd_Units_convert ();
  }

  Units* Units::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Units (*this, f, c);
  }

  Units::Value Units::
  _xsd_Units_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Units_literals_);
    const Value* i (::std::lower_bound (
                      _xsd_Units_indexes_,
                      _xsd_Units_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_Units_indexes_ + 3 || _xsd_Units_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Units::
  _xsd_Units_literals_[3] =
  {
    "Other",
    "Garki",
    "Malariatherapy"
  };

  const Units::Value Units::
  _xsd_Units_indexes_[3] =
  {
    ::scnXml::Units::Garki,
    ::scnXml::Units::Malariatherapy,
    ::scnXml::Units::Other
  };

  // Model
  //

  Model::
  Model (const ModelOptionsType& ModelOptions,
         const ClinicalType& clinical,
         const HumanType& human,
         const ParametersType& parameters)
  : ::xml_schema::Type (),
    ModelOptions_ (ModelOptions, this),
    clinical_ (clinical, this),
    human_ (human, this),
    vivax_ (this),
    parameters_ (parameters, this)
  {
  }

  Model::
  Model (::std::unique_ptr< ModelOptionsType > ModelOptions,
         ::std::unique_ptr< ClinicalType > clinical,
         ::std::unique_ptr< HumanType > human,
         ::std::unique_ptr< ParametersType > parameters)
  : ::xml_schema::Type (),
    ModelOptions_ (std::move (ModelOptions), this),
    clinical_ (std::move (clinical), this),
    human_ (std::move (human), this),
    vivax_ (this),
    parameters_ (std::move (parameters), this)
  {
  }

  Model::
  Model (const Model& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    ModelOptions_ (x.ModelOptions_, f, this),
    clinical_ (x.clinical_, f, this),
    human_ (x.human_, f, this),
    vivax_ (x.vivax_, f, this),
    parameters_ (x.parameters_, f, this)
  {
  }

  Model::
  Model (const xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    ModelOptions_ (this),
    clinical_ (this),
    human_ (this),
    vivax_ (this),
    parameters_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Model::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // ModelOptions
      //
      if (n.name () == "ModelOptions" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ModelOptionsType > r (
          ModelOptionsTraits::create (i, f, this));

        if (!ModelOptions_.present ())
        {
          this->ModelOptions_.set (::std::move (r));
          continue;
        }
      }

      // clinical
      //
      if (n.name () == "clinical" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ClinicalType > r (
          ClinicalTraits::create (i, f, this));

        if (!clinical_.present ())
        {
          this->clinical_.set (::std::move (r));
          continue;
        }
      }

      // human
      //
      if (n.name () == "human" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< HumanType > r (
          HumanTraits::create (i, f, this));

        if (!human_.present ())
        {
          this->human_.set (::std::move (r));
          continue;
        }
      }

      // vivax
      //
      if (n.name () == "vivax" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< VivaxType > r (
          VivaxTraits::create (i, f, this));

        if (!this->vivax_)
        {
          this->vivax_.set (::std::move (r));
          continue;
        }
      }

      // parameters
      //
      if (n.name () == "parameters" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ParametersType > r (
          ParametersTraits::create (i, f, this));

        if (!parameters_.present ())
        {
          this->parameters_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!ModelOptions_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ModelOptions",
        "");
    }

    if (!clinical_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "clinical",
        "");
    }

    if (!human_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "human",
        "");
    }

    if (!parameters_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "parameters",
        "");
    }
  }

  Model* Model::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Model (*this, f, c);
  }

  Model& Model::
  operator= (const Model& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->ModelOptions_ = x.ModelOptions_;
      this->clinical_ = x.clinical_;
      this->human_ = x.human_;
      this->vivax_ = x.vivax_;
      this->parameters_ = x.parameters_;
    }

    return *this;
  }

  Model::
  ~Model ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace scnXml
{
  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (const ::std::string& u,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::scnXml::Scenario > (
      ::scnXml::parseScenario (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (const ::std::string& u,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xml_schema::dom::unique_ptr< xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::scnXml::Scenario > (
      ::scnXml::parseScenario (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (const ::std::string& u,
                 xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::scnXml::Scenario > (
      ::scnXml::parseScenario (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::std::istream& is,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::scnXml::parseScenario (isrc, f, p);
  }

  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::std::istream& is,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::scnXml::parseScenario (isrc, h, f, p);
  }

  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::std::istream& is,
                 xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::scnXml::parseScenario (isrc, h, f, p);
  }

  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::scnXml::parseScenario (isrc, f, p);
  }

  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::std::istream& is,
                 const ::std::string& sid,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::Flags::dont_initialize) == 0,
      (f & ::xml_schema::Flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::scnXml::parseScenario (isrc, h, f, p);
  }

  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::std::istream& is,
                 const ::std::string& sid,
                 xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::scnXml::parseScenario (isrc, h, f, p);
  }

  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (xercesc::InputSource& i,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::unique_ptr< xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    return ::std::unique_ptr< ::scnXml::Scenario > (
      ::scnXml::parseScenario (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (xercesc::InputSource& i,
                 ::xml_schema::ErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::scnXml::Scenario > (
      ::scnXml::parseScenario (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (xercesc::InputSource& i,
                 xercesc::DOMErrorHandler& h,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    ::xml_schema::dom::unique_ptr< xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    return ::std::unique_ptr< ::scnXml::Scenario > (
      ::scnXml::parseScenario (
        std::move (d), f | ::xml_schema::Flags::own_dom, p));
  }

  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (const xercesc::DOMDocument& doc,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties& p)
  {
    if (f & ::xml_schema::Flags::keep_dom)
    {
      ::xml_schema::dom::unique_ptr< xercesc::DOMDocument > d (
        static_cast< xercesc::DOMDocument* > (doc.cloneNode (true)));

      return ::std::unique_ptr< ::scnXml::Scenario > (
        ::scnXml::parseScenario (
          std::move (d), f | ::xml_schema::Flags::own_dom, p));
    }

    const xercesc::DOMElement& e (*doc.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "scenario" &&
        n.namespace_ () == "http://openmalaria.org/schema/scenario_39")
    {
      ::std::unique_ptr< ::scnXml::Scenario > r (
        ::xsd::cxx::tree::traits< ::scnXml::Scenario, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "scenario",
      "http://openmalaria.org/schema/scenario_39");
  }

  ::std::unique_ptr< ::scnXml::Scenario >
  parseScenario (::xml_schema::dom::unique_ptr< xercesc::DOMDocument > d,
                 ::xml_schema::Flags f,
                 const ::xml_schema::Properties&)
  {
    ::xml_schema::dom::unique_ptr< xercesc::DOMDocument > c (
      ((f & ::xml_schema::Flags::keep_dom) &&
       !(f & ::xml_schema::Flags::own_dom))
      ? static_cast< xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::Flags::keep_dom)
      doc.setUserData (::xml_schema::dom::treeNodeKey,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "scenario" &&
        n.namespace_ () == "http://openmalaria.org/schema/scenario_39")
    {
      ::std::unique_ptr< ::scnXml::Scenario > r (
        ::xsd::cxx::tree::traits< ::scnXml::Scenario, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "scenario",
      "http://openmalaria.org/schema/scenario_39");
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.


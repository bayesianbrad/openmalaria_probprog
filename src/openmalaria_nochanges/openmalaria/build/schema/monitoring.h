// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from monitoring.xsd.
 */

#ifndef CXX_CODE_OPENMALARIA_SCHEMA_MONITORING_H
#define CXX_CODE_OPENMALARIA_SCHEMA_MONITORING_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type Type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type Container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char Byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char UnsignedByte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short Short;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short UnsignedShort;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int Int;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int UnsignedInt;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long Long;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long UnsignedLong;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long Integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long NonPositiveInteger;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long NonNegativeInteger;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long PositiveInteger;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long NegativeInteger;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool Boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float Float;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double Double;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double Decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, Token > Name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, Token > Language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > Buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone TimeZone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags Flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity Severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > Error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > Exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > Bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > Parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace scnXml
{
  class Monitoring;
  class MonAgeGroup;
  class MonGroupBounds;
  class Cohorts;
  class CohortSubPop;
  class MonitoringOptions;
  class MonitoringOption;
  class Continuous;
  class Surveys;
  class SurveyTime;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "util.h"

/**
 * @brief C++ namespace for the %http://openmalaria.org/schema/scenario_39
 * schema namespace.
 */
namespace scnXml
{
  /**
   * @brief Class corresponding to the %Monitoring schema type.
   *
   * @nosubgrouping
   */
  class Monitoring: public ::xml_schema::Type
  {
    public:
    /**
     * @name continuous
     *
     * @brief Accessor and modifier functions for the %continuous
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Continuous ContinuousType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ContinuousType > ContinuousOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ContinuousType, char > ContinuousTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ContinuousOptional&
    getContinuous () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ContinuousOptional&
    getContinuous ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setContinuous (const ContinuousType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setContinuous (const ContinuousOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setContinuous (::std::unique_ptr< ContinuousType > p);

    //@}

    /**
     * @name SurveyOptions
     *
     * @brief Accessor and modifier functions for the %SurveyOptions
     * required element.
     *
     * List of all active survey options. See model/mon/OutputMeasures.h for
     * a list of
     * supported outputs. Should also be on the wiki.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::MonitoringOptions SurveyOptionsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SurveyOptionsType, char > SurveyOptionsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SurveyOptionsType&
    getSurveyOptions () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SurveyOptionsType&
    getSurveyOptions ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSurveyOptions (const SurveyOptionsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSurveyOptions (::std::unique_ptr< SurveyOptionsType > p);

    //@}

    /**
     * @name surveys
     *
     * @brief Accessor and modifier functions for the %surveys
     * required element.
     *
     * List of survey times
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Surveys SurveysType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SurveysType, char > SurveysTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SurveysType&
    getSurveys () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SurveysType&
    getSurveys ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSurveys (const SurveysType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSurveys (::std::unique_ptr< SurveysType > p);

    //@}

    /**
     * @name ageGroup
     *
     * @brief Accessor and modifier functions for the %ageGroup
     * required element.
     *
     * List of age groups included in demography or surveys
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::MonAgeGroup AgeGroupType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AgeGroupType, char > AgeGroupTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const AgeGroupType&
    getAgeGroup () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    AgeGroupType&
    getAgeGroup ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAgeGroup (const AgeGroupType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setAgeGroup (::std::unique_ptr< AgeGroupType > p);

    //@}

    /**
     * @name cohorts
     *
     * @brief Accessor and modifier functions for the %cohorts
     * optional element.
     *
     * Allows the configuration of multiple cohorts (output segregated
     * according to membership within specific sub-populations).
     * 
     * If this element is omitted, monitoring surveys cover the entire
     * simulated human population.
     * 
     * It does not affect the "continuous" outputs (these never take
     * cohorts into account).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Cohorts CohortsType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CohortsType > CohortsOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CohortsType, char > CohortsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CohortsOptional&
    getCohorts () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CohortsOptional&
    getCohorts ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCohorts (const CohortsType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCohorts (const CohortsOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCohorts (::std::unique_ptr< CohortsType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * required attribute.
     *
     * Name of monitoring settings
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NameType&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NameType&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name startDate
     *
     * @brief Accessor and modifier functions for the %startDate
     * optional attribute.
     *
     * An optional date for the start of monitoring. If given, dates may be
     * used to specify when other events (surveys, intervention deployments)
     * occur; alternately times relative to the start of the intervention
     * period may be used to specify event times.
     * 
     * Setting this to 1st January of some year might simplify usage of
     * dates, and putting the start a couple of years before the start of
     * intervention deployment (along with some extra surveys) may be useful
     * to check transmission stabilises to the expected pre-intervention
     * levels.
     * 
     * As an example, if this date is set to 2000-01-01, then the following
     * event times are equivalent (assuming 1t=5d):
     * 15t, 75d, 0.2y, 2000-03-16.
     * 
     * Must be in the form YYYY-MM-DD, e.g. 2003-01-01.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String StartDateType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< StartDateType > StartDateOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< StartDateType, char > StartDateTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const StartDateOptional&
    getStartDate () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    StartDateOptional&
    getStartDate ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setStartDate (const StartDateType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setStartDate (const StartDateOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setStartDate (::std::unique_ptr< StartDateType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Monitoring (const SurveyOptionsType&,
                const SurveysType&,
                const AgeGroupType&,
                const NameType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    Monitoring (::std::unique_ptr< SurveyOptionsType >,
                ::std::unique_ptr< SurveysType >,
                ::std::unique_ptr< AgeGroupType >,
                const NameType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Monitoring (const xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Monitoring (const Monitoring& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Monitoring*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Monitoring&
    operator= (const Monitoring& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Monitoring ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ContinuousOptional continuous_;
    ::xsd::cxx::tree::one< SurveyOptionsType > SurveyOptions_;
    ::xsd::cxx::tree::one< SurveysType > surveys_;
    ::xsd::cxx::tree::one< AgeGroupType > ageGroup_;
    CohortsOptional cohorts_;
    ::xsd::cxx::tree::one< NameType > name_;
    StartDateOptional startDate_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MonAgeGroup schema type.
   *
   * @nosubgrouping
   */
  class MonAgeGroup: public ::xml_schema::Type
  {
    public:
    /**
     * @name group
     *
     * @brief Accessor and modifier functions for the %group
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::MonGroupBounds GroupType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< GroupType > GroupSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< GroupType >::iterator GroupIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< GroupType >::const_iterator GroupConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< GroupType, char > GroupTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const GroupSequence&
    getGroup () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    GroupSequence&
    getGroup ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setGroup (const GroupSequence& s);

    //@}

    /**
     * @name lowerbound
     *
     * @brief Accessor and modifier functions for the %lowerbound
     * required attribute.
     *
     * Lower bound of age group
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double LowerboundType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LowerboundType, char, ::xsd::cxx::tree::schema_type::double_ > LowerboundTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const LowerboundType&
    getLowerbound () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    LowerboundType&
    getLowerbound ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLowerbound (const LowerboundType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MonAgeGroup (const LowerboundType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MonAgeGroup (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MonAgeGroup (const MonAgeGroup& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MonAgeGroup*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MonAgeGroup&
    operator= (const MonAgeGroup& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MonAgeGroup ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    GroupSequence group_;
    ::xsd::cxx::tree::one< LowerboundType > lowerbound_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MonGroupBounds schema type.
   *
   * @nosubgrouping
   */
  class MonGroupBounds: public ::xml_schema::Type
  {
    public:
    /**
     * @name upperbound
     *
     * @brief Accessor and modifier functions for the %upperbound
     * required attribute.
     *
     * Upper bound of age group
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double UpperboundType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< UpperboundType, char, ::xsd::cxx::tree::schema_type::double_ > UpperboundTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const UpperboundType&
    getUpperbound () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    UpperboundType&
    getUpperbound ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setUpperbound (const UpperboundType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MonGroupBounds (const UpperboundType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MonGroupBounds (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MonGroupBounds (const MonGroupBounds& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MonGroupBounds*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MonGroupBounds&
    operator= (const MonGroupBounds& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MonGroupBounds ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< UpperboundType > upperbound_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %Cohorts schema type.
   *
   * @nosubgrouping
   */
  class Cohorts: public ::xml_schema::Type
  {
    public:
    /**
     * @name subPop
     *
     * @brief Accessor and modifier functions for the %subPop
     * sequence element.
     *
     * Consider a certain sup-population a cohort, and segregate outputs
     * according to membership. Where multiple sub-populations are listed,
     * segregate output according to all combinations of membership: e.g.
     * if sub-populations A and B are listed, there will be outputs for
     * "member of A and B", "member of A but not B", "B but not A" and
     * "not a member of A or B". Listing n sub-populations implies 2^n
     * sets of outputs (each is further segregated by age groups, survey
     * times and enabled output measures, which could lead to excessive
     * program memory usage and output file size).
     * 
     * To identify outputs, each sub-population has a power of two number
     * as identifier (see "number" attribute). Each of the 2^n output sets
     * is identified by a number: the output set is the output from humans
     * who are members in some set of sub-populations (S1, S2, ...) and
     * not members in some others (T1, T2, ...); the number identifying
     * the set is the sum of the numbers identifying the sets S1, S2, etc.
     * 
     * In the output file, the output set is identified by multiplying
     * this number by 1000 then adding it to the age group column.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::CohortSubPop SubPopType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< SubPopType > SubPopSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< SubPopType >::iterator SubPopIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< SubPopType >::const_iterator SubPopConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SubPopType, char > SubPopTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const SubPopSequence&
    getSubPop () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    SubPopSequence&
    getSubPop ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setSubPop (const SubPopSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Cohorts ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Cohorts (const xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Cohorts (const Cohorts& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Cohorts*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Cohorts&
    operator= (const Cohorts& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Cohorts ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SubPopSequence subPop_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %CohortSubPop schema type.
   *
   * @nosubgrouping
   */
  class CohortSubPop: public ::xml_schema::Type
  {
    public:
    /**
     * @name id
     *
     * @brief Accessor and modifier functions for the %id
     * required attribute.
     *
     * Textual identifier for the sub-population (i.e. for an intervention
     * component, since sub-populations are defined as the hosts an
     * intervention component is deployed to).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String IdType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< IdType, char > IdTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const IdType&
    getId () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    IdType&
    getId ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setId (const IdType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setId (::std::unique_ptr< IdType > p);

    //@}

    /**
     * @name number
     *
     * @brief Accessor and modifier functions for the %number
     * required attribute.
     *
     * Number identifying a sub-population; used to define identifiers of
     * output sets. This number must be a power of 2 (i.e. 1, 2, 4, 8, ...).
     * See documentation of subPop element.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Integer NumberType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NumberType, char > NumberTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const NumberType&
    getNumber () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    NumberType&
    getNumber ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setNumber (const NumberType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    CohortSubPop (const IdType&,
                  const NumberType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    CohortSubPop (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CohortSubPop (const CohortSubPop& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual CohortSubPop*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    CohortSubPop&
    operator= (const CohortSubPop& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~CohortSubPop ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IdType > id_;
    ::xsd::cxx::tree::one< NumberType > number_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MonitoringOptions schema type.
   *
   * @nosubgrouping
   */
  class MonitoringOptions: public ::xml_schema::Type
  {
    public:
    /**
     * @name option
     *
     * @brief Accessor and modifier functions for the %option
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::MonitoringOption OptionType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< OptionType > OptionSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< OptionType >::iterator OptionIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< OptionType >::const_iterator OptionConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OptionType, char > OptionTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const OptionSequence&
    getOption () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    OptionSequence&
    getOption ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setOption (const OptionSequence& s);

    //@}

    /**
     * @name onlyNewEpisode
     *
     * @brief Accessor and modifier functions for the %onlyNewEpisode
     * optional attribute with a default value.
     *
     * If set, some statistics exclude humans who have been treated in the
     * recent past (precisely, when the time of last treatment was before
     * the current step and no more than health-system-memory days/steps
     * ago).
     * 
     * This is a rough replacement for the REPORT_ONLY_AT_RISK option,
     * with one difference: the maximum age of treatment for
     * REPORT_ONLY_AT_RISK was fixed at 20 days.
     * 
     * Affected measures include (as of version 35):
     * nHost (0),
     * nInfect(1),
     * nExpectd (2),
     * nPatent (3),
     * sumLogPyrogenThres (4),
     * sumlogDens (5),
     * totalInfs (6),
     * totalPatentInf (8),
     * sumPyrogenThresh (10),
     * nSubPopRemovalFirstEvent (62),
     * sumAge (68),
     * nInfectByGenotype (69),
     * nPatentByGenotype (70),
     * logDensByGenotype (71),
     * nHostDrugConcNonZero (72),
     * sumLogDrugConcNonZero (73).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean OnlyNewEpisodeType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< OnlyNewEpisodeType, char > OnlyNewEpisodeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const OnlyNewEpisodeType&
    getOnlyNewEpisode () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    OnlyNewEpisodeType&
    getOnlyNewEpisode ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setOnlyNewEpisode (const OnlyNewEpisodeType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static OnlyNewEpisodeType
    getOnlyNewEpisodeDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MonitoringOptions ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MonitoringOptions (const xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MonitoringOptions (const MonitoringOptions& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MonitoringOptions*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MonitoringOptions&
    operator= (const MonitoringOptions& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MonitoringOptions ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    OptionSequence option_;
    ::xsd::cxx::tree::one< OnlyNewEpisodeType > onlyNewEpisode_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %MonitoringOption schema type.
   *
   * @nosubgrouping
   */
  class MonitoringOption: public ::scnXml::Option
  {
    public:
    /**
     * @name outputNumber
     *
     * @brief Accessor and modifier functions for the %outputNumber
     * optional attribute.
     *
     * Number identifying this monitoring measure in the output
     * file (3rd column). Normally this is determined from the
     * measure, but it can be set manually, e.g. for when the same
     * measure is recorded twice (to accumulate across different
     * categories).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Int OutputNumberType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< OutputNumberType > OutputNumberOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutputNumberType, char > OutputNumberTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const OutputNumberOptional&
    getOutputNumber () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    OutputNumberOptional&
    getOutputNumber ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setOutputNumber (const OutputNumberType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setOutputNumber (const OutputNumberOptional& x);

    //@}

    /**
     * @name byAge
     *
     * @brief Accessor and modifier functions for the %byAge
     * optional attribute.
     *
     * If true, the measure is reported for each age category. If
     * false, values are summed across all age categories and only
     * the sum reported. If not specified, separate categories
     * will be reported if the measure supports this.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean ByAgeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ByAgeType > ByAgeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ByAgeType, char > ByAgeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ByAgeOptional&
    getByAge () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ByAgeOptional&
    getByAge ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setByAge (const ByAgeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setByAge (const ByAgeOptional& x);

    //@}

    /**
     * @name byCohort
     *
     * @brief Accessor and modifier functions for the %byCohort
     * optional attribute.
     *
     * If true, the measure is reported for each cohort separately.
     * If false, values are summed across all cohorts and only
     * the sum reported. If not specified, separate categories
     * will be reported if the measure supports this.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean ByCohortType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ByCohortType > ByCohortOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ByCohortType, char > ByCohortTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ByCohortOptional&
    getByCohort () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ByCohortOptional&
    getByCohort ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setByCohort (const ByCohortType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setByCohort (const ByCohortOptional& x);

    //@}

    /**
     * @name bySpecies
     *
     * @brief Accessor and modifier functions for the %bySpecies
     * optional attribute.
     *
     * If true, the measure is reported for each mosquito species
     * separately. If false, values are summed across all species
     * and only the sum reported. If not specified, separate
     * categories will be reported if the measure supports this.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean BySpeciesType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< BySpeciesType > BySpeciesOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< BySpeciesType, char > BySpeciesTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const BySpeciesOptional&
    getBySpecies () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    BySpeciesOptional&
    getBySpecies ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setBySpecies (const BySpeciesType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setBySpecies (const BySpeciesOptional& x);

    //@}

    /**
     * @name byGenotype
     *
     * @brief Accessor and modifier functions for the %byGenotype
     * optional attribute.
     *
     * If true, the measure is reported for each parasite genotype
     * separately. If false, values are summed across all genotypes
     * and only the sum reported. If not specified, separate
     * categories will be reported if the measure supports this.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean ByGenotypeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ByGenotypeType > ByGenotypeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ByGenotypeType, char > ByGenotypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ByGenotypeOptional&
    getByGenotype () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ByGenotypeOptional&
    getByGenotype ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setByGenotype (const ByGenotypeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setByGenotype (const ByGenotypeOptional& x);

    //@}

    /**
     * @name byDrugType
     *
     * @brief Accessor and modifier functions for the %byDrugType
     * optional attribute.
     *
     * If true, the measure is reported for each drug type
     * separately. If false, values are summed across all drug types
     * and only the sum reported. If not specified, separate
     * categories will be reported if the measure supports this.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean ByDrugTypeType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ByDrugTypeType > ByDrugTypeOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ByDrugTypeType, char > ByDrugTypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ByDrugTypeOptional&
    getByDrugType () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    ByDrugTypeOptional&
    getByDrugType ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setByDrugType (const ByDrugTypeType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setByDrugType (const ByDrugTypeOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    MonitoringOption (const NameType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    MonitoringOption (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MonitoringOption (const MonitoringOption& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual MonitoringOption*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    MonitoringOption&
    operator= (const MonitoringOption& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~MonitoringOption ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    OutputNumberOptional outputNumber_;
    ByAgeOptional byAge_;
    ByCohortOptional byCohort_;
    BySpeciesOptional bySpecies_;
    ByGenotypeOptional byGenotype_;
    ByDrugTypeOptional byDrugType_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %continuous schema type.
   *
   * @nosubgrouping
   */
  class Continuous: public ::scnXml::OptionSet
  {
    public:
    /**
     * @name period
     *
     * @brief Accessor and modifier functions for the %period
     * required attribute.
     *
     * Delay between reports; typically one time step but can be
     * greater.
     * 
     * Can be specified in steps (e.g. 1t) or days (e.g. 5d).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String PeriodType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PeriodType, char > PeriodTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const PeriodType&
    getPeriod () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    PeriodType&
    getPeriod ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setPeriod (const PeriodType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPeriod (::std::unique_ptr< PeriodType > p);

    //@}

    /**
     * @name duringInit
     *
     * @brief Accessor and modifier functions for the %duringInit
     * optional attribute.
     *
     * Also output during initialization. By default this is
     * disabled (only intervention-period data is output). This
     * should not be used for predictions, but can be useful for
     * model validation.
     * 
     * In this mode, 'simulation time' is output as the first
     * column (in addition to 'timestep'), since 'timestep' is dis-
     * continuous across the start of the intervention period.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean DuringInitType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DuringInitType > DuringInitOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DuringInitType, char > DuringInitTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DuringInitOptional&
    getDuringInit () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DuringInitOptional&
    getDuringInit ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDuringInit (const DuringInitType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDuringInit (const DuringInitOptional& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Continuous (const PeriodType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Continuous (const xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Continuous (const Continuous& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Continuous*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Continuous&
    operator= (const Continuous& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Continuous ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PeriodType > period_;
    DuringInitOptional duringInit_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %surveys schema type.
   *
   * @nosubgrouping
   */
  class Surveys: public ::xml_schema::Type
  {
    public:
    /**
     * @name surveyTime
     *
     * @brief Accessor and modifier functions for the %surveyTime
     * sequence element.
     *
     * Time of a survey. A report will be made for those measures
     * enabled under SurveyOptions. Reported data is either from the
     * moment the survey is done (immediate data) or is collected 
     * over the time since the previous survey, or in some cases
     * over a fixed time span (usually one year).
     * 
     * Times can be specified in time steps, starting from 0, or as
     * a date (see monitoring/startDate), or in days (e.g. 15d) or
     * years (e.g. 1y). Relative times mean the time since the start
     * of the intervention period, and must be non-negative (zero is
     * valid, but some measures, e.g. nUncomp, will be zero).
     * 
     * The simulation ends immediately after the last survey is taken.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::SurveyTime SurveyTimeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< SurveyTimeType > SurveyTimeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< SurveyTimeType >::iterator SurveyTimeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< SurveyTimeType >::const_iterator SurveyTimeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SurveyTimeType, char > SurveyTimeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const SurveyTimeSequence&
    getSurveyTime () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    SurveyTimeSequence&
    getSurveyTime ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setSurveyTime (const SurveyTimeSequence& s);

    //@}

    /**
     * @name detectionLimit
     *
     * @brief Accessor and modifier functions for the %detectionLimit
     * optional attribute.
     *
     * Deprecated: limit above which a human's infection is reported
     * as patent.
     * 
     * Alternative: do not specify this; instead specify "diagnostic".
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double DetectionLimitType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DetectionLimitType > DetectionLimitOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DetectionLimitType, char, ::xsd::cxx::tree::schema_type::double_ > DetectionLimitTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DetectionLimitOptional&
    getDetectionLimit () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DetectionLimitOptional&
    getDetectionLimit ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDetectionLimit (const DetectionLimitType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDetectionLimit (const DetectionLimitOptional& x);

    //@}

    /**
     * @name diagnostic
     *
     * @brief Accessor and modifier functions for the %diagnostic
     * optional attribute.
     *
     * Name of a parameterised diagnostic to use in surveys (see
     * scenario/diagnostics).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String DiagnosticType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DiagnosticType > DiagnosticOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DiagnosticType, char > DiagnosticTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DiagnosticOptional&
    getDiagnostic () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    DiagnosticOptional&
    getDiagnostic ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDiagnostic (const DiagnosticType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setDiagnostic (const DiagnosticOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDiagnostic (::std::unique_ptr< DiagnosticType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Surveys ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Surveys (const xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Surveys (const Surveys& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Surveys*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Surveys&
    operator= (const Surveys& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Surveys ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    SurveyTimeSequence surveyTime_;
    DetectionLimitOptional detectionLimit_;
    DiagnosticOptional diagnostic_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %surveyTime schema type.
   *
   * @nosubgrouping
   */
  class SurveyTime: public ::xml_schema::String
  {
    public:
    /**
     * @name repeatStep
     *
     * @brief Accessor and modifier functions for the %repeatStep
     * optional attribute.
     *
     * See repeatEnd's documentation.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String RepeatStepType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RepeatStepType > RepeatStepOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RepeatStepType, char > RepeatStepTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RepeatStepOptional&
    getRepeatStep () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    RepeatStepOptional&
    getRepeatStep ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRepeatStep (const RepeatStepType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setRepeatStep (const RepeatStepOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRepeatStep (::std::unique_ptr< RepeatStepType > p);

    //@}

    /**
     * @name repeatEnd
     *
     * @brief Accessor and modifier functions for the %repeatEnd
     * optional attribute.
     *
     * Either both repeatStep and repeatEnd should be present
     * or neither. If present, the survey is repeated every
     * repeatStep timesteps (i.e. if t0 is the initial time
     * and x is repeatStep, surveys are done at times t0,
     * t0+x, t0+2*x, ...), ending before repeatEnd
     * (final repetition is the one before repeatEnd).
     * 
     * Note that repeatEnd may be specified as a date but
     * repeatStep must be a duration (days, steps or years).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String RepeatEndType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RepeatEndType > RepeatEndOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< RepeatEndType, char > RepeatEndTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RepeatEndOptional&
    getRepeatEnd () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    RepeatEndOptional&
    getRepeatEnd ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setRepeatEnd (const RepeatEndType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setRepeatEnd (const RepeatEndOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRepeatEnd (::std::unique_ptr< RepeatEndType > p);

    //@}

    /**
     * @name reported
     *
     * @brief Accessor and modifier functions for the %reported
     * optional attribute with a default value.
     *
     * For normal surveys, reporting=true. If set false,
     * quantities are measured but not reported. The reason for doing this is
     * to update conditions set on reportable measures.
     * 
     * Multiple surveys may be given here for the same date, e.g. if using
     * "repeatStep" for both reporting and non-reporting surveys. These are
     * combined such that a maximum of one survey is carried out per
     * time-step,
     * and the survey is reported if any of the listed surveys for this date
     * is
     * configured as "reporting".
     * 
     * Note that adding non-reporting surveys will not affect value output by
     * reported surveys, with the exception that generated psuedo-random
     * numbers
     * may be altered (specifically, when any stochastic diagnostics are used
     * in
     * surveys).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean ReportedType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ReportedType, char > ReportedTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ReportedType&
    getReported () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ReportedType&
    getReported ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setReported (const ReportedType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static ReportedType
    getReportedDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from initializers for required 
     * elements and attributes.
     */
    SurveyTime ();

    /**
     * @brief Create an instance from a C string and initializers
     * for required elements and attributes.
     */
    SurveyTime (const char*);

    /**
     * @brief Create an instance from a string andinitializers
     * for required elements and attributes.
     */
    SurveyTime (const ::std::string&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    SurveyTime (const ::xml_schema::String&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    SurveyTime (const xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SurveyTime (const SurveyTime& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual SurveyTime*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    SurveyTime&
    operator= (const SurveyTime& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~SurveyTime ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    RepeatStepOptional repeatStep_;
    RepeatEndOptional repeatEnd_;
    ::xsd::cxx::tree::one< ReportedType > reported_;

    //@endcond
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace scnXml
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_CODE_OPENMALARIA_SCHEMA_MONITORING_H

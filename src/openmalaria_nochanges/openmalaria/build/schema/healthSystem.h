// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from healthSystem.xsd.
 */

#ifndef CXX_CODE_OPENMALARIA_SCHEMA_HEALTH_SYSTEM_H
#define CXX_CODE_OPENMALARIA_SCHEMA_HEALTH_SYSTEM_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type Type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, Type > SimpleType;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type Container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char Byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char UnsignedByte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short Short;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short UnsignedShort;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int Int;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int UnsignedInt;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long Long;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long UnsignedLong;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long Integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long NonPositiveInteger;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long NonNegativeInteger;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long PositiveInteger;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long NegativeInteger;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool Boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float Float;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double Double;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double Decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, SimpleType > String;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, String > NormalizedString;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, NormalizedString > Token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, Token > Name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, Token > Nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, SimpleType, Nmtoken > Nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, Name > Ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, Token > Language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, Ncname > Id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, Ncname, Type > Idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, SimpleType, Idref > Idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, SimpleType > Uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, SimpleType, Uri, Ncname > Qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > Buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, SimpleType > Base64Binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, SimpleType > HexBinary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone TimeZone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, SimpleType > Date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, SimpleType > DateTime;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, SimpleType > Duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, SimpleType > Gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, SimpleType > Gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, SimpleType > GmonthDay;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, SimpleType > Gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, SimpleType > GyearMonth;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, SimpleType > Time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, Ncname > Entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, SimpleType, Entity > Entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order ContentOrder;
  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags Flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > Properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity Severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > Error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > Diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > Exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > Bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > DuplicateId;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > Parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > ExpectedElement;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > UnexpectedElement;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > ExpectedAttribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > UnexpectedEnumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > ExpectedTextContent;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > NoPrefixMapping;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > ErrorHandler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const treeNodeKey = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace scnXml
{
  class Clinical;
  class HealthSystem;
  class LiverStageDrug;
  class HSImmediateOutcomes;
  class TreatmentDetails;
  class HSDT5Day;
  class HSEventScheduler;
  class ClinicalOutcomes;
  class HSESNMF;
  class DecisionTree;
  class DTMultiple;
  class DTCaseType;
  class DTDiagnostic;
  class DTRandom;
  class DTAge;
  class DTNoTreatment;
  class DTTreatFailure;
  class DTTreatPKPD;
  class DTTreatSimple;
  class DTDeploy;
  class TreatmentOption;
  class NeonatalMortality;
  class NonMalariaFevers;
  class DrugRegimen;
  class TreatmentActions;
  class Outcome;
  class Age;
  class ClearInfections;
  class Stage;
}


#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "util.h"

/**
 * @brief C++ namespace for the %http://openmalaria.org/schema/scenario_39
 * schema namespace.
 */
namespace scnXml
{
  /**
   * @brief Class corresponding to the %Clinical schema type.
   *
   * Description of clinical parameters that are related to the
   * health-system description, but which contain data
   * that cannot be changed as part of an intervention and that are not
   * restricted to treatment.
   *
   * @nosubgrouping
   */
  class Clinical: public ::xml_schema::Type
  {
    public:
    /**
     * @name NeonatalMortality
     *
     * @brief Accessor and modifier functions for the %NeonatalMortality
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::NeonatalMortality NeonatalMortalityType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NeonatalMortalityType > NeonatalMortalityOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NeonatalMortalityType, char > NeonatalMortalityTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NeonatalMortalityOptional&
    getNeonatalMortality () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NeonatalMortalityOptional&
    getNeonatalMortality ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNeonatalMortality (const NeonatalMortalityType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNeonatalMortality (const NeonatalMortalityOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNeonatalMortality (::std::unique_ptr< NeonatalMortalityType > p);

    //@}

    /**
     * @name NonMalariaFevers
     *
     * @brief Accessor and modifier functions for the %NonMalariaFevers
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::NonMalariaFevers NonMalariaFeversType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NonMalariaFeversType > NonMalariaFeversOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NonMalariaFeversType, char > NonMalariaFeversTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NonMalariaFeversOptional&
    getNonMalariaFevers () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NonMalariaFeversOptional&
    getNonMalariaFevers ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNonMalariaFevers (const NonMalariaFeversType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNonMalariaFevers (const NonMalariaFeversOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNonMalariaFevers (::std::unique_ptr< NonMalariaFeversType > p);

    //@}

    /**
     * @name healthSystemMemory
     *
     * @brief Accessor and modifier functions for the %healthSystemMemory
     * required attribute.
     *
     * Follow-up period during which a recurrence is
     * considered to be a treatment failure
     * 
     * Can be specified in steps (e.g. 6t) or days (e.g. 28d).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String HealthSystemMemoryType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< HealthSystemMemoryType, char > HealthSystemMemoryTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const HealthSystemMemoryType&
    getHealthSystemMemory () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    HealthSystemMemoryType&
    getHealthSystemMemory ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setHealthSystemMemory (const HealthSystemMemoryType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setHealthSystemMemory (::std::unique_ptr< HealthSystemMemoryType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Clinical (const HealthSystemMemoryType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Clinical (const xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Clinical (const Clinical& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Clinical*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Clinical&
    operator= (const Clinical& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Clinical ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NeonatalMortalityOptional NeonatalMortality_;
    NonMalariaFeversOptional NonMalariaFevers_;
    ::xsd::cxx::tree::one< HealthSystemMemoryType > healthSystemMemory_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HealthSystem schema type.
   *
   * Description of case management system, used to specify the initial
   * model
   * or a replacement (an intervention). Encompasses case management
   * data and some other data required to derive case outcomes.
   * 
   * Contains a sub-element describing the particular health-system in use.
   * Health system data is here defined as data used to decide on a
   * treatment
   * strategy, given a case requiring treatment.
   *
   * @nosubgrouping
   */
  class HealthSystem: public ::xml_schema::Type
  {
    public:
    /**
     * @name EventScheduler
     *
     * @brief Accessor and modifier functions for the %EventScheduler
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::HSEventScheduler EventSchedulerType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< EventSchedulerType > EventSchedulerOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EventSchedulerType, char > EventSchedulerTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const EventSchedulerOptional&
    getEventScheduler () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    EventSchedulerOptional&
    getEventScheduler ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEventScheduler (const EventSchedulerType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setEventScheduler (const EventSchedulerOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setEventScheduler (::std::unique_ptr< EventSchedulerType > p);

    //@}

    /**
     * @name ImmediateOutcomes
     *
     * @brief Accessor and modifier functions for the %ImmediateOutcomes
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::HSImmediateOutcomes ImmediateOutcomesType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ImmediateOutcomesType > ImmediateOutcomesOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ImmediateOutcomesType, char > ImmediateOutcomesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ImmediateOutcomesOptional&
    getImmediateOutcomes () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ImmediateOutcomesOptional&
    getImmediateOutcomes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setImmediateOutcomes (const ImmediateOutcomesType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setImmediateOutcomes (const ImmediateOutcomesOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setImmediateOutcomes (::std::unique_ptr< ImmediateOutcomesType > p);

    //@}

    /**
     * @name DecisionTree5Day
     *
     * @brief Accessor and modifier functions for the %DecisionTree5Day
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::HSDT5Day DecisionTree5DayType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DecisionTree5DayType > DecisionTree5DayOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DecisionTree5DayType, char > DecisionTree5DayTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DecisionTree5DayOptional&
    getDecisionTree5Day () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DecisionTree5DayOptional&
    getDecisionTree5Day ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDecisionTree5Day (const DecisionTree5DayType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDecisionTree5Day (const DecisionTree5DayOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDecisionTree5Day (::std::unique_ptr< DecisionTree5DayType > p);

    //@}

    /**
     * @name CFR
     *
     * @brief Accessor and modifier functions for the %CFR
     * required element.
     *
     * Case fatality rate (probability of an inpatient fatality from a
     * bout of severe malaria, per age-group).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::AgeGroupValues CFRType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CFRType, char > CFRTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CFRType&
    getCFR () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CFRType&
    getCFR ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCFR (const CFRType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCFR (::std::unique_ptr< CFRType > p);

    //@}

    /**
     * @name pSequelaeInpatient
     *
     * @brief Accessor and modifier functions for the %pSequelaeInpatient
     * required element.
     *
     * List of age-specific probabilities of sequelae in inpatients,
     * during a severe bout of malaria.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::AgeGroupValues PSequelaeInpatientType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PSequelaeInpatientType, char > PSequelaeInpatientTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PSequelaeInpatientType&
    getPSequelaeInpatient () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PSequelaeInpatientType&
    getPSequelaeInpatient ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPSequelaeInpatient (const PSequelaeInpatientType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPSequelaeInpatient (::std::unique_ptr< PSequelaeInpatientType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HealthSystem (const CFRType&,
                  const PSequelaeInpatientType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    HealthSystem (::std::unique_ptr< CFRType >,
                  ::std::unique_ptr< PSequelaeInpatientType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HealthSystem (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HealthSystem (const HealthSystem& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HealthSystem*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HealthSystem&
    operator= (const HealthSystem& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HealthSystem ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    EventSchedulerOptional EventScheduler_;
    ImmediateOutcomesOptional ImmediateOutcomes_;
    DecisionTree5DayOptional DecisionTree5Day_;
    ::xsd::cxx::tree::one< CFRType > CFR_;
    ::xsd::cxx::tree::one< PSequelaeInpatientType > pSequelaeInpatient_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %LiverStageDrug schema type.
   *
   * Parameters for drug treatment which have an effect on the liver-stage
   * of parasites (Primaquine and potentially Tafenoquine); for use with
   * the Vivax model only.
   * 
   * Note: if this section is not listed, the following default values are
   * assumed: pHumanCannotReceive=0, pUseUncomplicated=0,
   * effectivenessOnUse=1.
   *
   * @nosubgrouping
   */
  class LiverStageDrug: public ::xml_schema::Type
  {
    public:
    /**
     * @name pHumanCannotReceive
     *
     * @brief Accessor and modifier functions for the %pHumanCannotReceive
     * required element.
     *
     * Chance that a human is determined to be unable to receive liver-stage
     * drug
     * treatment. Treatment is neither reported or given for such humans.
     * 
     * This is sampled once per human at birth.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue PHumanCannotReceiveType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PHumanCannotReceiveType, char > PHumanCannotReceiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PHumanCannotReceiveType&
    getPHumanCannotReceive () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PHumanCannotReceiveType&
    getPHumanCannotReceive ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPHumanCannotReceive (const PHumanCannotReceiveType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPHumanCannotReceive (::std::unique_ptr< PHumanCannotReceiveType > p);

    //@}

    /**
     * @name ignoreCannotReceive
     *
     * @brief Accessor and modifier functions for the %ignoreCannotReceive
     * optional element.
     *
     * If true, ignore pHumanCannotReceive and consider all humans eligible
     * for treatment; if false (or not specified), do not treat those demed
     * incompatible with liver-stage drug treatment.
     * 
     * The point of this is that pHumanCannotReceive cannot be altered by
     * changeHS interventions, but this property can be.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::BooleanValue IgnoreCannotReceiveType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< IgnoreCannotReceiveType > IgnoreCannotReceiveOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IgnoreCannotReceiveType, char > IgnoreCannotReceiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const IgnoreCannotReceiveOptional&
    getIgnoreCannotReceive () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    IgnoreCannotReceiveOptional&
    getIgnoreCannotReceive ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIgnoreCannotReceive (const IgnoreCannotReceiveType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setIgnoreCannotReceive (const IgnoreCannotReceiveOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setIgnoreCannotReceive (::std::unique_ptr< IgnoreCannotReceiveType > p);

    //@}

    /**
     * @name pUseUncomplicated
     *
     * @brief Accessor and modifier functions for the %pUseUncomplicated
     * optional element.
     *
     * This feature is deprecated; it is suggested to use the "simple
     * treatment" feature configured to clear liver-stage parasites,
     * leaving this option unset or zero.
     * 
     * Chance of liver-stage drug treatment being used for routine treatment
     * of an
     * uncomplicated case.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue PUseUncomplicatedType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PUseUncomplicatedType > PUseUncomplicatedOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PUseUncomplicatedType, char > PUseUncomplicatedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PUseUncomplicatedOptional&
    getPUseUncomplicated () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PUseUncomplicatedOptional&
    getPUseUncomplicated ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPUseUncomplicated (const PUseUncomplicatedType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPUseUncomplicated (const PUseUncomplicatedOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPUseUncomplicated (::std::unique_ptr< PUseUncomplicatedType > p);

    //@}

    /**
     * @name effectivenessOnUse
     *
     * @brief Accessor and modifier functions for the %effectivenessOnUse
     * required element.
     *
     * Chance that liver-stage drug treatment is effective.
     * 
     * On application, a random variable is sampled against this probability.
     * If false, the treatment does nothing; if true, the treatment clears
     * all
     * liver stage parasites. Where effectiveness is longer than a single
     * time step (prophylactic effect), this sample still only happens once
     * (thus either no effect or all liver stages cleared over multiple
     * steps).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue EffectivenessOnUseType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EffectivenessOnUseType, char > EffectivenessOnUseTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EffectivenessOnUseType&
    getEffectivenessOnUse () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EffectivenessOnUseType&
    getEffectivenessOnUse ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEffectivenessOnUse (const EffectivenessOnUseType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setEffectivenessOnUse (::std::unique_ptr< EffectivenessOnUseType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    LiverStageDrug (const PHumanCannotReceiveType&,
                    const EffectivenessOnUseType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    LiverStageDrug (::std::unique_ptr< PHumanCannotReceiveType >,
                    ::std::unique_ptr< EffectivenessOnUseType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    LiverStageDrug (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LiverStageDrug (const LiverStageDrug& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual LiverStageDrug*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    LiverStageDrug&
    operator= (const LiverStageDrug& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~LiverStageDrug ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PHumanCannotReceiveType > pHumanCannotReceive_;
    IgnoreCannotReceiveOptional ignoreCannotReceive_;
    PUseUncomplicatedOptional pUseUncomplicated_;
    ::xsd::cxx::tree::one< EffectivenessOnUseType > effectivenessOnUse_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HSImmediateOutcomes schema type.
   *
   * Description of "immediate outcomes" health system:
   * Tediosi et al case management model (Case management as
   * described in AJTMH 75 (suppl 2) pp90-103).
   *
   * @nosubgrouping
   */
  class HSImmediateOutcomes: public ::xml_schema::Type
  {
    public:
    /**
     * @name drugRegimen
     *
     * @brief Accessor and modifier functions for the %drugRegimen
     * required element.
     *
     * Description of drug regimen.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DrugRegimen DrugRegimenType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DrugRegimenType, char > DrugRegimenTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const DrugRegimenType&
    getDrugRegimen () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    DrugRegimenType&
    getDrugRegimen ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDrugRegimen (const DrugRegimenType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDrugRegimen (::std::unique_ptr< DrugRegimenType > p);

    //@}

    /**
     * @name initialACR
     *
     * @brief Accessor and modifier functions for the %initialACR
     * required element.
     *
     * Initial cure rate
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TreatmentDetails InitialACRType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< InitialACRType, char > InitialACRTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const InitialACRType&
    getInitialACR () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    InitialACRType&
    getInitialACR ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setInitialACR (const InitialACRType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInitialACR (::std::unique_ptr< InitialACRType > p);

    //@}

    /**
     * @name compliance
     *
     * @brief Accessor and modifier functions for the %compliance
     * required element.
     *
     * Adherence to treatment
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TreatmentDetails ComplianceType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComplianceType, char > ComplianceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ComplianceType&
    getCompliance () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ComplianceType&
    getCompliance ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCompliance (const ComplianceType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCompliance (::std::unique_ptr< ComplianceType > p);

    //@}

    /**
     * @name nonCompliersEffective
     *
     * @brief Accessor and modifier functions for the %nonCompliersEffective
     * required element.
     *
     * Effectiveness of treatment for non-compliant patients
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TreatmentDetails NonCompliersEffectiveType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NonCompliersEffectiveType, char > NonCompliersEffectiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NonCompliersEffectiveType&
    getNonCompliersEffective () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NonCompliersEffectiveType&
    getNonCompliersEffective ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNonCompliersEffective (const NonCompliersEffectiveType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNonCompliersEffective (::std::unique_ptr< NonCompliersEffectiveType > p);

    //@}

    /**
     * @name treatmentActions
     *
     * @brief Accessor and modifier functions for the %treatmentActions
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TreatmentActions TreatmentActionsType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreatmentActionsType, char > TreatmentActionsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TreatmentActionsType&
    getTreatmentActions () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TreatmentActionsType&
    getTreatmentActions ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreatmentActions (const TreatmentActionsType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTreatmentActions (::std::unique_ptr< TreatmentActionsType > p);

    //@}

    /**
     * @name pSeekOfficialCareUncomplicated1
     *
     * @brief Accessor and modifier functions for the %pSeekOfficialCareUncomplicated1
     * required element.
     *
     * Probability that a patient with newly incident
     * uncomplicated disease seeks official care
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue PSeekOfficialCareUncomplicated1Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PSeekOfficialCareUncomplicated1Type, char > PSeekOfficialCareUncomplicated1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PSeekOfficialCareUncomplicated1Type&
    getPSeekOfficialCareUncomplicated1 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PSeekOfficialCareUncomplicated1Type&
    getPSeekOfficialCareUncomplicated1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPSeekOfficialCareUncomplicated1 (const PSeekOfficialCareUncomplicated1Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPSeekOfficialCareUncomplicated1 (::std::unique_ptr< PSeekOfficialCareUncomplicated1Type > p);

    //@}

    /**
     * @name pSelfTreatUncomplicated
     *
     * @brief Accessor and modifier functions for the %pSelfTreatUncomplicated
     * required element.
     *
     * Probability that a patient with uncomplicated disease without
     * recent history of disease (i.e. first line) will self-treat.
     * 
     * Note that in second line cases there is no probability of
     * self-treatment.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue PSelfTreatUncomplicatedType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PSelfTreatUncomplicatedType, char > PSelfTreatUncomplicatedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PSelfTreatUncomplicatedType&
    getPSelfTreatUncomplicated () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PSelfTreatUncomplicatedType&
    getPSelfTreatUncomplicated ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPSelfTreatUncomplicated (const PSelfTreatUncomplicatedType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPSelfTreatUncomplicated (::std::unique_ptr< PSelfTreatUncomplicatedType > p);

    //@}

    /**
     * @name pSeekOfficialCareUncomplicated2
     *
     * @brief Accessor and modifier functions for the %pSeekOfficialCareUncomplicated2
     * required element.
     *
     * Probability that a patient with recurrence of
     * uncomplicated disease seeks official care
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue PSeekOfficialCareUncomplicated2Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PSeekOfficialCareUncomplicated2Type, char > PSeekOfficialCareUncomplicated2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PSeekOfficialCareUncomplicated2Type&
    getPSeekOfficialCareUncomplicated2 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PSeekOfficialCareUncomplicated2Type&
    getPSeekOfficialCareUncomplicated2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPSeekOfficialCareUncomplicated2 (const PSeekOfficialCareUncomplicated2Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPSeekOfficialCareUncomplicated2 (::std::unique_ptr< PSeekOfficialCareUncomplicated2Type > p);

    //@}

    /**
     * @name pSeekOfficialCareSevere
     *
     * @brief Accessor and modifier functions for the %pSeekOfficialCareSevere
     * required element.
     *
     * Probability that a patient with severe disease
     * obtains appropriate care
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue PSeekOfficialCareSevereType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PSeekOfficialCareSevereType, char > PSeekOfficialCareSevereTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PSeekOfficialCareSevereType&
    getPSeekOfficialCareSevere () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PSeekOfficialCareSevereType&
    getPSeekOfficialCareSevere ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPSeekOfficialCareSevere (const PSeekOfficialCareSevereType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPSeekOfficialCareSevere (::std::unique_ptr< PSeekOfficialCareSevereType > p);

    //@}

    /**
     * @name liverStageDrug
     *
     * @brief Accessor and modifier functions for the %liverStageDrug
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::LiverStageDrug LiverStageDrugType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LiverStageDrugType > LiverStageDrugOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LiverStageDrugType, char > LiverStageDrugTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LiverStageDrugOptional&
    getLiverStageDrug () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LiverStageDrugOptional&
    getLiverStageDrug ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLiverStageDrug (const LiverStageDrugType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLiverStageDrug (const LiverStageDrugOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLiverStageDrug (::std::unique_ptr< LiverStageDrugType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * Name of health system
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name useDiagnosticUC
     *
     * @brief Accessor and modifier functions for the %useDiagnosticUC
     * optional attribute with a default value.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Boolean UseDiagnosticUCType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< UseDiagnosticUCType, char > UseDiagnosticUCTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const UseDiagnosticUCType&
    getUseDiagnosticUC () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    UseDiagnosticUCType&
    getUseDiagnosticUC ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setUseDiagnosticUC (const UseDiagnosticUCType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static UseDiagnosticUCType
    getUseDiagnosticUCDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HSImmediateOutcomes (const DrugRegimenType&,
                         const InitialACRType&,
                         const ComplianceType&,
                         const NonCompliersEffectiveType&,
                         const TreatmentActionsType&,
                         const PSeekOfficialCareUncomplicated1Type&,
                         const PSelfTreatUncomplicatedType&,
                         const PSeekOfficialCareUncomplicated2Type&,
                         const PSeekOfficialCareSevereType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    HSImmediateOutcomes (::std::unique_ptr< DrugRegimenType >,
                         ::std::unique_ptr< InitialACRType >,
                         ::std::unique_ptr< ComplianceType >,
                         ::std::unique_ptr< NonCompliersEffectiveType >,
                         ::std::unique_ptr< TreatmentActionsType >,
                         ::std::unique_ptr< PSeekOfficialCareUncomplicated1Type >,
                         ::std::unique_ptr< PSelfTreatUncomplicatedType >,
                         ::std::unique_ptr< PSeekOfficialCareUncomplicated2Type >,
                         ::std::unique_ptr< PSeekOfficialCareSevereType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HSImmediateOutcomes (const xercesc::DOMElement& e,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HSImmediateOutcomes (const HSImmediateOutcomes& x,
                         ::xml_schema::Flags f = 0,
                         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HSImmediateOutcomes*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HSImmediateOutcomes&
    operator= (const HSImmediateOutcomes& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HSImmediateOutcomes ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DrugRegimenType > drugRegimen_;
    ::xsd::cxx::tree::one< InitialACRType > initialACR_;
    ::xsd::cxx::tree::one< ComplianceType > compliance_;
    ::xsd::cxx::tree::one< NonCompliersEffectiveType > nonCompliersEffective_;
    ::xsd::cxx::tree::one< TreatmentActionsType > treatmentActions_;
    ::xsd::cxx::tree::one< PSeekOfficialCareUncomplicated1Type > pSeekOfficialCareUncomplicated1_;
    ::xsd::cxx::tree::one< PSelfTreatUncomplicatedType > pSelfTreatUncomplicated_;
    ::xsd::cxx::tree::one< PSeekOfficialCareUncomplicated2Type > pSeekOfficialCareUncomplicated2_;
    ::xsd::cxx::tree::one< PSeekOfficialCareSevereType > pSeekOfficialCareSevere_;
    LiverStageDrugOptional liverStageDrug_;
    NameOptional name_;
    ::xsd::cxx::tree::one< UseDiagnosticUCType > useDiagnosticUC_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TreatmentDetails schema type.
   *
   * @nosubgrouping
   */
  class TreatmentDetails: public ::xml_schema::Type
  {
    public:
    /**
     * @name CQ
     *
     * @brief Accessor and modifier functions for the %CQ
     * optional element.
     *
     * Chloroquine
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue CQType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CQType > CQOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CQType, char > CQTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CQOptional&
    getCQ () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CQOptional&
    getCQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCQ (const CQType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCQ (const CQOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCQ (::std::unique_ptr< CQType > p);

    //@}

    /**
     * @name SP
     *
     * @brief Accessor and modifier functions for the %SP
     * optional element.
     *
     * Sulphadoxine-pyrimethamine
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue SPType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SPType > SPOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SPType, char > SPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SPOptional&
    getSP () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SPOptional&
    getSP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSP (const SPType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSP (const SPOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSP (::std::unique_ptr< SPType > p);

    //@}

    /**
     * @name AQ
     *
     * @brief Accessor and modifier functions for the %AQ
     * optional element.
     *
     * Amodiaquine
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue AQType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AQType > AQOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AQType, char > AQTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AQOptional&
    getAQ () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AQOptional&
    getAQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAQ (const AQType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAQ (const AQOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAQ (::std::unique_ptr< AQType > p);

    //@}

    /**
     * @name SPAQ
     *
     * @brief Accessor and modifier functions for the %SPAQ
     * optional element.
     *
     * Sulphadoxine-pyrimethamine/Amodiaquine
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue SPAQType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SPAQType > SPAQOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SPAQType, char > SPAQTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SPAQOptional&
    getSPAQ () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SPAQOptional&
    getSPAQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSPAQ (const SPAQType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSPAQ (const SPAQOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSPAQ (::std::unique_ptr< SPAQType > p);

    //@}

    /**
     * @name ACT
     *
     * @brief Accessor and modifier functions for the %ACT
     * optional element.
     *
     * Artemisinine combination therapy
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue ACTType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ACTType > ACTOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ACTType, char > ACTTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ACTOptional&
    getACT () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ACTOptional&
    getACT ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setACT (const ACTType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setACT (const ACTOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setACT (::std::unique_ptr< ACTType > p);

    //@}

    /**
     * @name QN
     *
     * @brief Accessor and modifier functions for the %QN
     * optional element.
     *
     * Quinine
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue QNType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< QNType > QNOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QNType, char > QNTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const QNOptional&
    getQN () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    QNOptional&
    getQN ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQN (const QNType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setQN (const QNOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setQN (::std::unique_ptr< QNType > p);

    //@}

    /**
     * @name selfTreatment
     *
     * @brief Accessor and modifier functions for the %selfTreatment
     * required element.
     *
     * Probability of self-treatment
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue SelfTreatmentType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SelfTreatmentType, char > SelfTreatmentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SelfTreatmentType&
    getSelfTreatment () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SelfTreatmentType&
    getSelfTreatment ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSelfTreatment (const SelfTreatmentType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSelfTreatment (::std::unique_ptr< SelfTreatmentType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TreatmentDetails (const SelfTreatmentType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    TreatmentDetails (::std::unique_ptr< SelfTreatmentType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TreatmentDetails (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TreatmentDetails (const TreatmentDetails& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TreatmentDetails*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TreatmentDetails&
    operator= (const TreatmentDetails& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TreatmentDetails ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CQOptional CQ_;
    SPOptional SP_;
    AQOptional AQ_;
    SPAQOptional SPAQ_;
    ACTOptional ACT_;
    QNOptional QN_;
    ::xsd::cxx::tree::one< SelfTreatmentType > selfTreatment_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HSDT5Day schema type.
   *
   * Description of the health system using the 5-day timestep with
   * decision
   * tree model: access is configured as in the Tediosi et al case
   * management model (Case management as described in AJTMH 75 (suppl 2)
   * pp90-103) while treatment decisions are configured via decision trees.
   * 
   * Besides greater flexibility, this allows treatment via PK/PD models.
   *
   * @nosubgrouping
   */
  class HSDT5Day: public ::xml_schema::Type
  {
    public:
    /**
     * @name pSeekOfficialCareUncomplicated1
     *
     * @brief Accessor and modifier functions for the %pSeekOfficialCareUncomplicated1
     * required element.
     *
     * Probability that a patient with newly incident
     * uncomplicated disease seeks official care
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue PSeekOfficialCareUncomplicated1Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PSeekOfficialCareUncomplicated1Type, char > PSeekOfficialCareUncomplicated1Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PSeekOfficialCareUncomplicated1Type&
    getPSeekOfficialCareUncomplicated1 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PSeekOfficialCareUncomplicated1Type&
    getPSeekOfficialCareUncomplicated1 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPSeekOfficialCareUncomplicated1 (const PSeekOfficialCareUncomplicated1Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPSeekOfficialCareUncomplicated1 (::std::unique_ptr< PSeekOfficialCareUncomplicated1Type > p);

    //@}

    /**
     * @name pSelfTreatUncomplicated
     *
     * @brief Accessor and modifier functions for the %pSelfTreatUncomplicated
     * required element.
     *
     * Probability that a patient with uncomplicated disease without
     * recent history of disease (i.e. first line) will self-treat.
     * 
     * Note that in second line cases there is no probability of
     * self-treatment.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue PSelfTreatUncomplicatedType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PSelfTreatUncomplicatedType, char > PSelfTreatUncomplicatedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PSelfTreatUncomplicatedType&
    getPSelfTreatUncomplicated () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PSelfTreatUncomplicatedType&
    getPSelfTreatUncomplicated ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPSelfTreatUncomplicated (const PSelfTreatUncomplicatedType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPSelfTreatUncomplicated (::std::unique_ptr< PSelfTreatUncomplicatedType > p);

    //@}

    /**
     * @name pSeekOfficialCareUncomplicated2
     *
     * @brief Accessor and modifier functions for the %pSeekOfficialCareUncomplicated2
     * required element.
     *
     * Probability that a patient with recurrence of
     * uncomplicated disease seeks official care
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue PSeekOfficialCareUncomplicated2Type;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PSeekOfficialCareUncomplicated2Type, char > PSeekOfficialCareUncomplicated2Traits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PSeekOfficialCareUncomplicated2Type&
    getPSeekOfficialCareUncomplicated2 () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PSeekOfficialCareUncomplicated2Type&
    getPSeekOfficialCareUncomplicated2 ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPSeekOfficialCareUncomplicated2 (const PSeekOfficialCareUncomplicated2Type& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPSeekOfficialCareUncomplicated2 (::std::unique_ptr< PSeekOfficialCareUncomplicated2Type > p);

    //@}

    /**
     * @name pSeekOfficialCareSevere
     *
     * @brief Accessor and modifier functions for the %pSeekOfficialCareSevere
     * required element.
     *
     * Probability that a patient with severe disease
     * obtains appropriate care
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue PSeekOfficialCareSevereType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PSeekOfficialCareSevereType, char > PSeekOfficialCareSevereTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PSeekOfficialCareSevereType&
    getPSeekOfficialCareSevere () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PSeekOfficialCareSevereType&
    getPSeekOfficialCareSevere ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPSeekOfficialCareSevere (const PSeekOfficialCareSevereType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPSeekOfficialCareSevere (::std::unique_ptr< PSeekOfficialCareSevereType > p);

    //@}

    /**
     * @name liverStageDrug
     *
     * @brief Accessor and modifier functions for the %liverStageDrug
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::LiverStageDrug LiverStageDrugType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< LiverStageDrugType > LiverStageDrugOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< LiverStageDrugType, char > LiverStageDrugTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const LiverStageDrugOptional&
    getLiverStageDrug () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    LiverStageDrugOptional&
    getLiverStageDrug ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setLiverStageDrug (const LiverStageDrugType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setLiverStageDrug (const LiverStageDrugOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setLiverStageDrug (::std::unique_ptr< LiverStageDrugType > p);

    //@}

    /**
     * @name treeUCOfficial
     *
     * @brief Accessor and modifier functions for the %treeUCOfficial
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecisionTree TreeUCOfficialType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreeUCOfficialType, char > TreeUCOfficialTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TreeUCOfficialType&
    getTreeUCOfficial () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TreeUCOfficialType&
    getTreeUCOfficial ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreeUCOfficial (const TreeUCOfficialType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTreeUCOfficial (::std::unique_ptr< TreeUCOfficialType > p);

    //@}

    /**
     * @name treeUCSelfTreat
     *
     * @brief Accessor and modifier functions for the %treeUCSelfTreat
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecisionTree TreeUCSelfTreatType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreeUCSelfTreatType, char > TreeUCSelfTreatTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TreeUCSelfTreatType&
    getTreeUCSelfTreat () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TreeUCSelfTreatType&
    getTreeUCSelfTreat ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreeUCSelfTreat (const TreeUCSelfTreatType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTreeUCSelfTreat (::std::unique_ptr< TreeUCSelfTreatType > p);

    //@}

    /**
     * @name cureRateSevere
     *
     * @brief Accessor and modifier functions for the %cureRateSevere
     * required element.
     *
     * The probability of clearing parasites given access to
     * appropriate (hospital) care, for a severe case.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DoubleValue CureRateSevereType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CureRateSevereType, char > CureRateSevereTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CureRateSevereType&
    getCureRateSevere () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CureRateSevereType&
    getCureRateSevere ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCureRateSevere (const CureRateSevereType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCureRateSevere (::std::unique_ptr< CureRateSevereType > p);

    //@}

    /**
     * @name treatmentSevere
     *
     * @brief Accessor and modifier functions for the %treatmentSevere
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TreatmentOption TreatmentSevereType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreatmentSevereType, char > TreatmentSevereTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TreatmentSevereType&
    getTreatmentSevere () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TreatmentSevereType&
    getTreatmentSevere ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreatmentSevere (const TreatmentSevereType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTreatmentSevere (::std::unique_ptr< TreatmentSevereType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * Name of health system
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HSDT5Day (const PSeekOfficialCareUncomplicated1Type&,
              const PSelfTreatUncomplicatedType&,
              const PSeekOfficialCareUncomplicated2Type&,
              const PSeekOfficialCareSevereType&,
              const TreeUCOfficialType&,
              const TreeUCSelfTreatType&,
              const CureRateSevereType&,
              const TreatmentSevereType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    HSDT5Day (::std::unique_ptr< PSeekOfficialCareUncomplicated1Type >,
              ::std::unique_ptr< PSelfTreatUncomplicatedType >,
              ::std::unique_ptr< PSeekOfficialCareUncomplicated2Type >,
              ::std::unique_ptr< PSeekOfficialCareSevereType >,
              ::std::unique_ptr< TreeUCOfficialType >,
              ::std::unique_ptr< TreeUCSelfTreatType >,
              ::std::unique_ptr< CureRateSevereType >,
              ::std::unique_ptr< TreatmentSevereType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HSDT5Day (const xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HSDT5Day (const HSDT5Day& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HSDT5Day*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HSDT5Day&
    operator= (const HSDT5Day& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HSDT5Day ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PSeekOfficialCareUncomplicated1Type > pSeekOfficialCareUncomplicated1_;
    ::xsd::cxx::tree::one< PSelfTreatUncomplicatedType > pSelfTreatUncomplicated_;
    ::xsd::cxx::tree::one< PSeekOfficialCareUncomplicated2Type > pSeekOfficialCareUncomplicated2_;
    ::xsd::cxx::tree::one< PSeekOfficialCareSevereType > pSeekOfficialCareSevere_;
    LiverStageDrugOptional liverStageDrug_;
    ::xsd::cxx::tree::one< TreeUCOfficialType > treeUCOfficial_;
    ::xsd::cxx::tree::one< TreeUCSelfTreatType > treeUCSelfTreat_;
    ::xsd::cxx::tree::one< CureRateSevereType > cureRateSevere_;
    ::xsd::cxx::tree::one< TreatmentSevereType > treatmentSevere_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HSEventScheduler schema type.
   *
   * @nosubgrouping
   */
  class HSEventScheduler: public ::xml_schema::Type
  {
    public:
    /**
     * @name uncomplicated
     *
     * @brief Accessor and modifier functions for the %uncomplicated
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecisionTree UncomplicatedType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UncomplicatedType, char > UncomplicatedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const UncomplicatedType&
    getUncomplicated () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    UncomplicatedType&
    getUncomplicated ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUncomplicated (const UncomplicatedType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setUncomplicated (::std::unique_ptr< UncomplicatedType > p);

    //@}

    /**
     * @name complicated
     *
     * @brief Accessor and modifier functions for the %complicated
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecisionTree ComplicatedType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComplicatedType, char > ComplicatedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ComplicatedType&
    getComplicated () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ComplicatedType&
    getComplicated ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setComplicated (const ComplicatedType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setComplicated (::std::unique_ptr< ComplicatedType > p);

    //@}

    /**
     * @name ClinicalOutcomes
     *
     * @brief Accessor and modifier functions for the %ClinicalOutcomes
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ClinicalOutcomes ClinicalOutcomesType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ClinicalOutcomesType, char > ClinicalOutcomesTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ClinicalOutcomesType&
    getClinicalOutcomes () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ClinicalOutcomesType&
    getClinicalOutcomes ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setClinicalOutcomes (const ClinicalOutcomesType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setClinicalOutcomes (::std::unique_ptr< ClinicalOutcomesType > p);

    //@}

    /**
     * @name NonMalariaFevers
     *
     * @brief Accessor and modifier functions for the %NonMalariaFevers
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::HSESNMF NonMalariaFeversType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NonMalariaFeversType > NonMalariaFeversOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NonMalariaFeversType, char > NonMalariaFeversTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NonMalariaFeversOptional&
    getNonMalariaFevers () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NonMalariaFeversOptional&
    getNonMalariaFevers ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNonMalariaFevers (const NonMalariaFeversType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNonMalariaFevers (const NonMalariaFeversOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNonMalariaFevers (::std::unique_ptr< NonMalariaFeversType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HSEventScheduler (const UncomplicatedType&,
                      const ComplicatedType&,
                      const ClinicalOutcomesType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    HSEventScheduler (::std::unique_ptr< UncomplicatedType >,
                      ::std::unique_ptr< ComplicatedType >,
                      ::std::unique_ptr< ClinicalOutcomesType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HSEventScheduler (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HSEventScheduler (const HSEventScheduler& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HSEventScheduler*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HSEventScheduler&
    operator= (const HSEventScheduler& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HSEventScheduler ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< UncomplicatedType > uncomplicated_;
    ::xsd::cxx::tree::one< ComplicatedType > complicated_;
    ::xsd::cxx::tree::one< ClinicalOutcomesType > ClinicalOutcomes_;
    NonMalariaFeversOptional NonMalariaFevers_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %ClinicalOutcomes schema type.
   *
   * Description of base parameters of the clinical model.
   *
   * @nosubgrouping
   */
  class ClinicalOutcomes: public ::xml_schema::Type
  {
    public:
    /**
     * @name maxUCSeekingMemory
     *
     * @brief Accessor and modifier functions for the %maxUCSeekingMemory
     * required element.
     *
     * Maximum number of timesteps (including first day of case) that an
     * individual with an uncomplicated case of
     * malaria will remember he/she was sick before resetting.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int MaxUCSeekingMemoryType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MaxUCSeekingMemoryType, char > MaxUCSeekingMemoryTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const MaxUCSeekingMemoryType&
    getMaxUCSeekingMemory () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    MaxUCSeekingMemoryType&
    getMaxUCSeekingMemory ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMaxUCSeekingMemory (const MaxUCSeekingMemoryType& x);

    //@}

    /**
     * @name uncomplicatedCaseDuration
     *
     * @brief Accessor and modifier functions for the %uncomplicatedCaseDuration
     * required element.
     *
     * Fixed length of an uncomplicated case of malarial or non-malarial
     * sickness (from treatment seeking until return to life-as-usual).
     * Usually 3.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int UncomplicatedCaseDurationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< UncomplicatedCaseDurationType, char > UncomplicatedCaseDurationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const UncomplicatedCaseDurationType&
    getUncomplicatedCaseDuration () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    UncomplicatedCaseDurationType&
    getUncomplicatedCaseDuration ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setUncomplicatedCaseDuration (const UncomplicatedCaseDurationType& x);

    //@}

    /**
     * @name complicatedCaseDuration
     *
     * @brief Accessor and modifier functions for the %complicatedCaseDuration
     * required element.
     *
     * Fixed length of a complicated or severe case of malaria
     * (from treatment seeking until return to life-as-usual).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int ComplicatedCaseDurationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComplicatedCaseDurationType, char > ComplicatedCaseDurationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ComplicatedCaseDurationType&
    getComplicatedCaseDuration () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ComplicatedCaseDurationType&
    getComplicatedCaseDuration ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setComplicatedCaseDuration (const ComplicatedCaseDurationType& x);

    //@}

    /**
     * @name complicatedRiskDuration
     *
     * @brief Accessor and modifier functions for the %complicatedRiskDuration
     * required element.
     *
     * Number of days for which humans are at risk of death during a severe
     * or complicated case of malaria. Cannot be greater than the duration
     * of a complicated case or less than 1 day.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Int ComplicatedRiskDurationType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComplicatedRiskDurationType, char > ComplicatedRiskDurationTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const ComplicatedRiskDurationType&
    getComplicatedRiskDuration () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    ComplicatedRiskDurationType&
    getComplicatedRiskDuration ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setComplicatedRiskDuration (const ComplicatedRiskDurationType& x);

    //@}

    /**
     * @name dailyPrImmUCTS
     *
     * @brief Accessor and modifier functions for the %dailyPrImmUCTS
     * sequence element.
     *
     * It is sometimes desirable to model delays to treatment-seeking in
     * uncomplicated cases. While treatment of drugs can be delayed within
     * case management trees to provide a similar effect, this doesn't
     * delay any of the decisions, including diagnostics using the current
     * parasite density.
     * 
     * Instead a list of dailyPrImmUCTS elements can be used, describing
     * successive daily probabilities of treatment (sum must be 1). For
     * example, with a list of two elements with values 0.8 and 0.2, for
     * 80% of UC cases the decision tree is evaluated immediately, and for
     * 20% of cases evaluation is delayed by one day.
     * 
     * For no delay, use one element with a value of 1.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double DailyPrImmUCTSType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DailyPrImmUCTSType > DailyPrImmUCTSSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< DailyPrImmUCTSType >::iterator DailyPrImmUCTSIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< DailyPrImmUCTSType >::const_iterator DailyPrImmUCTSConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DailyPrImmUCTSType, char, ::xsd::cxx::tree::schema_type::double_ > DailyPrImmUCTSTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DailyPrImmUCTSSequence&
    getDailyPrImmUCTS () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DailyPrImmUCTSSequence&
    getDailyPrImmUCTS ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDailyPrImmUCTS (const DailyPrImmUCTSSequence& s);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ClinicalOutcomes (const MaxUCSeekingMemoryType&,
                      const UncomplicatedCaseDurationType&,
                      const ComplicatedCaseDurationType&,
                      const ComplicatedRiskDurationType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ClinicalOutcomes (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClinicalOutcomes (const ClinicalOutcomes& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ClinicalOutcomes*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClinicalOutcomes&
    operator= (const ClinicalOutcomes& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ClinicalOutcomes ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< MaxUCSeekingMemoryType > maxUCSeekingMemory_;
    ::xsd::cxx::tree::one< UncomplicatedCaseDurationType > uncomplicatedCaseDuration_;
    ::xsd::cxx::tree::one< ComplicatedCaseDurationType > complicatedCaseDuration_;
    ::xsd::cxx::tree::one< ComplicatedRiskDurationType > complicatedRiskDuration_;
    DailyPrImmUCTSSequence dailyPrImmUCTS_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %HSESNMF schema type.
   *
   * Description of non-malaria fever health-system modelling (treatment,
   * outcomes and costing). Incidence is described by the 
   * model->clinical->NonMalariaFevers element. Non-malaria fevers are only
   * modelled if the NON_MALARIA_FEVERS option is used.
   * 
   * As further explanation of the parameters below, we first take:
   * ?? = logit(P?) - ???P(need),
   * and then calculate the probability of antibiotic administration,
   * P(AB),
   * dependent on treatment seeking location.
   * No seeking: P(AB) = 0
   * Informal sector: logit(P(AB)) = ?? + ??
   * Health facility: logit(P(AB)) = ?? + ???I(neg) + ???I(pos) +
   * ???I(need)
   * (where I(X) is 1 when event X is true and 0 otherwise,
   * logit(p)=log(p/(1-p)), event "need" is the event that death may occur
   * without treatment, events "neg" and "pos" are the events that a
   * malaria
   * parasite diagnositic was used and indicated no parasites and parasites
   * respectively).
   *
   * @nosubgrouping
   */
  class HSESNMF: public ::xml_schema::Type
  {
    public:
    /**
     * @name prTreatment
     *
     * @brief Accessor and modifier functions for the %prTreatment
     * required element.
     *
     * Probability of a non-malaria fever being treated with an antibiotic
     * given that no malaria diagnostic was used but independent of need.
     * Symbol: P?.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double PrTreatmentType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PrTreatmentType, char, ::xsd::cxx::tree::schema_type::double_ > PrTreatmentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PrTreatmentType&
    getPrTreatment () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PrTreatmentType&
    getPrTreatment ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPrTreatment (const PrTreatmentType& x);

    //@}

    /**
     * @name effectNegativeTest
     *
     * @brief Accessor and modifier functions for the %effectNegativeTest
     * required element.
     *
     * The effect of a negative malaria diagnostic on the odds ratio of
     * receiving antibiotics. Symbol: exp(??).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double EffectNegativeTestType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EffectNegativeTestType, char, ::xsd::cxx::tree::schema_type::double_ > EffectNegativeTestTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EffectNegativeTestType&
    getEffectNegativeTest () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EffectNegativeTestType&
    getEffectNegativeTest ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEffectNegativeTest (const EffectNegativeTestType& x);

    //@}

    /**
     * @name effectPositiveTest
     *
     * @brief Accessor and modifier functions for the %effectPositiveTest
     * required element.
     *
     * The effect of a positive malaria diagnostic on the odds ratio of
     * receiving antibiotics. Symbol: exp(??).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double EffectPositiveTestType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EffectPositiveTestType, char, ::xsd::cxx::tree::schema_type::double_ > EffectPositiveTestTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EffectPositiveTestType&
    getEffectPositiveTest () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EffectPositiveTestType&
    getEffectPositiveTest ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEffectPositiveTest (const EffectPositiveTestType& x);

    //@}

    /**
     * @name effectNeed
     *
     * @brief Accessor and modifier functions for the %effectNeed
     * required element.
     *
     * The effect of needing antibiotic treatment on the odds ratio of
     * receiving antibiotics. Symbol: exp(??).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double EffectNeedType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EffectNeedType, char, ::xsd::cxx::tree::schema_type::double_ > EffectNeedTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EffectNeedType&
    getEffectNeed () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EffectNeedType&
    getEffectNeed ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEffectNeed (const EffectNeedType& x);

    //@}

    /**
     * @name effectInformal
     *
     * @brief Accessor and modifier functions for the %effectInformal
     * required element.
     *
     * The effect of seeking treatment from an informal provider (i.e.
     * a provider untrained in NMF diagnosis) on the odds ratio of
     * receiving antibiotics. Symbol: exp(??)
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double EffectInformalType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< EffectInformalType, char, ::xsd::cxx::tree::schema_type::double_ > EffectInformalTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const EffectInformalType&
    getEffectInformal () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    EffectInformalType&
    getEffectInformal ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setEffectInformal (const EffectInformalType& x);

    //@}

    /**
     * @name CFR
     *
     * @brief Accessor and modifier functions for the %CFR
     * required element.
     *
     * Base case fatality rate for non-malaria fevers (probability of
     * death from a fever requiring antibiotic treatment given that no
     * antibiotic treatment is received, per age-group).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::AgeGroupValues CFRType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CFRType, char > CFRTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const CFRType&
    getCFR () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    CFRType&
    getCFR ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCFR (const CFRType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setCFR (::std::unique_ptr< CFRType > p);

    //@}

    /**
     * @name TreatmentEfficacy
     *
     * @brief Accessor and modifier functions for the %TreatmentEfficacy
     * required element.
     *
     * Probability that treatment would prevent a death (i.e. CFR is
     * multiplied by one minus this when treatment occurs).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::xml_schema::Double TreatmentEfficacyType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreatmentEfficacyType, char, ::xsd::cxx::tree::schema_type::double_ > TreatmentEfficacyTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const TreatmentEfficacyType&
    getTreatmentEfficacy () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    TreatmentEfficacyType&
    getTreatmentEfficacy ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreatmentEfficacy (const TreatmentEfficacyType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    HSESNMF (const PrTreatmentType&,
             const EffectNegativeTestType&,
             const EffectPositiveTestType&,
             const EffectNeedType&,
             const EffectInformalType&,
             const CFRType&,
             const TreatmentEfficacyType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    HSESNMF (const PrTreatmentType&,
             const EffectNegativeTestType&,
             const EffectPositiveTestType&,
             const EffectNeedType&,
             const EffectInformalType&,
             ::std::unique_ptr< CFRType >,
             const TreatmentEfficacyType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    HSESNMF (const xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HSESNMF (const HSESNMF& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual HSESNMF*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    HSESNMF&
    operator= (const HSESNMF& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~HSESNMF ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PrTreatmentType > prTreatment_;
    ::xsd::cxx::tree::one< EffectNegativeTestType > effectNegativeTest_;
    ::xsd::cxx::tree::one< EffectPositiveTestType > effectPositiveTest_;
    ::xsd::cxx::tree::one< EffectNeedType > effectNeed_;
    ::xsd::cxx::tree::one< EffectInformalType > effectInformal_;
    ::xsd::cxx::tree::one< CFRType > CFR_;
    ::xsd::cxx::tree::one< TreatmentEfficacyType > TreatmentEfficacy_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DecisionTree schema type.
   *
   * Describes how "decisions" are made, both probabilistically and
   * deterministically, and what actions are carried out.
   * 
   * Quantities may also be reported as a side effect of decisions made in
   * the tree, for example the number of diagnostics used.
   *
   * @nosubgrouping
   */
  class DecisionTree: public ::xml_schema::Type
  {
    public:
    /**
     * @name multiple
     *
     * @brief Accessor and modifier functions for the %multiple
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTMultiple MultipleType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< MultipleType > MultipleOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< MultipleType, char > MultipleTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const MultipleOptional&
    getMultiple () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    MultipleOptional&
    getMultiple ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setMultiple (const MultipleType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setMultiple (const MultipleOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setMultiple (::std::unique_ptr< MultipleType > p);

    //@}

    /**
     * @name caseType
     *
     * @brief Accessor and modifier functions for the %caseType
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTCaseType CaseTypeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CaseTypeType > CaseTypeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CaseTypeType, char > CaseTypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CaseTypeOptional&
    getCaseType () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CaseTypeOptional&
    getCaseType ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCaseType (const CaseTypeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCaseType (const CaseTypeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCaseType (::std::unique_ptr< CaseTypeType > p);

    //@}

    /**
     * @name diagnostic
     *
     * @brief Accessor and modifier functions for the %diagnostic
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTDiagnostic DiagnosticType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< DiagnosticType > DiagnosticOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DiagnosticType, char > DiagnosticTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const DiagnosticOptional&
    getDiagnostic () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    DiagnosticOptional&
    getDiagnostic ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setDiagnostic (const DiagnosticType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setDiagnostic (const DiagnosticOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setDiagnostic (::std::unique_ptr< DiagnosticType > p);

    //@}

    /**
     * @name random
     *
     * @brief Accessor and modifier functions for the %random
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTRandom RandomType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< RandomType > RandomOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RandomType, char > RandomTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const RandomOptional&
    getRandom () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    RandomOptional&
    getRandom ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setRandom (const RandomType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setRandom (const RandomOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setRandom (::std::unique_ptr< RandomType > p);

    //@}

    /**
     * @name age
     *
     * @brief Accessor and modifier functions for the %age
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTAge AgeType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AgeType > AgeOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AgeType, char > AgeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AgeOptional&
    getAge () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AgeOptional&
    getAge ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAge (const AgeType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAge (const AgeOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAge (::std::unique_ptr< AgeType > p);

    //@}

    /**
     * @name noTreatment
     *
     * @brief Accessor and modifier functions for the %noTreatment
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTNoTreatment NoTreatmentType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NoTreatmentType > NoTreatmentOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NoTreatmentType, char > NoTreatmentTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NoTreatmentOptional&
    getNoTreatment () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    NoTreatmentOptional&
    getNoTreatment ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNoTreatment (const NoTreatmentType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setNoTreatment (const NoTreatmentOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setNoTreatment (::std::unique_ptr< NoTreatmentType > p);

    //@}

    /**
     * @name treatFailure
     *
     * @brief Accessor and modifier functions for the %treatFailure
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTTreatFailure TreatFailureType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TreatFailureType > TreatFailureOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreatFailureType, char > TreatFailureTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TreatFailureOptional&
    getTreatFailure () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TreatFailureOptional&
    getTreatFailure ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreatFailure (const TreatFailureType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTreatFailure (const TreatFailureOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTreatFailure (::std::unique_ptr< TreatFailureType > p);

    //@}

    /**
     * @name treatPKPD
     *
     * @brief Accessor and modifier functions for the %treatPKPD
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTTreatPKPD TreatPKPDType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TreatPKPDType > TreatPKPDSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< TreatPKPDType >::iterator TreatPKPDIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< TreatPKPDType >::const_iterator TreatPKPDConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreatPKPDType, char > TreatPKPDTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TreatPKPDSequence&
    getTreatPKPD () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TreatPKPDSequence&
    getTreatPKPD ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTreatPKPD (const TreatPKPDSequence& s);

    //@}

    /**
     * @name treatSimple
     *
     * @brief Accessor and modifier functions for the %treatSimple
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTTreatSimple TreatSimpleType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TreatSimpleType > TreatSimpleOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreatSimpleType, char > TreatSimpleTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TreatSimpleOptional&
    getTreatSimple () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TreatSimpleOptional&
    getTreatSimple ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreatSimple (const TreatSimpleType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTreatSimple (const TreatSimpleOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTreatSimple (::std::unique_ptr< TreatSimpleType > p);

    //@}

    /**
     * @name deploy
     *
     * @brief Accessor and modifier functions for the %deploy
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTDeploy DeployType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DeployType > DeploySequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::iterator DeployIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::const_iterator DeployConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeployType, char > DeployTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DeploySequence&
    getDeploy () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DeploySequence&
    getDeploy ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDeploy (const DeploySequence& s);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * An optional piece of documentation attached to this node.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DecisionTree ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DecisionTree (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DecisionTree (const DecisionTree& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DecisionTree*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DecisionTree&
    operator= (const DecisionTree& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DecisionTree ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    MultipleOptional multiple_;
    CaseTypeOptional caseType_;
    DiagnosticOptional diagnostic_;
    RandomOptional random_;
    AgeOptional age_;
    NoTreatmentOptional noTreatment_;
    TreatFailureOptional treatFailure_;
    TreatPKPDSequence treatPKPD_;
    TreatSimpleOptional treatSimple_;
    DeploySequence deploy_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DTMultiple schema type.
   *
   * A special node allowing multiple sub-trees to be evaluated.
   * 
   * This is different from an ordinary decision tree node in that:
   * 
   * a) multiple types of child can occur simultaneously (e.g. multiple
   * types of treatment or treatment plus a 'random' sub-tree)
   * 
   * b) the 'noTreatment' and 'treatFailure' nodes are not allowed
   *
   * @nosubgrouping
   */
  class DTMultiple: public ::xml_schema::Type
  {
    public:
    /**
     * @name caseType
     *
     * @brief Accessor and modifier functions for the %caseType
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTCaseType CaseTypeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< CaseTypeType > CaseTypeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< CaseTypeType >::iterator CaseTypeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< CaseTypeType >::const_iterator CaseTypeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CaseTypeType, char > CaseTypeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const CaseTypeSequence&
    getCaseType () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    CaseTypeSequence&
    getCaseType ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setCaseType (const CaseTypeSequence& s);

    //@}

    /**
     * @name diagnostic
     *
     * @brief Accessor and modifier functions for the %diagnostic
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTDiagnostic DiagnosticType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DiagnosticType > DiagnosticSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< DiagnosticType >::iterator DiagnosticIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< DiagnosticType >::const_iterator DiagnosticConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DiagnosticType, char > DiagnosticTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DiagnosticSequence&
    getDiagnostic () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DiagnosticSequence&
    getDiagnostic ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDiagnostic (const DiagnosticSequence& s);

    //@}

    /**
     * @name random
     *
     * @brief Accessor and modifier functions for the %random
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTRandom RandomType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< RandomType > RandomSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< RandomType >::iterator RandomIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< RandomType >::const_iterator RandomConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< RandomType, char > RandomTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const RandomSequence&
    getRandom () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    RandomSequence&
    getRandom ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setRandom (const RandomSequence& s);

    //@}

    /**
     * @name age
     *
     * @brief Accessor and modifier functions for the %age
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTAge AgeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< AgeType > AgeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< AgeType >::iterator AgeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< AgeType >::const_iterator AgeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AgeType, char > AgeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const AgeSequence&
    getAge () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    AgeSequence&
    getAge ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setAge (const AgeSequence& s);

    //@}

    /**
     * @name treatPKPD
     *
     * @brief Accessor and modifier functions for the %treatPKPD
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTTreatPKPD TreatPKPDType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< TreatPKPDType > TreatPKPDSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< TreatPKPDType >::iterator TreatPKPDIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< TreatPKPDType >::const_iterator TreatPKPDConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreatPKPDType, char > TreatPKPDTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const TreatPKPDSequence&
    getTreatPKPD () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    TreatPKPDSequence&
    getTreatPKPD ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setTreatPKPD (const TreatPKPDSequence& s);

    //@}

    /**
     * @name treatSimple
     *
     * @brief Accessor and modifier functions for the %treatSimple
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTTreatSimple TreatSimpleType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< TreatSimpleType > TreatSimpleOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< TreatSimpleType, char > TreatSimpleTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const TreatSimpleOptional&
    getTreatSimple () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    TreatSimpleOptional&
    getTreatSimple ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setTreatSimple (const TreatSimpleType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setTreatSimple (const TreatSimpleOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setTreatSimple (::std::unique_ptr< TreatSimpleType > p);

    //@}

    /**
     * @name deploy
     *
     * @brief Accessor and modifier functions for the %deploy
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DTDeploy DeployType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< DeployType > DeploySequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::iterator DeployIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< DeployType >::const_iterator DeployConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< DeployType, char > DeployTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const DeploySequence&
    getDeploy () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    DeploySequence&
    getDeploy ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setDeploy (const DeploySequence& s);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * An optional piece of documentation attached to this node.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DTMultiple ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DTMultiple (const xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTMultiple (const DTMultiple& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DTMultiple*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTMultiple&
    operator= (const DTMultiple& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DTMultiple ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CaseTypeSequence caseType_;
    DiagnosticSequence diagnostic_;
    RandomSequence random_;
    AgeSequence age_;
    TreatPKPDSequence treatPKPD_;
    TreatSimpleOptional treatSimple_;
    DeploySequence deploy_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DTCaseType schema type.
   *
   * A switch which choses a branch deterministically, based on whether the
   * patient was treated recently (second line) or not (first line).
   * 
   * For uncomplicated cases only.
   *
   * @nosubgrouping
   */
  class DTCaseType: public ::xml_schema::Type
  {
    public:
    /**
     * @name firstLine
     *
     * @brief Accessor and modifier functions for the %firstLine
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecisionTree FirstLineType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< FirstLineType, char > FirstLineTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const FirstLineType&
    getFirstLine () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    FirstLineType&
    getFirstLine ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setFirstLine (const FirstLineType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setFirstLine (::std::unique_ptr< FirstLineType > p);

    //@}

    /**
     * @name secondLine
     *
     * @brief Accessor and modifier functions for the %secondLine
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecisionTree SecondLineType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SecondLineType, char > SecondLineTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const SecondLineType&
    getSecondLine () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    SecondLineType&
    getSecondLine ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSecondLine (const SecondLineType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSecondLine (::std::unique_ptr< SecondLineType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * An optional piece of documentation attached to this node.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DTCaseType (const FirstLineType&,
                const SecondLineType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    DTCaseType (::std::unique_ptr< FirstLineType >,
                ::std::unique_ptr< SecondLineType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DTCaseType (const xercesc::DOMElement& e,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTCaseType (const DTCaseType& x,
                ::xml_schema::Flags f = 0,
                ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DTCaseType*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTCaseType&
    operator= (const DTCaseType& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DTCaseType ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< FirstLineType > firstLine_;
    ::xsd::cxx::tree::one< SecondLineType > secondLine_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DTDiagnostic schema type.
   *
   * A switch which choses a branch deterministically, based on the outcome
   * of some type of diagnostic.
   *
   * @nosubgrouping
   */
  class DTDiagnostic: public ::xml_schema::Type
  {
    public:
    /**
     * @name positive
     *
     * @brief Accessor and modifier functions for the %positive
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecisionTree PositiveType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PositiveType, char > PositiveTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const PositiveType&
    getPositive () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    PositiveType&
    getPositive ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPositive (const PositiveType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setPositive (::std::unique_ptr< PositiveType > p);

    //@}

    /**
     * @name negative
     *
     * @brief Accessor and modifier functions for the %negative
     * required element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::DecisionTree NegativeType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< NegativeType, char > NegativeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const NegativeType&
    getNegative () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    NegativeType&
    getNegative ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setNegative (const NegativeType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setNegative (::std::unique_ptr< NegativeType > p);

    //@}

    /**
     * @name diagnostic
     *
     * @brief Accessor and modifier functions for the %diagnostic
     * required attribute.
     *
     * Should match the name of some parameterised diagnostic (see
     * scenario/diagnostics).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String DiagnosticType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DiagnosticType, char > DiagnosticTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const DiagnosticType&
    getDiagnostic () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    DiagnosticType&
    getDiagnostic ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDiagnostic (const DiagnosticType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDiagnostic (::std::unique_ptr< DiagnosticType > p);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * An optional piece of documentation attached to this node.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DTDiagnostic (const PositiveType&,
                  const NegativeType&,
                  const DiagnosticType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    DTDiagnostic (::std::unique_ptr< PositiveType >,
                  ::std::unique_ptr< NegativeType >,
                  const DiagnosticType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DTDiagnostic (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTDiagnostic (const DTDiagnostic& x,
                  ::xml_schema::Flags f = 0,
                  ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DTDiagnostic*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTDiagnostic&
    operator= (const DTDiagnostic& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DTDiagnostic ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PositiveType > positive_;
    ::xsd::cxx::tree::one< NegativeType > negative_;
    ::xsd::cxx::tree::one< DiagnosticType > diagnostic_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DTRandom schema type.
   *
   * A switch which choses a branch randomly.
   * 
   * Each branch must be listed with a probability; the sum of all these
   * probabilities must equal 1.
   *
   * @nosubgrouping
   */
  class DTRandom: public ::xml_schema::Type
  {
    public:
    /**
     * @name outcome
     *
     * @brief Accessor and modifier functions for the %outcome
     * sequence element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Outcome OutcomeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< OutcomeType > OutcomeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< OutcomeType >::iterator OutcomeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< OutcomeType >::const_iterator OutcomeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< OutcomeType, char > OutcomeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const OutcomeSequence&
    getOutcome () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    OutcomeSequence&
    getOutcome ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setOutcome (const OutcomeSequence& s);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * An optional piece of documentation attached to this node.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DTRandom ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DTRandom (const xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTRandom (const DTRandom& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DTRandom*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTRandom&
    operator= (const DTRandom& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DTRandom ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    OutcomeSequence outcome_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DTAge schema type.
   *
   * A switch which choses a branch deterministically, based on the
   * patient's age (in years).
   * 
   * Categories must uniquely cover all ages from birth, with no upper
   * bound. Categories must be listed in order of age, increasing; the
   * first
   * must have lower bound 0. Upper bounds are equal to the lower bound of
   * the next category, (but are exclusive where lower bounds are
   * inclusive); the last category has no upper bound.
   *
   * @nosubgrouping
   */
  class DTAge: public ::xml_schema::Type
  {
    public:
    /**
     * @name age
     *
     * @brief Accessor and modifier functions for the %age
     * sequence element.
     *
     * Describes a branch, selected for patients of a certain age.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::Age AgeType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< AgeType > AgeSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< AgeType >::iterator AgeIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< AgeType >::const_iterator AgeConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AgeType, char > AgeTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const AgeSequence&
    getAge () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    AgeSequence&
    getAge ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setAge (const AgeSequence& s);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * An optional piece of documentation attached to this node.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DTAge ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DTAge (const xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTAge (const DTAge& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DTAge*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTAge&
    operator= (const DTAge& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DTAge ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    AgeSequence age_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DTNoTreatment schema type.
   *
   * An end node doing nothing. This exists to explicitly state that no
   * treatment happens and to prevent trees from accidentally being left
   * incomplete.
   *
   * @nosubgrouping
   */
  class DTNoTreatment: public ::xml_schema::Type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * An optional piece of documentation attached to this node.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DTNoTreatment ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DTNoTreatment (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTNoTreatment (const DTNoTreatment& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DTNoTreatment*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTNoTreatment&
    operator= (const DTNoTreatment& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DTNoTreatment ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DTTreatFailure schema type.
   *
   * An end node which reports treatment but does not change
   * parasitalogical
   * status. This allows correct labelling of second-line cases.
   *
   * @nosubgrouping
   */
  class DTTreatFailure: public ::xml_schema::Type
  {
    public:
    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * An optional piece of documentation attached to this node.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DTTreatFailure ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DTTreatFailure (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTTreatFailure (const DTTreatFailure& x,
                    ::xml_schema::Flags f = 0,
                    ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DTTreatFailure*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTTreatFailure&
    operator= (const DTTreatFailure& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DTTreatFailure ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DTTreatPKPD schema type.
   *
   * A command to administer drugs according to a given schedule and
   * dosage table, optionally with a delay.
   *
   * @nosubgrouping
   */
  class DTTreatPKPD: public ::xml_schema::Type
  {
    public:
    /**
     * @name schedule
     *
     * @brief Accessor and modifier functions for the %schedule
     * required attribute.
     *
     * The name of a schedule to use for treatment.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String ScheduleType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ScheduleType, char > ScheduleTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ScheduleType&
    getSchedule () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ScheduleType&
    getSchedule ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSchedule (const ScheduleType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSchedule (::std::unique_ptr< ScheduleType > p);

    //@}

    /**
     * @name dosage
     *
     * @brief Accessor and modifier functions for the %dosage
     * required attribute.
     *
     * The name of a dosage table to use for treatment.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String DosageType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DosageType, char > DosageTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const DosageType&
    getDosage () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    DosageType&
    getDosage ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDosage (const DosageType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDosage (::std::unique_ptr< DosageType > p);

    //@}

    /**
     * @name delay_h
     *
     * @brief Accessor and modifier functions for the %delay_h
     * optional attribute with a default value.
     *
     * Optionally, this can be given to delay the start of treatment by a
     * given number of hours. If not specified, treatment is not delayed. If
     * a delay is given, all medications within the treatment schedule used
     * are delayed by this number of hours.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double Delay_hType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< Delay_hType, char, ::xsd::cxx::tree::schema_type::double_ > Delay_hTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const Delay_hType&
    getDelay_h () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    Delay_hType&
    getDelay_h ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDelay_h (const Delay_hType& x);

    /**
     * @brief Return the default value for the attribute.
     *
     * @return The attribute's default value.
     */
    static Delay_hType
    getDelay_hDefaultValue ();

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DTTreatPKPD (const ScheduleType&,
                 const DosageType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DTTreatPKPD (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTTreatPKPD (const DTTreatPKPD& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DTTreatPKPD*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTTreatPKPD&
    operator= (const DTTreatPKPD& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DTTreatPKPD ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ScheduleType > schedule_;
    ::xsd::cxx::tree::one< DosageType > dosage_;
    ::xsd::cxx::tree::one< Delay_hType > delay_h_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DTTreatSimple schema type.
   *
   * Simple treatment model, targetting liver- and/or blood-stage
   * infections. This is all-or-nothing treatment which, when deploymed,
   * completely clears all infections of the targetted stages. This makes
   * it
   * unsuitable for modeling resistance, but suitable for use with simple
   * infection models.
   * 
   * Infections are considered liver-stage when less than five days old and
   * blood-stage after that. Effects are described independently for the
   * two
   * stages.
   *
   * @nosubgrouping
   */
  class DTTreatSimple: public ::xml_schema::Type
  {
    public:
    /**
     * @name durationLiver
     *
     * @brief Accessor and modifier functions for the %durationLiver
     * required attribute.
     *
     * Controls action on liver-stage infections. 0 means no action, -1 step
     * is a compatibility option to act like treatment before schema version
     * 32 (which removed infections retrospectively), 1 step or any duration
     * which equals some whole number of steps n>0 means to clear all
     * liver-stage infections found on the next 1 or n steps.
     * 
     * Note on -1 compatibility option: the main difference to 1 step
     * (clearing on the next timestep) is that parasite densities will be
     * reduced immediately, and thus from the point of view of surveys and
     * mass screen and treat interventions a peak in density which is
     * immediately treated through case management will not be seen.
     * 
     * Can be specified in steps (e.g. 1t, -1t) or days (e.g. 5d).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String DurationLiverType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DurationLiverType, char > DurationLiverTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const DurationLiverType&
    getDurationLiver () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    DurationLiverType&
    getDurationLiver ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDurationLiver (const DurationLiverType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDurationLiver (::std::unique_ptr< DurationLiverType > p);

    //@}

    /**
     * @name durationBlood
     *
     * @brief Accessor and modifier functions for the %durationBlood
     * required attribute.
     *
     * Controls action on blood-stage infections. 0 means no action, -1 step
     * is a compatibility option to act like treatment before schema version
     * 32 (which removed infections retrospectively), 1 step or any duration
     * which equals some whole number of steps n>0 means to clear all
     * blood-stage infections found on the next 1 or n steps.
     * 
     * Note on -1 compatibility option: the main difference to 1 step
     * (clearing on the next timestep) is that parasite densities will be
     * reduced immediately, and thus from the point of view of surveys and
     * mass screen and treat interventions a peak in density which is
     * immediately treated through case management will not be seen.
     * 
     * Can be specified in steps (e.g. 1t, -1t) or days (e.g. 5d).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String DurationBloodType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DurationBloodType, char > DurationBloodTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const DurationBloodType&
    getDurationBlood () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    DurationBloodType&
    getDurationBlood ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDurationBlood (const DurationBloodType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDurationBlood (::std::unique_ptr< DurationBloodType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DTTreatSimple (const DurationLiverType&,
                   const DurationBloodType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DTTreatSimple (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTTreatSimple (const DTTreatSimple& x,
                   ::xml_schema::Flags f = 0,
                   ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DTTreatSimple*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTTreatSimple&
    operator= (const DTTreatSimple& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DTTreatSimple ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DurationLiverType > durationLiver_;
    ::xsd::cxx::tree::one< DurationBloodType > durationBlood_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %DTDeploy schema type.
   *
   * Deploy one or more intervention components.
   *
   * @nosubgrouping
   */
  class DTDeploy: public ::xml_schema::Type
  {
    public:
    /**
     * @name component
     *
     * @brief Accessor and modifier functions for the %component
     * required attribute.
     *
     * The identifier (short name) of a component.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String ComponentType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< ComponentType, char > ComponentTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const ComponentType&
    getComponent () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    ComponentType&
    getComponent ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setComponent (const ComponentType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setComponent (::std::unique_ptr< ComponentType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DTDeploy (const ComponentType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DTDeploy (const xercesc::DOMElement& e,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTDeploy (const DTDeploy& x,
              ::xml_schema::Flags f = 0,
              ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DTDeploy*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DTDeploy&
    operator= (const DTDeploy& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DTDeploy ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< ComponentType > component_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %TreatmentOption schema type.
   *
   * Describes the effects of the treatment, assuming this
   * compliance/adherence/... option is selected. Effects are described
   * in terms of a list of options, each of which acts independently but
   * with all effects being activated simultaneously.
   *
   * @nosubgrouping
   */
  class TreatmentOption: public ::scnXml::TriggeredDeployments
  {
    public:
    /**
     * @name clearInfections
     *
     * @brief Accessor and modifier functions for the %clearInfections
     * sequence element.
     *
     * This clears infections according to several options: it can clear
     * all blood stage infections, all liver stage infections or both, and
     * it can act on multiple timesteps. To have a probability of no
     * action add another treatment option (which does nothing) and set
     * the probabilities of selection appropriately.
     * 
     * This allows immediate (legacy) or delayed action, a prophylactic
     * period, and selection of which stages are targeted. It is a simple
     * model but appropriate enough for use with the five day timestep
     * when assuming no resistance and that drug
     * failure is mainly caused by bad drugs or compliance.
     * 
     * The old treatment action for the five-day timestep model is
     * essentially this, with immediateAction (timesteps=-1) and
     * stage=both, except for the IPT model's SP action, which was more
     * like with timesteps>1 and stage=blood.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::ClearInfections ClearInfectionsType;

    /**
     * @brief Element sequence container type.
     */
    typedef ::xsd::cxx::tree::sequence< ClearInfectionsType > ClearInfectionsSequence;

    /**
     * @brief Element iterator type.
     */
    typedef xsd::cxx::tree::sequence< ClearInfectionsType >::iterator ClearInfectionsIterator;

    /**
     * @brief Element constant iterator type.
     */
    typedef xsd::cxx::tree::sequence< ClearInfectionsType >::const_iterator ClearInfectionsConstIterator;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ClearInfectionsType, char > ClearInfectionsTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * sequence.
     *
     * @return A constant reference to the sequence container.
     */
    const ClearInfectionsSequence&
    getClearInfections () const;

    /**
     * @brief Return a read-write reference to the element sequence.
     *
     * @return A reference to the sequence container.
     */
    ClearInfectionsSequence&
    getClearInfections ();

    /**
     * @brief Copy elements from a given sequence.
     *
     * @param s A sequence to copy elements from.
     *
     * For each element in @a s this function makes a copy and adds it 
     * to the sequence. Note that this operation completely changes the 
     * sequence and all old elements will be lost.
     */
    void
    setClearInfections (const ClearInfectionsSequence& s);

    //@}

    /**
     * @name name
     *
     * @brief Accessor and modifier functions for the %name
     * optional attribute.
     *
     * Describes what this compliance option represents (e.g.
     * "good compliance", "poor compliance with good drugs", ...).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String NameType;

    /**
     * @brief Attribute optional container type.
     */
    typedef ::xsd::cxx::tree::optional< NameType > NameOptional;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< NameType, char > NameTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const NameOptional&
    getName () const;

    /**
     * @brief Return a read-write reference to the attribute container.
     *
     * @return A reference to the optional container.
     */
    NameOptional&
    getName ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setName (const NameType& x);

    /**
     * @brief Set the attribute value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the attribute.
     * Otherwise the attribute container is set the 'not present' state.
     */
    void
    setName (const NameOptional& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setName (::std::unique_ptr< NameType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TreatmentOption ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TreatmentOption (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TreatmentOption (const TreatmentOption& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TreatmentOption*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TreatmentOption&
    operator= (const TreatmentOption& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TreatmentOption ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ClearInfectionsSequence clearInfections_;
    NameOptional name_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NeonatalMortality schema type.
   *
   * @nosubgrouping
   */
  class NeonatalMortality: public ::xml_schema::Type
  {
    public:
    /**
     * @name diagnostic
     *
     * @brief Accessor and modifier functions for the %diagnostic
     * required attribute.
     *
     * The name of a diagnostic used to parameterise the model.
     * 
     * Neonatal mortality is derived from malaria patency of a certain
     * sub-population of humans. This is the diagnostic used to asses
     * patency for this purpose.
     * 
     * If this is not specified, the monitoring diagnostic is used.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String DiagnosticType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< DiagnosticType, char > DiagnosticTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const DiagnosticType&
    getDiagnostic () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    DiagnosticType&
    getDiagnostic ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setDiagnostic (const DiagnosticType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setDiagnostic (::std::unique_ptr< DiagnosticType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NeonatalMortality (const DiagnosticType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NeonatalMortality (const xercesc::DOMElement& e,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NeonatalMortality (const NeonatalMortality& x,
                       ::xml_schema::Flags f = 0,
                       ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NeonatalMortality*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NeonatalMortality&
    operator= (const NeonatalMortality& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NeonatalMortality ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< DiagnosticType > diagnostic_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %NonMalariaFevers schema type.
   *
   * Description of the incidence of non-malaria fever. Non-malaria fevers
   * are only modelled if the NON_MALARIA_FEVERS option is used.
   *
   * @nosubgrouping
   */
  class NonMalariaFevers: public ::xml_schema::Type
  {
    public:
    /**
     * @name incidence
     *
     * @brief Accessor and modifier functions for the %incidence
     * required element.
     *
     * Probability that a non-malaria fever occurs given that no concurrent
     * malaria fever occurs.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::AgeGroupValues IncidenceType;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< IncidenceType, char > IncidenceTraits;

    /**
     * @brief Return a read-only (constant) reference to the element.
     *
     * @return A constant reference to the element.
     */
    const IncidenceType&
    getIncidence () const;

    /**
     * @brief Return a read-write reference to the element.
     *
     * @return A reference to the element.
     */
    IncidenceType&
    getIncidence ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setIncidence (const IncidenceType& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setIncidence (::std::unique_ptr< IncidenceType > p);

    //@}

    /**
     * @name prNeedTreatmentNMF
     *
     * @brief Accessor and modifier functions for the %prNeedTreatmentNMF
     * optional element.
     *
     * Probability that a non-malarial fever requires treatment with
     * antibiotics (assuming fever is not induced by malaria, although
     * concurrent parasites may be present).
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::AgeGroupValues PrNeedTreatmentNMFType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PrNeedTreatmentNMFType > PrNeedTreatmentNMFOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PrNeedTreatmentNMFType, char > PrNeedTreatmentNMFTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PrNeedTreatmentNMFOptional&
    getPrNeedTreatmentNMF () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PrNeedTreatmentNMFOptional&
    getPrNeedTreatmentNMF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPrNeedTreatmentNMF (const PrNeedTreatmentNMFType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPrNeedTreatmentNMF (const PrNeedTreatmentNMFOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPrNeedTreatmentNMF (::std::unique_ptr< PrNeedTreatmentNMFType > p);

    //@}

    /**
     * @name prNeedTreatmentMF
     *
     * @brief Accessor and modifier functions for the %prNeedTreatmentMF
     * optional element.
     *
     * Probability that a malaria fever needs treatment with
     * antibiotics (assuming fever is induced by malaria, although
     * concurrent bacteria may be present).
     * 
     * Meaning partially overlaps with separate model for comorbidity
     * given malaria.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::AgeGroupValues PrNeedTreatmentMFType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< PrNeedTreatmentMFType > PrNeedTreatmentMFOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< PrNeedTreatmentMFType, char > PrNeedTreatmentMFTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const PrNeedTreatmentMFOptional&
    getPrNeedTreatmentMF () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    PrNeedTreatmentMFOptional&
    getPrNeedTreatmentMF ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setPrNeedTreatmentMF (const PrNeedTreatmentMFType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setPrNeedTreatmentMF (const PrNeedTreatmentMFOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setPrNeedTreatmentMF (::std::unique_ptr< PrNeedTreatmentMFType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    NonMalariaFevers (const IncidenceType&);

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes
     * (::std::unique_ptr version).
     *
     * This constructor will try to use the passed values directly
     * instead of making copies.
     */
    NonMalariaFevers (::std::unique_ptr< IncidenceType >);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    NonMalariaFevers (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NonMalariaFevers (const NonMalariaFevers& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual NonMalariaFevers*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    NonMalariaFevers&
    operator= (const NonMalariaFevers& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~NonMalariaFevers ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< IncidenceType > incidence_;
    PrNeedTreatmentNMFOptional prNeedTreatmentNMF_;
    PrNeedTreatmentMFOptional prNeedTreatmentMF_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %drugRegimen schema type.
   *
   * @nosubgrouping
   */
  class DrugRegimen: public ::xml_schema::Type
  {
    public:
    /**
     * @name firstLine
     *
     * @brief Accessor and modifier functions for the %firstLine
     * required attribute.
     *
     * Code for first line drug
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String FirstLineType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< FirstLineType, char > FirstLineTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const FirstLineType&
    getFirstLine () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    FirstLineType&
    getFirstLine ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setFirstLine (const FirstLineType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setFirstLine (::std::unique_ptr< FirstLineType > p);

    //@}

    /**
     * @name secondLine
     *
     * @brief Accessor and modifier functions for the %secondLine
     * required attribute.
     *
     * Code for second line drug
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String SecondLineType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< SecondLineType, char > SecondLineTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const SecondLineType&
    getSecondLine () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    SecondLineType&
    getSecondLine ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setSecondLine (const SecondLineType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setSecondLine (::std::unique_ptr< SecondLineType > p);

    //@}

    /**
     * @name inpatient
     *
     * @brief Accessor and modifier functions for the %inpatient
     * required attribute.
     *
     * Code for drug used for treating
     * inpatients
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String InpatientType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< InpatientType, char > InpatientTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const InpatientType&
    getInpatient () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    InpatientType&
    getInpatient ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setInpatient (const InpatientType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setInpatient (::std::unique_ptr< InpatientType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    DrugRegimen (const FirstLineType&,
                 const SecondLineType&,
                 const InpatientType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    DrugRegimen (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DrugRegimen (const DrugRegimen& x,
                 ::xml_schema::Flags f = 0,
                 ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual DrugRegimen*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    DrugRegimen&
    operator= (const DrugRegimen& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~DrugRegimen ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< FirstLineType > firstLine_;
    ::xsd::cxx::tree::one< SecondLineType > secondLine_;
    ::xsd::cxx::tree::one< InpatientType > inpatient_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %treatmentActions schema type.
   *
   * @nosubgrouping
   */
  class TreatmentActions: public ::xml_schema::Type
  {
    public:
    /**
     * @name CQ
     *
     * @brief Accessor and modifier functions for the %CQ
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TreatmentOption CQType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< CQType > CQOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< CQType, char > CQTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const CQOptional&
    getCQ () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    CQOptional&
    getCQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setCQ (const CQType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setCQ (const CQOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setCQ (::std::unique_ptr< CQType > p);

    //@}

    /**
     * @name SP
     *
     * @brief Accessor and modifier functions for the %SP
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TreatmentOption SPType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SPType > SPOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SPType, char > SPTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SPOptional&
    getSP () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SPOptional&
    getSP ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSP (const SPType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSP (const SPOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSP (::std::unique_ptr< SPType > p);

    //@}

    /**
     * @name AQ
     *
     * @brief Accessor and modifier functions for the %AQ
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TreatmentOption AQType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< AQType > AQOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< AQType, char > AQTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const AQOptional&
    getAQ () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    AQOptional&
    getAQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setAQ (const AQType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setAQ (const AQOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setAQ (::std::unique_ptr< AQType > p);

    //@}

    /**
     * @name SPAQ
     *
     * @brief Accessor and modifier functions for the %SPAQ
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TreatmentOption SPAQType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< SPAQType > SPAQOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< SPAQType, char > SPAQTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const SPAQOptional&
    getSPAQ () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    SPAQOptional&
    getSPAQ ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setSPAQ (const SPAQType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setSPAQ (const SPAQOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setSPAQ (::std::unique_ptr< SPAQType > p);

    //@}

    /**
     * @name ACT
     *
     * @brief Accessor and modifier functions for the %ACT
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TreatmentOption ACTType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< ACTType > ACTOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< ACTType, char > ACTTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const ACTOptional&
    getACT () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    ACTOptional&
    getACT ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setACT (const ACTType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setACT (const ACTOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setACT (::std::unique_ptr< ACTType > p);

    //@}

    /**
     * @name QN
     *
     * @brief Accessor and modifier functions for the %QN
     * optional element.
     */
    //@{

    /**
     * @brief Element type.
     */
    typedef ::scnXml::TreatmentOption QNType;

    /**
     * @brief Element optional container type.
     */
    typedef ::xsd::cxx::tree::optional< QNType > QNOptional;

    /**
     * @brief Element traits type.
     */
    typedef ::xsd::cxx::tree::traits< QNType, char > QNTraits;

    /**
     * @brief Return a read-only (constant) reference to the element
     * container.
     *
     * @return A constant reference to the optional container.
     */
    const QNOptional&
    getQN () const;

    /**
     * @brief Return a read-write reference to the element container.
     *
     * @return A reference to the optional container.
     */
    QNOptional&
    getQN ();

    /**
     * @brief Set the element value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the element.
     */
    void
    setQN (const QNType& x);

    /**
     * @brief Set the element value.
     *
     * @param x An optional container with the new value to set.
     *
     * If the value is present in @a x then this function makes a copy 
     * of this value and sets it as the new value of the element.
     * Otherwise the element container is set the 'not present' state.
     */
    void
    setQN (const QNOptional& x);

    /**
     * @brief Set the element value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly instead
     * of making a copy.
     */
    void
    setQN (::std::unique_ptr< QNType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    TreatmentActions ();

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    TreatmentActions (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TreatmentActions (const TreatmentActions& x,
                      ::xml_schema::Flags f = 0,
                      ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual TreatmentActions*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    TreatmentActions&
    operator= (const TreatmentActions& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~TreatmentActions ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    CQOptional CQ_;
    SPOptional SP_;
    AQOptional AQ_;
    SPAQOptional SPAQ_;
    ACTOptional ACT_;
    QNOptional QN_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %outcome schema type.
   *
   * @nosubgrouping
   */
  class Outcome: public ::scnXml::DecisionTree
  {
    public:
    /**
     * @name p
     *
     * @brief Accessor and modifier functions for the %p
     * required attribute.
     *
     * Probability of selecting this outcome. The sum of
     * probabilities across all outcomes must be 1.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double PType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< PType, char, ::xsd::cxx::tree::schema_type::double_ > PTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const PType&
    getP () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    PType&
    getP ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setP (const PType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Outcome (const PType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Outcome (const xercesc::DOMElement& e,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Outcome (const Outcome& x,
             ::xml_schema::Flags f = 0,
             ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Outcome*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Outcome&
    operator= (const Outcome& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Outcome ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< PType > p_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %age schema type.
   *
   * @nosubgrouping
   */
  class Age: public ::scnXml::DecisionTree
  {
    public:
    /**
     * @name lb
     *
     * @brief Accessor and modifier functions for the %lb
     * required attribute.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::Double LbType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< LbType, char, ::xsd::cxx::tree::schema_type::double_ > LbTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const LbType&
    getLb () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    LbType&
    getLb ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setLb (const LbType& x);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    Age (const LbType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Age (const xercesc::DOMElement& e,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Age (const Age& x,
         ::xml_schema::Flags f = 0,
         ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Age*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Age&
    operator= (const Age& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~Age ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< LbType > lb_;

    //@endcond
  };

  /**
   * @brief Class corresponding to the %clearInfections schema type.
   *
   * @nosubgrouping
   */
  class ClearInfections: public ::xml_schema::Type
  {
    public:
    /**
     * @name timesteps
     *
     * @brief Accessor and modifier functions for the %timesteps
     * required attribute.
     *
     * The number of timesteps during which this action remains
     * in effect (e.g. 2 means clear infections during the next
     * two timestep updates). Full clearance of the targeted stages
     * occurs during this time.
     * 
     * A special value of -1 means act immediately (retrospectively);
     * this the old behaviour. A value of 1 means act on the next
     * timestep only.
     * 
     * Both of these can be thought of as a model for short-acting
     * effective drug treatment; the main differences are that the
     * latter means parasite densities will remain high from the point
     * of view of surveys and diagnostics (i.e. mass screen and treat)
     * used before the next timestep and that the latter will also
     * remove infections starting the next timestep. Arguably the
     * latter is a better model, but the differences are perhaps
     * small, excepting where immediate treatment of fevers (i.e.
     * through the health system) can hide high parasite densities
     * from reporting and mass-screen-and-treat diagnostics. For
     * use by interventions, the latter model has nicer behaviour in
     * that the order of deployment of multiple interventions
     * deployed at the same time does not matter, and that the former
     * model retrospectively treats infections which may already have
     * caused fever, thus may have a lower health impact than it
     * should.
     * 
     * It is recommended to use the new model (value 1, or greater
     * than 1 if prophylactic effect is desired) unless wanting to
     * emulate the old behaviour.
     * 
     * Values of 0 or less than -1 are not allowed.
     * 
     * Can be specified in steps (e.g. 1t, -1t) or days (e.g. 5d).
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::xml_schema::String TimestepsType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< TimestepsType, char > TimestepsTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const TimestepsType&
    getTimesteps () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    TimestepsType&
    getTimesteps ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setTimesteps (const TimestepsType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setTimesteps (::std::unique_ptr< TimestepsType > p);

    //@}

    /**
     * @name stage
     *
     * @brief Accessor and modifier functions for the %stage
     * required attribute.
     *
     * Controls whether liver-stage or blood-stage infections
     * are cleared, or both.
     * 
     * Infections are considered liver-stage for one 5-day timestep,
     * blood-stage but pre-patent for some number of timesteps
     * (latentp - 1), then start the patent blood stage. If stage is
     * set to "liver", infections are only cleared during their first
     * timestep; if stage is set to "blood", infections are cleared
     * during pre-patent and patent blood stages; if stage is set to
     * "both" all infections are cleared.
     * 
     * The old behaviour (oddly considering the drugs it is meant to
     * emulate) is to clear both stages, except for the IPT model of
     * SP action, which cleared only patent blood-stage infections.
     */
    //@{

    /**
     * @brief Attribute type.
     */
    typedef ::scnXml::Stage StageType;

    /**
     * @brief Attribute traits type.
     */
    typedef ::xsd::cxx::tree::traits< StageType, char > StageTraits;

    /**
     * @brief Return a read-only (constant) reference to the attribute.
     *
     * @return A constant reference to the attribute.
     */
    const StageType&
    getStage () const;

    /**
     * @brief Return a read-write reference to the attribute.
     *
     * @return A reference to the attribute.
     */
    StageType&
    getStage ();

    /**
     * @brief Set the attribute value.
     *
     * @param x A new value to set.
     *
     * This function makes a copy of its argument and sets it as
     * the new value of the attribute.
     */
    void
    setStage (const StageType& x);

    /**
     * @brief Set the attribute value without copying.
     *
     * @param p A new value to use.
     *
     * This function will try to use the passed value directly
     * instead of making a copy.
     */
    void
    setStage (::std::unique_ptr< StageType > p);

    //@}

    /**
     * @name Constructors
     */
    //@{

    /**
     * @brief Create an instance from the ultimate base and
     * initializers for required elements and attributes.
     */
    ClearInfections (const TimestepsType&,
                     const StageType&);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    ClearInfections (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClearInfections (const ClearInfections& x,
                     ::xml_schema::Flags f = 0,
                     ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual ClearInfections*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Copy assignment operator.
     *
     * @param x An instance to make a copy of.
     * @return A reference to itself.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    ClearInfections&
    operator= (const ClearInfections& x);

    //@}

    /**
     * @brief Destructor.
     */
    virtual 
    ~ClearInfections ();

    // Implementation.
    //

    //@cond

    protected:
    void
    parse (::xsd::cxx::xml::dom::parser< char >&,
           ::xml_schema::Flags);

    protected:
    ::xsd::cxx::tree::one< TimestepsType > timesteps_;
    ::xsd::cxx::tree::one< StageType > stage_;

    //@endcond
  };

  /**
   * @brief Enumeration class corresponding to the %stage
   * schema type.
   */
  class Stage: public ::xml_schema::String
  {
    public:

    /**
     * @brief Underlying enum type.
     */
    enum Value
    {
      liver,
      blood,
      both
    };

    /**
     * @brief Create an instance from the underlying enum value.
     *
     * @param v A enum value.
     */
    Stage (Value v);

    /**
     * @brief Create an instance from a C string.
     *
     * @param v A string value.
     */
    Stage (const char* v);

    /**
     * @brief Create an instance from a string.
     *
     * @param v A string value.
     */
    Stage (const ::std::string& v);

    /**
     * @brief Create an instance from the base value.
     *
     * @param v A base value.
     */
    Stage (const ::xml_schema::String& v);

    /**
     * @brief Create an instance from a DOM element.
     *
     * @param e A DOM element to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Stage (const xercesc::DOMElement& e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a DOM attribute.
     *
     * @param a A DOM attribute to extract the data from.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Stage (const xercesc::DOMAttr& a,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Create an instance from a string fragment.
     *
     * @param s A string fragment to extract the data from.
     * @param e A pointer to DOM element containing the string fragment.
     * @param f Flags to create the new instance with.
     * @param c A pointer to the object that will contain the new
     * instance.
     */
    Stage (const ::std::string& s,
           const xercesc::DOMElement* e,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy constructor.
     *
     * @param x An instance to make a copy of.
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     *
     * For polymorphic object models use the @c _clone function instead.
     */
    Stage (const Stage& x,
           ::xml_schema::Flags f = 0,
           ::xml_schema::Container* c = 0);

    /**
     * @brief Copy the instance polymorphically.
     *
     * @param f Flags to create the copy with.
     * @param c A pointer to the object that will contain the copy.
     * @return A pointer to the dynamically allocated copy.
     *
     * This function ensures that the dynamic type of the instance is
     * used for copying and should be used for polymorphic object
     * models instead of the copy constructor.
     */
    virtual Stage*
    _clone (::xml_schema::Flags f = 0,
            ::xml_schema::Container* c = 0) const;

    /**
     * @brief Assign the underlying enum value.
     *
     * @param v A enum value.
     * @return A refernce to the instance.
     */
    Stage&
    operator= (Value v);

    /**
     * @brief Implicit conversion operator to the underlying
     * enum value.
     *
     * @return A enum value.
     */
    virtual
    operator Value () const
    {
      return _xsd_Stage_convert ();
    }

    //@cond

    protected:
    Value
    _xsd_Stage_convert () const;

    public:
    static const char* const _xsd_Stage_literals_[3];
    static const Value _xsd_Stage_indexes_[3];

    //@endcond
  };
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace scnXml
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_CODE_OPENMALARIA_SCHEMA_HEALTH_SYSTEM_H

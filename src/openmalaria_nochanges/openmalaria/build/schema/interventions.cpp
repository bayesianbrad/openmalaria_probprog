// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "interventions.h"

namespace scnXml
{
  // Interventions
  // 

  const Interventions::ChangeHSOptional& Interventions::
  getChangeHS () const
  {
    return this->changeHS_;
  }

  Interventions::ChangeHSOptional& Interventions::
  getChangeHS ()
  {
    return this->changeHS_;
  }

  void Interventions::
  setChangeHS (const ChangeHSType& x)
  {
    this->changeHS_.set (x);
  }

  void Interventions::
  setChangeHS (const ChangeHSOptional& x)
  {
    this->changeHS_ = x;
  }

  void Interventions::
  setChangeHS (::std::unique_ptr< ChangeHSType > x)
  {
    this->changeHS_.set (std::move (x));
  }

  const Interventions::ChangeEIROptional& Interventions::
  getChangeEIR () const
  {
    return this->changeEIR_;
  }

  Interventions::ChangeEIROptional& Interventions::
  getChangeEIR ()
  {
    return this->changeEIR_;
  }

  void Interventions::
  setChangeEIR (const ChangeEIRType& x)
  {
    this->changeEIR_.set (x);
  }

  void Interventions::
  setChangeEIR (const ChangeEIROptional& x)
  {
    this->changeEIR_ = x;
  }

  void Interventions::
  setChangeEIR (::std::unique_ptr< ChangeEIRType > x)
  {
    this->changeEIR_.set (std::move (x));
  }

  const Interventions::ImportedInfectionsOptional& Interventions::
  getImportedInfections () const
  {
    return this->importedInfections_;
  }

  Interventions::ImportedInfectionsOptional& Interventions::
  getImportedInfections ()
  {
    return this->importedInfections_;
  }

  void Interventions::
  setImportedInfections (const ImportedInfectionsType& x)
  {
    this->importedInfections_.set (x);
  }

  void Interventions::
  setImportedInfections (const ImportedInfectionsOptional& x)
  {
    this->importedInfections_ = x;
  }

  void Interventions::
  setImportedInfections (::std::unique_ptr< ImportedInfectionsType > x)
  {
    this->importedInfections_.set (std::move (x));
  }

  const Interventions::InsertR_0CaseOptional& Interventions::
  getInsertR_0Case () const
  {
    return this->insertR_0Case_;
  }

  Interventions::InsertR_0CaseOptional& Interventions::
  getInsertR_0Case ()
  {
    return this->insertR_0Case_;
  }

  void Interventions::
  setInsertR_0Case (const InsertR_0CaseType& x)
  {
    this->insertR_0Case_.set (x);
  }

  void Interventions::
  setInsertR_0Case (const InsertR_0CaseOptional& x)
  {
    this->insertR_0Case_ = x;
  }

  void Interventions::
  setInsertR_0Case (::std::unique_ptr< InsertR_0CaseType > x)
  {
    this->insertR_0Case_.set (std::move (x));
  }

  const Interventions::UninfectVectorsOptional& Interventions::
  getUninfectVectors () const
  {
    return this->uninfectVectors_;
  }

  Interventions::UninfectVectorsOptional& Interventions::
  getUninfectVectors ()
  {
    return this->uninfectVectors_;
  }

  void Interventions::
  setUninfectVectors (const UninfectVectorsType& x)
  {
    this->uninfectVectors_.set (x);
  }

  void Interventions::
  setUninfectVectors (const UninfectVectorsOptional& x)
  {
    this->uninfectVectors_ = x;
  }

  void Interventions::
  setUninfectVectors (::std::unique_ptr< UninfectVectorsType > x)
  {
    this->uninfectVectors_.set (std::move (x));
  }

  const Interventions::VectorPopOptional& Interventions::
  getVectorPop () const
  {
    return this->vectorPop_;
  }

  Interventions::VectorPopOptional& Interventions::
  getVectorPop ()
  {
    return this->vectorPop_;
  }

  void Interventions::
  setVectorPop (const VectorPopType& x)
  {
    this->vectorPop_.set (x);
  }

  void Interventions::
  setVectorPop (const VectorPopOptional& x)
  {
    this->vectorPop_ = x;
  }

  void Interventions::
  setVectorPop (::std::unique_ptr< VectorPopType > x)
  {
    this->vectorPop_.set (std::move (x));
  }

  const Interventions::VectorTrapOptional& Interventions::
  getVectorTrap () const
  {
    return this->vectorTrap_;
  }

  Interventions::VectorTrapOptional& Interventions::
  getVectorTrap ()
  {
    return this->vectorTrap_;
  }

  void Interventions::
  setVectorTrap (const VectorTrapType& x)
  {
    this->vectorTrap_.set (x);
  }

  void Interventions::
  setVectorTrap (const VectorTrapOptional& x)
  {
    this->vectorTrap_ = x;
  }

  void Interventions::
  setVectorTrap (::std::unique_ptr< VectorTrapType > x)
  {
    this->vectorTrap_.set (std::move (x));
  }

  const Interventions::HumanOptional& Interventions::
  getHuman () const
  {
    return this->human_;
  }

  Interventions::HumanOptional& Interventions::
  getHuman ()
  {
    return this->human_;
  }

  void Interventions::
  setHuman (const HumanType& x)
  {
    this->human_.set (x);
  }

  void Interventions::
  setHuman (const HumanOptional& x)
  {
    this->human_ = x;
  }

  void Interventions::
  setHuman (::std::unique_ptr< HumanType > x)
  {
    this->human_.set (std::move (x));
  }

  const Interventions::NameType& Interventions::
  getName () const
  {
    return this->name_.get ();
  }

  Interventions::NameType& Interventions::
  getName ()
  {
    return this->name_.get ();
  }

  void Interventions::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Interventions::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // HumanInterventions
  // 

  const HumanInterventions::ComponentSequence& HumanInterventions::
  getComponent () const
  {
    return this->component_;
  }

  HumanInterventions::ComponentSequence& HumanInterventions::
  getComponent ()
  {
    return this->component_;
  }

  void HumanInterventions::
  setComponent (const ComponentSequence& s)
  {
    this->component_ = s;
  }

  const HumanInterventions::DeploymentSequence& HumanInterventions::
  getDeployment () const
  {
    return this->deployment_;
  }

  HumanInterventions::DeploymentSequence& HumanInterventions::
  getDeployment ()
  {
    return this->deployment_;
  }

  void HumanInterventions::
  setDeployment (const DeploymentSequence& s)
  {
    this->deployment_ = s;
  }


  // HumanInterventionComponent
  // 

  const HumanInterventionComponent::ScreenOptional& HumanInterventionComponent::
  getScreen () const
  {
    return this->screen_;
  }

  HumanInterventionComponent::ScreenOptional& HumanInterventionComponent::
  getScreen ()
  {
    return this->screen_;
  }

  void HumanInterventionComponent::
  setScreen (const ScreenType& x)
  {
    this->screen_.set (x);
  }

  void HumanInterventionComponent::
  setScreen (const ScreenOptional& x)
  {
    this->screen_ = x;
  }

  void HumanInterventionComponent::
  setScreen (::std::unique_ptr< ScreenType > x)
  {
    this->screen_.set (std::move (x));
  }

  const HumanInterventionComponent::TreatSimpleOptional& HumanInterventionComponent::
  getTreatSimple () const
  {
    return this->treatSimple_;
  }

  HumanInterventionComponent::TreatSimpleOptional& HumanInterventionComponent::
  getTreatSimple ()
  {
    return this->treatSimple_;
  }

  void HumanInterventionComponent::
  setTreatSimple (const TreatSimpleType& x)
  {
    this->treatSimple_.set (x);
  }

  void HumanInterventionComponent::
  setTreatSimple (const TreatSimpleOptional& x)
  {
    this->treatSimple_ = x;
  }

  void HumanInterventionComponent::
  setTreatSimple (::std::unique_ptr< TreatSimpleType > x)
  {
    this->treatSimple_.set (std::move (x));
  }

  const HumanInterventionComponent::TreatPKPDOptional& HumanInterventionComponent::
  getTreatPKPD () const
  {
    return this->treatPKPD_;
  }

  HumanInterventionComponent::TreatPKPDOptional& HumanInterventionComponent::
  getTreatPKPD ()
  {
    return this->treatPKPD_;
  }

  void HumanInterventionComponent::
  setTreatPKPD (const TreatPKPDType& x)
  {
    this->treatPKPD_.set (x);
  }

  void HumanInterventionComponent::
  setTreatPKPD (const TreatPKPDOptional& x)
  {
    this->treatPKPD_ = x;
  }

  void HumanInterventionComponent::
  setTreatPKPD (::std::unique_ptr< TreatPKPDType > x)
  {
    this->treatPKPD_.set (std::move (x));
  }

  const HumanInterventionComponent::DecisionTreeOptional& HumanInterventionComponent::
  getDecisionTree () const
  {
    return this->decisionTree_;
  }

  HumanInterventionComponent::DecisionTreeOptional& HumanInterventionComponent::
  getDecisionTree ()
  {
    return this->decisionTree_;
  }

  void HumanInterventionComponent::
  setDecisionTree (const DecisionTreeType& x)
  {
    this->decisionTree_.set (x);
  }

  void HumanInterventionComponent::
  setDecisionTree (const DecisionTreeOptional& x)
  {
    this->decisionTree_ = x;
  }

  void HumanInterventionComponent::
  setDecisionTree (::std::unique_ptr< DecisionTreeType > x)
  {
    this->decisionTree_.set (std::move (x));
  }

  const HumanInterventionComponent::PEVOptional& HumanInterventionComponent::
  getPEV () const
  {
    return this->PEV_;
  }

  HumanInterventionComponent::PEVOptional& HumanInterventionComponent::
  getPEV ()
  {
    return this->PEV_;
  }

  void HumanInterventionComponent::
  setPEV (const PEVType& x)
  {
    this->PEV_.set (x);
  }

  void HumanInterventionComponent::
  setPEV (const PEVOptional& x)
  {
    this->PEV_ = x;
  }

  void HumanInterventionComponent::
  setPEV (::std::unique_ptr< PEVType > x)
  {
    this->PEV_.set (std::move (x));
  }

  const HumanInterventionComponent::BSVOptional& HumanInterventionComponent::
  getBSV () const
  {
    return this->BSV_;
  }

  HumanInterventionComponent::BSVOptional& HumanInterventionComponent::
  getBSV ()
  {
    return this->BSV_;
  }

  void HumanInterventionComponent::
  setBSV (const BSVType& x)
  {
    this->BSV_.set (x);
  }

  void HumanInterventionComponent::
  setBSV (const BSVOptional& x)
  {
    this->BSV_ = x;
  }

  void HumanInterventionComponent::
  setBSV (::std::unique_ptr< BSVType > x)
  {
    this->BSV_.set (std::move (x));
  }

  const HumanInterventionComponent::TBVOptional& HumanInterventionComponent::
  getTBV () const
  {
    return this->TBV_;
  }

  HumanInterventionComponent::TBVOptional& HumanInterventionComponent::
  getTBV ()
  {
    return this->TBV_;
  }

  void HumanInterventionComponent::
  setTBV (const TBVType& x)
  {
    this->TBV_.set (x);
  }

  void HumanInterventionComponent::
  setTBV (const TBVOptional& x)
  {
    this->TBV_ = x;
  }

  void HumanInterventionComponent::
  setTBV (::std::unique_ptr< TBVType > x)
  {
    this->TBV_.set (std::move (x));
  }

  const HumanInterventionComponent::ITNOptional& HumanInterventionComponent::
  getITN () const
  {
    return this->ITN_;
  }

  HumanInterventionComponent::ITNOptional& HumanInterventionComponent::
  getITN ()
  {
    return this->ITN_;
  }

  void HumanInterventionComponent::
  setITN (const ITNType& x)
  {
    this->ITN_.set (x);
  }

  void HumanInterventionComponent::
  setITN (const ITNOptional& x)
  {
    this->ITN_ = x;
  }

  void HumanInterventionComponent::
  setITN (::std::unique_ptr< ITNType > x)
  {
    this->ITN_.set (std::move (x));
  }

  const HumanInterventionComponent::IRSOptional& HumanInterventionComponent::
  getIRS () const
  {
    return this->IRS_;
  }

  HumanInterventionComponent::IRSOptional& HumanInterventionComponent::
  getIRS ()
  {
    return this->IRS_;
  }

  void HumanInterventionComponent::
  setIRS (const IRSType& x)
  {
    this->IRS_.set (x);
  }

  void HumanInterventionComponent::
  setIRS (const IRSOptional& x)
  {
    this->IRS_ = x;
  }

  void HumanInterventionComponent::
  setIRS (::std::unique_ptr< IRSType > x)
  {
    this->IRS_.set (std::move (x));
  }

  const HumanInterventionComponent::GVIOptional& HumanInterventionComponent::
  getGVI () const
  {
    return this->GVI_;
  }

  HumanInterventionComponent::GVIOptional& HumanInterventionComponent::
  getGVI ()
  {
    return this->GVI_;
  }

  void HumanInterventionComponent::
  setGVI (const GVIType& x)
  {
    this->GVI_.set (x);
  }

  void HumanInterventionComponent::
  setGVI (const GVIOptional& x)
  {
    this->GVI_ = x;
  }

  void HumanInterventionComponent::
  setGVI (::std::unique_ptr< GVIType > x)
  {
    this->GVI_.set (std::move (x));
  }

  const HumanInterventionComponent::RecruitmentOnlyOptional& HumanInterventionComponent::
  getRecruitmentOnly () const
  {
    return this->recruitmentOnly_;
  }

  HumanInterventionComponent::RecruitmentOnlyOptional& HumanInterventionComponent::
  getRecruitmentOnly ()
  {
    return this->recruitmentOnly_;
  }

  void HumanInterventionComponent::
  setRecruitmentOnly (const RecruitmentOnlyType& x)
  {
    this->recruitmentOnly_.set (x);
  }

  void HumanInterventionComponent::
  setRecruitmentOnly (const RecruitmentOnlyOptional& x)
  {
    this->recruitmentOnly_ = x;
  }

  void HumanInterventionComponent::
  setRecruitmentOnly (::std::unique_ptr< RecruitmentOnlyType > x)
  {
    this->recruitmentOnly_.set (std::move (x));
  }

  const HumanInterventionComponent::ClearImmunityOptional& HumanInterventionComponent::
  getClearImmunity () const
  {
    return this->clearImmunity_;
  }

  HumanInterventionComponent::ClearImmunityOptional& HumanInterventionComponent::
  getClearImmunity ()
  {
    return this->clearImmunity_;
  }

  void HumanInterventionComponent::
  setClearImmunity (const ClearImmunityType& x)
  {
    this->clearImmunity_.set (x);
  }

  void HumanInterventionComponent::
  setClearImmunity (const ClearImmunityOptional& x)
  {
    this->clearImmunity_ = x;
  }

  void HumanInterventionComponent::
  setClearImmunity (::std::unique_ptr< ClearImmunityType > x)
  {
    this->clearImmunity_.set (std::move (x));
  }

  const HumanInterventionComponent::SubPopRemovalOptional& HumanInterventionComponent::
  getSubPopRemoval () const
  {
    return this->subPopRemoval_;
  }

  HumanInterventionComponent::SubPopRemovalOptional& HumanInterventionComponent::
  getSubPopRemoval ()
  {
    return this->subPopRemoval_;
  }

  void HumanInterventionComponent::
  setSubPopRemoval (const SubPopRemovalType& x)
  {
    this->subPopRemoval_.set (x);
  }

  void HumanInterventionComponent::
  setSubPopRemoval (const SubPopRemovalOptional& x)
  {
    this->subPopRemoval_ = x;
  }

  void HumanInterventionComponent::
  setSubPopRemoval (::std::unique_ptr< SubPopRemovalType > x)
  {
    this->subPopRemoval_.set (std::move (x));
  }

  const HumanInterventionComponent::IdType& HumanInterventionComponent::
  getId () const
  {
    return this->id_.get ();
  }

  HumanInterventionComponent::IdType& HumanInterventionComponent::
  getId ()
  {
    return this->id_.get ();
  }

  void HumanInterventionComponent::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void HumanInterventionComponent::
  setId (::std::unique_ptr< IdType > x)
  {
    this->id_.set (std::move (x));
  }

  const HumanInterventionComponent::NameOptional& HumanInterventionComponent::
  getName () const
  {
    return this->name_;
  }

  HumanInterventionComponent::NameOptional& HumanInterventionComponent::
  getName ()
  {
    return this->name_;
  }

  void HumanInterventionComponent::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void HumanInterventionComponent::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void HumanInterventionComponent::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // SubPopRemoval
  // 

  const SubPopRemoval::OnFirstBoutType& SubPopRemoval::
  getOnFirstBout () const
  {
    return this->onFirstBout_.get ();
  }

  SubPopRemoval::OnFirstBoutType& SubPopRemoval::
  getOnFirstBout ()
  {
    return this->onFirstBout_.get ();
  }

  void SubPopRemoval::
  setOnFirstBout (const OnFirstBoutType& x)
  {
    this->onFirstBout_.set (x);
  }

  SubPopRemoval::OnFirstBoutType SubPopRemoval::
  getOnFirstBoutDefaultValue ()
  {
    return OnFirstBoutType (false);
  }

  const SubPopRemoval::OnFirstTreatmentType& SubPopRemoval::
  getOnFirstTreatment () const
  {
    return this->onFirstTreatment_.get ();
  }

  SubPopRemoval::OnFirstTreatmentType& SubPopRemoval::
  getOnFirstTreatment ()
  {
    return this->onFirstTreatment_.get ();
  }

  void SubPopRemoval::
  setOnFirstTreatment (const OnFirstTreatmentType& x)
  {
    this->onFirstTreatment_.set (x);
  }

  SubPopRemoval::OnFirstTreatmentType SubPopRemoval::
  getOnFirstTreatmentDefaultValue ()
  {
    return OnFirstTreatmentType (false);
  }

  const SubPopRemoval::OnFirstInfectionType& SubPopRemoval::
  getOnFirstInfection () const
  {
    return this->onFirstInfection_.get ();
  }

  SubPopRemoval::OnFirstInfectionType& SubPopRemoval::
  getOnFirstInfection ()
  {
    return this->onFirstInfection_.get ();
  }

  void SubPopRemoval::
  setOnFirstInfection (const OnFirstInfectionType& x)
  {
    this->onFirstInfection_.set (x);
  }

  SubPopRemoval::OnFirstInfectionType SubPopRemoval::
  getOnFirstInfectionDefaultValue ()
  {
    return OnFirstInfectionType (false);
  }

  const SubPopRemoval::AfterYearsOptional& SubPopRemoval::
  getAfterYears () const
  {
    return this->afterYears_;
  }

  SubPopRemoval::AfterYearsOptional& SubPopRemoval::
  getAfterYears ()
  {
    return this->afterYears_;
  }

  void SubPopRemoval::
  setAfterYears (const AfterYearsType& x)
  {
    this->afterYears_.set (x);
  }

  void SubPopRemoval::
  setAfterYears (const AfterYearsOptional& x)
  {
    this->afterYears_ = x;
  }


  // Screen
  // 

  const Screen::PositiveSequence& Screen::
  getPositive () const
  {
    return this->positive_;
  }

  Screen::PositiveSequence& Screen::
  getPositive ()
  {
    return this->positive_;
  }

  void Screen::
  setPositive (const PositiveSequence& s)
  {
    this->positive_ = s;
  }

  const Screen::NegativeSequence& Screen::
  getNegative () const
  {
    return this->negative_;
  }

  Screen::NegativeSequence& Screen::
  getNegative ()
  {
    return this->negative_;
  }

  void Screen::
  setNegative (const NegativeSequence& s)
  {
    this->negative_ = s;
  }

  const Screen::DiagnosticType& Screen::
  getDiagnostic () const
  {
    return this->diagnostic_.get ();
  }

  Screen::DiagnosticType& Screen::
  getDiagnostic ()
  {
    return this->diagnostic_.get ();
  }

  void Screen::
  setDiagnostic (const DiagnosticType& x)
  {
    this->diagnostic_.set (x);
  }

  void Screen::
  setDiagnostic (::std::unique_ptr< DiagnosticType > x)
  {
    this->diagnostic_.set (std::move (x));
  }


  // VectorIntervention
  // 

  const VectorIntervention::DescriptionType& VectorIntervention::
  getDescription () const
  {
    return this->description_.get ();
  }

  VectorIntervention::DescriptionType& VectorIntervention::
  getDescription ()
  {
    return this->description_.get ();
  }

  void VectorIntervention::
  setDescription (const DescriptionType& x)
  {
    this->description_.set (x);
  }

  void VectorIntervention::
  setDescription (::std::unique_ptr< DescriptionType > x)
  {
    this->description_.set (std::move (x));
  }

  const VectorIntervention::TimedOptional& VectorIntervention::
  getTimed () const
  {
    return this->timed_;
  }

  VectorIntervention::TimedOptional& VectorIntervention::
  getTimed ()
  {
    return this->timed_;
  }

  void VectorIntervention::
  setTimed (const TimedType& x)
  {
    this->timed_.set (x);
  }

  void VectorIntervention::
  setTimed (const TimedOptional& x)
  {
    this->timed_ = x;
  }

  void VectorIntervention::
  setTimed (::std::unique_ptr< TimedType > x)
  {
    this->timed_.set (std::move (x));
  }

  const VectorIntervention::NameType& VectorIntervention::
  getName () const
  {
    return this->name_.get ();
  }

  VectorIntervention::NameType& VectorIntervention::
  getName ()
  {
    return this->name_.get ();
  }

  void VectorIntervention::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void VectorIntervention::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // VectorTrap
  // 

  const VectorTrap::DescriptionSequence& VectorTrap::
  getDescription () const
  {
    return this->description_;
  }

  VectorTrap::DescriptionSequence& VectorTrap::
  getDescription ()
  {
    return this->description_;
  }

  void VectorTrap::
  setDescription (const DescriptionSequence& s)
  {
    this->description_ = s;
  }

  const VectorTrap::TimedOptional& VectorTrap::
  getTimed () const
  {
    return this->timed_;
  }

  VectorTrap::TimedOptional& VectorTrap::
  getTimed ()
  {
    return this->timed_;
  }

  void VectorTrap::
  setTimed (const TimedType& x)
  {
    this->timed_.set (x);
  }

  void VectorTrap::
  setTimed (const TimedOptional& x)
  {
    this->timed_ = x;
  }

  void VectorTrap::
  setTimed (::std::unique_ptr< TimedType > x)
  {
    this->timed_.set (std::move (x));
  }

  const VectorTrap::NameOptional& VectorTrap::
  getName () const
  {
    return this->name_;
  }

  VectorTrap::NameOptional& VectorTrap::
  getName ()
  {
    return this->name_;
  }

  void VectorTrap::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void VectorTrap::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void VectorTrap::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // TimedBase
  // 

  const TimedBase::TimeType& TimedBase::
  getTime () const
  {
    return this->time_.get ();
  }

  TimedBase::TimeType& TimedBase::
  getTime ()
  {
    return this->time_.get ();
  }

  void TimedBase::
  setTime (const TimeType& x)
  {
    this->time_.set (x);
  }

  void TimedBase::
  setTime (::std::unique_ptr< TimeType > x)
  {
    this->time_.set (std::move (x));
  }


  // DeploymentBase
  // 

  const DeploymentBase::CoverageType& DeploymentBase::
  getCoverage () const
  {
    return this->coverage_.get ();
  }

  DeploymentBase::CoverageType& DeploymentBase::
  getCoverage ()
  {
    return this->coverage_.get ();
  }

  void DeploymentBase::
  setCoverage (const CoverageType& x)
  {
    this->coverage_.set (x);
  }

  const DeploymentBase::VaccMinPrevDosesOptional& DeploymentBase::
  getVaccMinPrevDoses () const
  {
    return this->vaccMinPrevDoses_;
  }

  DeploymentBase::VaccMinPrevDosesOptional& DeploymentBase::
  getVaccMinPrevDoses ()
  {
    return this->vaccMinPrevDoses_;
  }

  void DeploymentBase::
  setVaccMinPrevDoses (const VaccMinPrevDosesType& x)
  {
    this->vaccMinPrevDoses_.set (x);
  }

  void DeploymentBase::
  setVaccMinPrevDoses (const VaccMinPrevDosesOptional& x)
  {
    this->vaccMinPrevDoses_ = x;
  }

  const DeploymentBase::VaccMaxCumDosesOptional& DeploymentBase::
  getVaccMaxCumDoses () const
  {
    return this->vaccMaxCumDoses_;
  }

  DeploymentBase::VaccMaxCumDosesOptional& DeploymentBase::
  getVaccMaxCumDoses ()
  {
    return this->vaccMaxCumDoses_;
  }

  void DeploymentBase::
  setVaccMaxCumDoses (const VaccMaxCumDosesType& x)
  {
    this->vaccMaxCumDoses_.set (x);
  }

  void DeploymentBase::
  setVaccMaxCumDoses (const VaccMaxCumDosesOptional& x)
  {
    this->vaccMaxCumDoses_ = x;
  }


  // MassDeployment
  // 

  const MassDeployment::TimeType& MassDeployment::
  getTime () const
  {
    return this->time_.get ();
  }

  MassDeployment::TimeType& MassDeployment::
  getTime ()
  {
    return this->time_.get ();
  }

  void MassDeployment::
  setTime (const TimeType& x)
  {
    this->time_.set (x);
  }

  void MassDeployment::
  setTime (::std::unique_ptr< TimeType > x)
  {
    this->time_.set (std::move (x));
  }

  const MassDeployment::MaxAgeOptional& MassDeployment::
  getMaxAge () const
  {
    return this->maxAge_;
  }

  MassDeployment::MaxAgeOptional& MassDeployment::
  getMaxAge ()
  {
    return this->maxAge_;
  }

  void MassDeployment::
  setMaxAge (const MaxAgeType& x)
  {
    this->maxAge_.set (x);
  }

  void MassDeployment::
  setMaxAge (const MaxAgeOptional& x)
  {
    this->maxAge_ = x;
  }

  const MassDeployment::MinAgeType& MassDeployment::
  getMinAge () const
  {
    return this->minAge_.get ();
  }

  MassDeployment::MinAgeType& MassDeployment::
  getMinAge ()
  {
    return this->minAge_.get ();
  }

  void MassDeployment::
  setMinAge (const MinAgeType& x)
  {
    this->minAge_.set (x);
  }

  MassDeployment::MinAgeType MassDeployment::
  getMinAgeDefaultValue ()
  {
    return MinAgeType (0.0);
  }

  const MassDeployment::RepeatStepOptional& MassDeployment::
  getRepeatStep () const
  {
    return this->repeatStep_;
  }

  MassDeployment::RepeatStepOptional& MassDeployment::
  getRepeatStep ()
  {
    return this->repeatStep_;
  }

  void MassDeployment::
  setRepeatStep (const RepeatStepType& x)
  {
    this->repeatStep_.set (x);
  }

  void MassDeployment::
  setRepeatStep (const RepeatStepOptional& x)
  {
    this->repeatStep_ = x;
  }

  void MassDeployment::
  setRepeatStep (::std::unique_ptr< RepeatStepType > x)
  {
    this->repeatStep_.set (std::move (x));
  }

  const MassDeployment::RepeatEndOptional& MassDeployment::
  getRepeatEnd () const
  {
    return this->repeatEnd_;
  }

  MassDeployment::RepeatEndOptional& MassDeployment::
  getRepeatEnd ()
  {
    return this->repeatEnd_;
  }

  void MassDeployment::
  setRepeatEnd (const RepeatEndType& x)
  {
    this->repeatEnd_.set (x);
  }

  void MassDeployment::
  setRepeatEnd (const RepeatEndOptional& x)
  {
    this->repeatEnd_ = x;
  }

  void MassDeployment::
  setRepeatEnd (::std::unique_ptr< RepeatEndType > x)
  {
    this->repeatEnd_.set (std::move (x));
  }


  // ContinuousList
  // 

  const ContinuousList::RestrictToSubPopOptional& ContinuousList::
  getRestrictToSubPop () const
  {
    return this->restrictToSubPop_;
  }

  ContinuousList::RestrictToSubPopOptional& ContinuousList::
  getRestrictToSubPop ()
  {
    return this->restrictToSubPop_;
  }

  void ContinuousList::
  setRestrictToSubPop (const RestrictToSubPopType& x)
  {
    this->restrictToSubPop_.set (x);
  }

  void ContinuousList::
  setRestrictToSubPop (const RestrictToSubPopOptional& x)
  {
    this->restrictToSubPop_ = x;
  }

  void ContinuousList::
  setRestrictToSubPop (::std::unique_ptr< RestrictToSubPopType > x)
  {
    this->restrictToSubPop_.set (std::move (x));
  }

  const ContinuousList::DeploySequence& ContinuousList::
  getDeploy () const
  {
    return this->deploy_;
  }

  ContinuousList::DeploySequence& ContinuousList::
  getDeploy ()
  {
    return this->deploy_;
  }

  void ContinuousList::
  setDeploy (const DeploySequence& s)
  {
    this->deploy_ = s;
  }


  // ContinuousDeployment
  // 

  const ContinuousDeployment::TargetAgeYrsType& ContinuousDeployment::
  getTargetAgeYrs () const
  {
    return this->targetAgeYrs_.get ();
  }

  ContinuousDeployment::TargetAgeYrsType& ContinuousDeployment::
  getTargetAgeYrs ()
  {
    return this->targetAgeYrs_.get ();
  }

  void ContinuousDeployment::
  setTargetAgeYrs (const TargetAgeYrsType& x)
  {
    this->targetAgeYrs_.set (x);
  }

  const ContinuousDeployment::BeginOptional& ContinuousDeployment::
  getBegin () const
  {
    return this->begin_;
  }

  ContinuousDeployment::BeginOptional& ContinuousDeployment::
  getBegin ()
  {
    return this->begin_;
  }

  void ContinuousDeployment::
  setBegin (const BeginType& x)
  {
    this->begin_.set (x);
  }

  void ContinuousDeployment::
  setBegin (const BeginOptional& x)
  {
    this->begin_ = x;
  }

  void ContinuousDeployment::
  setBegin (::std::unique_ptr< BeginType > x)
  {
    this->begin_.set (std::move (x));
  }

  const ContinuousDeployment::EndOptional& ContinuousDeployment::
  getEnd () const
  {
    return this->end_;
  }

  ContinuousDeployment::EndOptional& ContinuousDeployment::
  getEnd ()
  {
    return this->end_;
  }

  void ContinuousDeployment::
  setEnd (const EndType& x)
  {
    this->end_.set (x);
  }

  void ContinuousDeployment::
  setEnd (const EndOptional& x)
  {
    this->end_ = x;
  }

  void ContinuousDeployment::
  setEnd (::std::unique_ptr< EndType > x)
  {
    this->end_.set (std::move (x));
  }


  // TimedBaseList
  // 

  const TimedBaseList::DeploySequence& TimedBaseList::
  getDeploy () const
  {
    return this->deploy_;
  }

  TimedBaseList::DeploySequence& TimedBaseList::
  getDeploy ()
  {
    return this->deploy_;
  }

  void TimedBaseList::
  setDeploy (const DeploySequence& s)
  {
    this->deploy_ = s;
  }


  // MassListWithCum
  // 

  const MassListWithCum::RestrictToSubPopOptional& MassListWithCum::
  getRestrictToSubPop () const
  {
    return this->restrictToSubPop_;
  }

  MassListWithCum::RestrictToSubPopOptional& MassListWithCum::
  getRestrictToSubPop ()
  {
    return this->restrictToSubPop_;
  }

  void MassListWithCum::
  setRestrictToSubPop (const RestrictToSubPopType& x)
  {
    this->restrictToSubPop_.set (x);
  }

  void MassListWithCum::
  setRestrictToSubPop (const RestrictToSubPopOptional& x)
  {
    this->restrictToSubPop_ = x;
  }

  void MassListWithCum::
  setRestrictToSubPop (::std::unique_ptr< RestrictToSubPopType > x)
  {
    this->restrictToSubPop_.set (std::move (x));
  }

  const MassListWithCum::CumulativeCoverageOptional& MassListWithCum::
  getCumulativeCoverage () const
  {
    return this->cumulativeCoverage_;
  }

  MassListWithCum::CumulativeCoverageOptional& MassListWithCum::
  getCumulativeCoverage ()
  {
    return this->cumulativeCoverage_;
  }

  void MassListWithCum::
  setCumulativeCoverage (const CumulativeCoverageType& x)
  {
    this->cumulativeCoverage_.set (x);
  }

  void MassListWithCum::
  setCumulativeCoverage (const CumulativeCoverageOptional& x)
  {
    this->cumulativeCoverage_ = x;
  }

  void MassListWithCum::
  setCumulativeCoverage (::std::unique_ptr< CumulativeCoverageType > x)
  {
    this->cumulativeCoverage_.set (std::move (x));
  }

  const MassListWithCum::DeploySequence& MassListWithCum::
  getDeploy () const
  {
    return this->deploy_;
  }

  MassListWithCum::DeploySequence& MassListWithCum::
  getDeploy ()
  {
    return this->deploy_;
  }

  void MassListWithCum::
  setDeploy (const DeploySequence& s)
  {
    this->deploy_ = s;
  }


  // RestrictToSubPop
  // 

  const RestrictToSubPop::IdType& RestrictToSubPop::
  getId () const
  {
    return this->id_.get ();
  }

  RestrictToSubPop::IdType& RestrictToSubPop::
  getId ()
  {
    return this->id_.get ();
  }

  void RestrictToSubPop::
  setId (const IdType& x)
  {
    this->id_.set (x);
  }

  void RestrictToSubPop::
  setId (::std::unique_ptr< IdType > x)
  {
    this->id_.set (std::move (x));
  }

  const RestrictToSubPop::ComplementType& RestrictToSubPop::
  getComplement () const
  {
    return this->complement_.get ();
  }

  RestrictToSubPop::ComplementType& RestrictToSubPop::
  getComplement ()
  {
    return this->complement_.get ();
  }

  void RestrictToSubPop::
  setComplement (const ComplementType& x)
  {
    this->complement_.set (x);
  }

  RestrictToSubPop::ComplementType RestrictToSubPop::
  getComplementDefaultValue ()
  {
    return ComplementType (false);
  }


  // VaccineDescription
  // 

  const VaccineDescription::DecayType& VaccineDescription::
  getDecay () const
  {
    return this->decay_.get ();
  }

  VaccineDescription::DecayType& VaccineDescription::
  getDecay ()
  {
    return this->decay_.get ();
  }

  void VaccineDescription::
  setDecay (const DecayType& x)
  {
    this->decay_.set (x);
  }

  void VaccineDescription::
  setDecay (::std::unique_ptr< DecayType > x)
  {
    this->decay_.set (std::move (x));
  }

  const VaccineDescription::EfficacyBType& VaccineDescription::
  getEfficacyB () const
  {
    return this->efficacyB_.get ();
  }

  VaccineDescription::EfficacyBType& VaccineDescription::
  getEfficacyB ()
  {
    return this->efficacyB_.get ();
  }

  void VaccineDescription::
  setEfficacyB (const EfficacyBType& x)
  {
    this->efficacyB_.set (x);
  }

  void VaccineDescription::
  setEfficacyB (::std::unique_ptr< EfficacyBType > x)
  {
    this->efficacyB_.set (std::move (x));
  }

  const VaccineDescription::InitialEfficacySequence& VaccineDescription::
  getInitialEfficacy () const
  {
    return this->initialEfficacy_;
  }

  VaccineDescription::InitialEfficacySequence& VaccineDescription::
  getInitialEfficacy ()
  {
    return this->initialEfficacy_;
  }

  void VaccineDescription::
  setInitialEfficacy (const InitialEfficacySequence& s)
  {
    this->initialEfficacy_ = s;
  }


  // ITNDescription
  // 

  const ITNDescription::UsageOptional& ITNDescription::
  getUsage () const
  {
    return this->usage_;
  }

  ITNDescription::UsageOptional& ITNDescription::
  getUsage ()
  {
    return this->usage_;
  }

  void ITNDescription::
  setUsage (const UsageType& x)
  {
    this->usage_.set (x);
  }

  void ITNDescription::
  setUsage (const UsageOptional& x)
  {
    this->usage_ = x;
  }

  void ITNDescription::
  setUsage (::std::unique_ptr< UsageType > x)
  {
    this->usage_.set (std::move (x));
  }

  const ITNDescription::HoleRateType& ITNDescription::
  getHoleRate () const
  {
    return this->holeRate_.get ();
  }

  ITNDescription::HoleRateType& ITNDescription::
  getHoleRate ()
  {
    return this->holeRate_.get ();
  }

  void ITNDescription::
  setHoleRate (const HoleRateType& x)
  {
    this->holeRate_.set (x);
  }

  void ITNDescription::
  setHoleRate (::std::unique_ptr< HoleRateType > x)
  {
    this->holeRate_.set (std::move (x));
  }

  const ITNDescription::RipRateType& ITNDescription::
  getRipRate () const
  {
    return this->ripRate_.get ();
  }

  ITNDescription::RipRateType& ITNDescription::
  getRipRate ()
  {
    return this->ripRate_.get ();
  }

  void ITNDescription::
  setRipRate (const RipRateType& x)
  {
    this->ripRate_.set (x);
  }

  void ITNDescription::
  setRipRate (::std::unique_ptr< RipRateType > x)
  {
    this->ripRate_.set (std::move (x));
  }

  const ITNDescription::RipFactorType& ITNDescription::
  getRipFactor () const
  {
    return this->ripFactor_.get ();
  }

  ITNDescription::RipFactorType& ITNDescription::
  getRipFactor ()
  {
    return this->ripFactor_.get ();
  }

  void ITNDescription::
  setRipFactor (const RipFactorType& x)
  {
    this->ripFactor_.set (x);
  }

  void ITNDescription::
  setRipFactor (::std::unique_ptr< RipFactorType > x)
  {
    this->ripFactor_.set (std::move (x));
  }

  const ITNDescription::InitialInsecticideType& ITNDescription::
  getInitialInsecticide () const
  {
    return this->initialInsecticide_.get ();
  }

  ITNDescription::InitialInsecticideType& ITNDescription::
  getInitialInsecticide ()
  {
    return this->initialInsecticide_.get ();
  }

  void ITNDescription::
  setInitialInsecticide (const InitialInsecticideType& x)
  {
    this->initialInsecticide_.set (x);
  }

  void ITNDescription::
  setInitialInsecticide (::std::unique_ptr< InitialInsecticideType > x)
  {
    this->initialInsecticide_.set (std::move (x));
  }

  const ITNDescription::InsecticideDecayType& ITNDescription::
  getInsecticideDecay () const
  {
    return this->insecticideDecay_.get ();
  }

  ITNDescription::InsecticideDecayType& ITNDescription::
  getInsecticideDecay ()
  {
    return this->insecticideDecay_.get ();
  }

  void ITNDescription::
  setInsecticideDecay (const InsecticideDecayType& x)
  {
    this->insecticideDecay_.set (x);
  }

  void ITNDescription::
  setInsecticideDecay (::std::unique_ptr< InsecticideDecayType > x)
  {
    this->insecticideDecay_.set (std::move (x));
  }

  const ITNDescription::AttritionOfNetsType& ITNDescription::
  getAttritionOfNets () const
  {
    return this->attritionOfNets_.get ();
  }

  ITNDescription::AttritionOfNetsType& ITNDescription::
  getAttritionOfNets ()
  {
    return this->attritionOfNets_.get ();
  }

  void ITNDescription::
  setAttritionOfNets (const AttritionOfNetsType& x)
  {
    this->attritionOfNets_.set (x);
  }

  void ITNDescription::
  setAttritionOfNets (::std::unique_ptr< AttritionOfNetsType > x)
  {
    this->attritionOfNets_.set (std::move (x));
  }

  const ITNDescription::AnophelesParamsSequence& ITNDescription::
  getAnophelesParams () const
  {
    return this->anophelesParams_;
  }

  ITNDescription::AnophelesParamsSequence& ITNDescription::
  getAnophelesParams ()
  {
    return this->anophelesParams_;
  }

  void ITNDescription::
  setAnophelesParams (const AnophelesParamsSequence& s)
  {
    this->anophelesParams_ = s;
  }


  // GVIDescription
  // 

  const GVIDescription::UsageOptional& GVIDescription::
  getUsage () const
  {
    return this->usage_;
  }

  GVIDescription::UsageOptional& GVIDescription::
  getUsage ()
  {
    return this->usage_;
  }

  void GVIDescription::
  setUsage (const UsageType& x)
  {
    this->usage_.set (x);
  }

  void GVIDescription::
  setUsage (const UsageOptional& x)
  {
    this->usage_ = x;
  }

  void GVIDescription::
  setUsage (::std::unique_ptr< UsageType > x)
  {
    this->usage_.set (std::move (x));
  }

  const GVIDescription::DecayType& GVIDescription::
  getDecay () const
  {
    return this->decay_.get ();
  }

  GVIDescription::DecayType& GVIDescription::
  getDecay ()
  {
    return this->decay_.get ();
  }

  void GVIDescription::
  setDecay (const DecayType& x)
  {
    this->decay_.set (x);
  }

  void GVIDescription::
  setDecay (::std::unique_ptr< DecayType > x)
  {
    this->decay_.set (std::move (x));
  }

  const GVIDescription::AnophelesParamsSequence& GVIDescription::
  getAnophelesParams () const
  {
    return this->anophelesParams_;
  }

  GVIDescription::AnophelesParamsSequence& GVIDescription::
  getAnophelesParams ()
  {
    return this->anophelesParams_;
  }

  void GVIDescription::
  setAnophelesParams (const AnophelesParamsSequence& s)
  {
    this->anophelesParams_ = s;
  }


  // IRSDescription
  // 

  const IRSDescription::UsageOptional& IRSDescription::
  getUsage () const
  {
    return this->usage_;
  }

  IRSDescription::UsageOptional& IRSDescription::
  getUsage ()
  {
    return this->usage_;
  }

  void IRSDescription::
  setUsage (const UsageType& x)
  {
    this->usage_.set (x);
  }

  void IRSDescription::
  setUsage (const UsageOptional& x)
  {
    this->usage_ = x;
  }

  void IRSDescription::
  setUsage (::std::unique_ptr< UsageType > x)
  {
    this->usage_.set (std::move (x));
  }

  const IRSDescription::InitialInsecticideType& IRSDescription::
  getInitialInsecticide () const
  {
    return this->initialInsecticide_.get ();
  }

  IRSDescription::InitialInsecticideType& IRSDescription::
  getInitialInsecticide ()
  {
    return this->initialInsecticide_.get ();
  }

  void IRSDescription::
  setInitialInsecticide (const InitialInsecticideType& x)
  {
    this->initialInsecticide_.set (x);
  }

  void IRSDescription::
  setInitialInsecticide (::std::unique_ptr< InitialInsecticideType > x)
  {
    this->initialInsecticide_.set (std::move (x));
  }

  const IRSDescription::InsecticideDecayType& IRSDescription::
  getInsecticideDecay () const
  {
    return this->insecticideDecay_.get ();
  }

  IRSDescription::InsecticideDecayType& IRSDescription::
  getInsecticideDecay ()
  {
    return this->insecticideDecay_.get ();
  }

  void IRSDescription::
  setInsecticideDecay (const InsecticideDecayType& x)
  {
    this->insecticideDecay_.set (x);
  }

  void IRSDescription::
  setInsecticideDecay (::std::unique_ptr< InsecticideDecayType > x)
  {
    this->insecticideDecay_.set (std::move (x));
  }

  const IRSDescription::AnophelesParamsSequence& IRSDescription::
  getAnophelesParams () const
  {
    return this->anophelesParams_;
  }

  IRSDescription::AnophelesParamsSequence& IRSDescription::
  getAnophelesParams ()
  {
    return this->anophelesParams_;
  }

  void IRSDescription::
  setAnophelesParams (const AnophelesParamsSequence& s)
  {
    this->anophelesParams_ = s;
  }


  // IRSDeterrency
  // 

  const IRSDeterrency::InsecticideFactorType& IRSDeterrency::
  getInsecticideFactor () const
  {
    return this->insecticideFactor_.get ();
  }

  IRSDeterrency::InsecticideFactorType& IRSDeterrency::
  getInsecticideFactor ()
  {
    return this->insecticideFactor_.get ();
  }

  void IRSDeterrency::
  setInsecticideFactor (const InsecticideFactorType& x)
  {
    this->insecticideFactor_.set (x);
  }

  const IRSDeterrency::InsecticideScalingFactorType& IRSDeterrency::
  getInsecticideScalingFactor () const
  {
    return this->insecticideScalingFactor_.get ();
  }

  IRSDeterrency::InsecticideScalingFactorType& IRSDeterrency::
  getInsecticideScalingFactor ()
  {
    return this->insecticideScalingFactor_.get ();
  }

  void IRSDeterrency::
  setInsecticideScalingFactor (const InsecticideScalingFactorType& x)
  {
    this->insecticideScalingFactor_.set (x);
  }


  // ITNEnteringDeterrencyLogit
  // 

  const ITNEnteringDeterrencyLogit::BaseFactorType& ITNEnteringDeterrencyLogit::
  getBaseFactor () const
  {
    return this->baseFactor_.get ();
  }

  ITNEnteringDeterrencyLogit::BaseFactorType& ITNEnteringDeterrencyLogit::
  getBaseFactor ()
  {
    return this->baseFactor_.get ();
  }

  void ITNEnteringDeterrencyLogit::
  setBaseFactor (const BaseFactorType& x)
  {
    this->baseFactor_.set (x);
  }

  const ITNEnteringDeterrencyLogit::InsecticideFactorType& ITNEnteringDeterrencyLogit::
  getInsecticideFactor () const
  {
    return this->insecticideFactor_.get ();
  }

  ITNEnteringDeterrencyLogit::InsecticideFactorType& ITNEnteringDeterrencyLogit::
  getInsecticideFactor ()
  {
    return this->insecticideFactor_.get ();
  }

  void ITNEnteringDeterrencyLogit::
  setInsecticideFactor (const InsecticideFactorType& x)
  {
    this->insecticideFactor_.set (x);
  }


  // IRSKillingEffect
  // 

  const IRSKillingEffect::BaseFactorType& IRSKillingEffect::
  getBaseFactor () const
  {
    return this->baseFactor_.get ();
  }

  IRSKillingEffect::BaseFactorType& IRSKillingEffect::
  getBaseFactor ()
  {
    return this->baseFactor_.get ();
  }

  void IRSKillingEffect::
  setBaseFactor (const BaseFactorType& x)
  {
    this->baseFactor_.set (x);
  }


  // ITNDeterrency
  // 

  const ITNDeterrency::HoleFactorType& ITNDeterrency::
  getHoleFactor () const
  {
    return this->holeFactor_.get ();
  }

  ITNDeterrency::HoleFactorType& ITNDeterrency::
  getHoleFactor ()
  {
    return this->holeFactor_.get ();
  }

  void ITNDeterrency::
  setHoleFactor (const HoleFactorType& x)
  {
    this->holeFactor_.set (x);
  }

  const ITNDeterrency::InteractionFactorType& ITNDeterrency::
  getInteractionFactor () const
  {
    return this->interactionFactor_.get ();
  }

  ITNDeterrency::InteractionFactorType& ITNDeterrency::
  getInteractionFactor ()
  {
    return this->interactionFactor_.get ();
  }

  void ITNDeterrency::
  setInteractionFactor (const InteractionFactorType& x)
  {
    this->interactionFactor_.set (x);
  }

  const ITNDeterrency::HoleScalingFactorType& ITNDeterrency::
  getHoleScalingFactor () const
  {
    return this->holeScalingFactor_.get ();
  }

  ITNDeterrency::HoleScalingFactorType& ITNDeterrency::
  getHoleScalingFactor ()
  {
    return this->holeScalingFactor_.get ();
  }

  void ITNDeterrency::
  setHoleScalingFactor (const HoleScalingFactorType& x)
  {
    this->holeScalingFactor_.set (x);
  }


  // ITNKillingEffect
  // 

  const ITNKillingEffect::BaseFactorType& ITNKillingEffect::
  getBaseFactor () const
  {
    return this->baseFactor_.get ();
  }

  ITNKillingEffect::BaseFactorType& ITNKillingEffect::
  getBaseFactor ()
  {
    return this->baseFactor_.get ();
  }

  void ITNKillingEffect::
  setBaseFactor (const BaseFactorType& x)
  {
    this->baseFactor_.set (x);
  }


  // ITNEffectLogit
  // 

  const ITNEffectLogit::BaseFactorType& ITNEffectLogit::
  getBaseFactor () const
  {
    return this->baseFactor_.get ();
  }

  ITNEffectLogit::BaseFactorType& ITNEffectLogit::
  getBaseFactor ()
  {
    return this->baseFactor_.get ();
  }

  void ITNEffectLogit::
  setBaseFactor (const BaseFactorType& x)
  {
    this->baseFactor_.set (x);
  }

  const ITNEffectLogit::InsecticideFactorType& ITNEffectLogit::
  getInsecticideFactor () const
  {
    return this->insecticideFactor_.get ();
  }

  ITNEffectLogit::InsecticideFactorType& ITNEffectLogit::
  getInsecticideFactor ()
  {
    return this->insecticideFactor_.get ();
  }

  void ITNEffectLogit::
  setInsecticideFactor (const InsecticideFactorType& x)
  {
    this->insecticideFactor_.set (x);
  }

  const ITNEffectLogit::HoleFactorType& ITNEffectLogit::
  getHoleFactor () const
  {
    return this->holeFactor_.get ();
  }

  ITNEffectLogit::HoleFactorType& ITNEffectLogit::
  getHoleFactor ()
  {
    return this->holeFactor_.get ();
  }

  void ITNEffectLogit::
  setHoleFactor (const HoleFactorType& x)
  {
    this->holeFactor_.set (x);
  }

  const ITNEffectLogit::InteractionFactorType& ITNEffectLogit::
  getInteractionFactor () const
  {
    return this->interactionFactor_.get ();
  }

  ITNEffectLogit::InteractionFactorType& ITNEffectLogit::
  getInteractionFactor ()
  {
    return this->interactionFactor_.get ();
  }

  void ITNEffectLogit::
  setInteractionFactor (const InteractionFactorType& x)
  {
    this->interactionFactor_.set (x);
  }


  // VectorSpeciesIntervention
  // 

  const VectorSpeciesIntervention::SeekingDeathRateIncreaseOptional& VectorSpeciesIntervention::
  getSeekingDeathRateIncrease () const
  {
    return this->seekingDeathRateIncrease_;
  }

  VectorSpeciesIntervention::SeekingDeathRateIncreaseOptional& VectorSpeciesIntervention::
  getSeekingDeathRateIncrease ()
  {
    return this->seekingDeathRateIncrease_;
  }

  void VectorSpeciesIntervention::
  setSeekingDeathRateIncrease (const SeekingDeathRateIncreaseType& x)
  {
    this->seekingDeathRateIncrease_.set (x);
  }

  void VectorSpeciesIntervention::
  setSeekingDeathRateIncrease (const SeekingDeathRateIncreaseOptional& x)
  {
    this->seekingDeathRateIncrease_ = x;
  }

  void VectorSpeciesIntervention::
  setSeekingDeathRateIncrease (::std::unique_ptr< SeekingDeathRateIncreaseType > x)
  {
    this->seekingDeathRateIncrease_.set (std::move (x));
  }

  const VectorSpeciesIntervention::ProbDeathOvipositingOptional& VectorSpeciesIntervention::
  getProbDeathOvipositing () const
  {
    return this->probDeathOvipositing_;
  }

  VectorSpeciesIntervention::ProbDeathOvipositingOptional& VectorSpeciesIntervention::
  getProbDeathOvipositing ()
  {
    return this->probDeathOvipositing_;
  }

  void VectorSpeciesIntervention::
  setProbDeathOvipositing (const ProbDeathOvipositingType& x)
  {
    this->probDeathOvipositing_.set (x);
  }

  void VectorSpeciesIntervention::
  setProbDeathOvipositing (const ProbDeathOvipositingOptional& x)
  {
    this->probDeathOvipositing_ = x;
  }

  void VectorSpeciesIntervention::
  setProbDeathOvipositing (::std::unique_ptr< ProbDeathOvipositingType > x)
  {
    this->probDeathOvipositing_.set (std::move (x));
  }

  const VectorSpeciesIntervention::EmergenceReductionOptional& VectorSpeciesIntervention::
  getEmergenceReduction () const
  {
    return this->emergenceReduction_;
  }

  VectorSpeciesIntervention::EmergenceReductionOptional& VectorSpeciesIntervention::
  getEmergenceReduction ()
  {
    return this->emergenceReduction_;
  }

  void VectorSpeciesIntervention::
  setEmergenceReduction (const EmergenceReductionType& x)
  {
    this->emergenceReduction_.set (x);
  }

  void VectorSpeciesIntervention::
  setEmergenceReduction (const EmergenceReductionOptional& x)
  {
    this->emergenceReduction_ = x;
  }

  void VectorSpeciesIntervention::
  setEmergenceReduction (::std::unique_ptr< EmergenceReductionType > x)
  {
    this->emergenceReduction_.set (std::move (x));
  }

  const VectorSpeciesIntervention::MosquitoType& VectorSpeciesIntervention::
  getMosquito () const
  {
    return this->mosquito_.get ();
  }

  VectorSpeciesIntervention::MosquitoType& VectorSpeciesIntervention::
  getMosquito ()
  {
    return this->mosquito_.get ();
  }

  void VectorSpeciesIntervention::
  setMosquito (const MosquitoType& x)
  {
    this->mosquito_.set (x);
  }

  void VectorSpeciesIntervention::
  setMosquito (::std::unique_ptr< MosquitoType > x)
  {
    this->mosquito_.set (std::move (x));
  }


  // ChangeHS
  // 

  const ChangeHS::TimedDeploymentSequence& ChangeHS::
  getTimedDeployment () const
  {
    return this->timedDeployment_;
  }

  ChangeHS::TimedDeploymentSequence& ChangeHS::
  getTimedDeployment ()
  {
    return this->timedDeployment_;
  }

  void ChangeHS::
  setTimedDeployment (const TimedDeploymentSequence& s)
  {
    this->timedDeployment_ = s;
  }

  const ChangeHS::NameOptional& ChangeHS::
  getName () const
  {
    return this->name_;
  }

  ChangeHS::NameOptional& ChangeHS::
  getName ()
  {
    return this->name_;
  }

  void ChangeHS::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ChangeHS::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ChangeHS::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // ChangeEIR
  // 

  const ChangeEIR::TimedDeploymentSequence& ChangeEIR::
  getTimedDeployment () const
  {
    return this->timedDeployment_;
  }

  ChangeEIR::TimedDeploymentSequence& ChangeEIR::
  getTimedDeployment ()
  {
    return this->timedDeployment_;
  }

  void ChangeEIR::
  setTimedDeployment (const TimedDeploymentSequence& s)
  {
    this->timedDeployment_ = s;
  }

  const ChangeEIR::NameOptional& ChangeEIR::
  getName () const
  {
    return this->name_;
  }

  ChangeEIR::NameOptional& ChangeEIR::
  getName ()
  {
    return this->name_;
  }

  void ChangeEIR::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ChangeEIR::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ChangeEIR::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // ImportedInfections
  // 

  const ImportedInfections::TimedType& ImportedInfections::
  getTimed () const
  {
    return this->timed_.get ();
  }

  ImportedInfections::TimedType& ImportedInfections::
  getTimed ()
  {
    return this->timed_.get ();
  }

  void ImportedInfections::
  setTimed (const TimedType& x)
  {
    this->timed_.set (x);
  }

  void ImportedInfections::
  setTimed (::std::unique_ptr< TimedType > x)
  {
    this->timed_.set (std::move (x));
  }

  const ImportedInfections::NameOptional& ImportedInfections::
  getName () const
  {
    return this->name_;
  }

  ImportedInfections::NameOptional& ImportedInfections::
  getName ()
  {
    return this->name_;
  }

  void ImportedInfections::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void ImportedInfections::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void ImportedInfections::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // InsertR_0Case
  // 

  const InsertR_0Case::TimedDeploymentSequence& InsertR_0Case::
  getTimedDeployment () const
  {
    return this->timedDeployment_;
  }

  InsertR_0Case::TimedDeploymentSequence& InsertR_0Case::
  getTimedDeployment ()
  {
    return this->timedDeployment_;
  }

  void InsertR_0Case::
  setTimedDeployment (const TimedDeploymentSequence& s)
  {
    this->timedDeployment_ = s;
  }

  const InsertR_0Case::NameOptional& InsertR_0Case::
  getName () const
  {
    return this->name_;
  }

  InsertR_0Case::NameOptional& InsertR_0Case::
  getName ()
  {
    return this->name_;
  }

  void InsertR_0Case::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void InsertR_0Case::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void InsertR_0Case::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // UninfectVectors
  // 

  const UninfectVectors::TimedDeploymentSequence& UninfectVectors::
  getTimedDeployment () const
  {
    return this->timedDeployment_;
  }

  UninfectVectors::TimedDeploymentSequence& UninfectVectors::
  getTimedDeployment ()
  {
    return this->timedDeployment_;
  }

  void UninfectVectors::
  setTimedDeployment (const TimedDeploymentSequence& s)
  {
    this->timedDeployment_ = s;
  }

  const UninfectVectors::NameOptional& UninfectVectors::
  getName () const
  {
    return this->name_;
  }

  UninfectVectors::NameOptional& UninfectVectors::
  getName ()
  {
    return this->name_;
  }

  void UninfectVectors::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void UninfectVectors::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void UninfectVectors::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // VectorPop
  // 

  const VectorPop::InterventionSequence& VectorPop::
  getIntervention () const
  {
    return this->intervention_;
  }

  VectorPop::InterventionSequence& VectorPop::
  getIntervention ()
  {
    return this->intervention_;
  }

  void VectorPop::
  setIntervention (const InterventionSequence& s)
  {
    this->intervention_ = s;
  }


  // VectorTrap1
  // 

  const VectorTrap1::InterventionSequence& VectorTrap1::
  getIntervention () const
  {
    return this->intervention_;
  }

  VectorTrap1::InterventionSequence& VectorTrap1::
  getIntervention ()
  {
    return this->intervention_;
  }

  void VectorTrap1::
  setIntervention (const InterventionSequence& s)
  {
    this->intervention_ = s;
  }


  // Deployment
  // 

  const Deployment::ComponentSequence& Deployment::
  getComponent () const
  {
    return this->component_;
  }

  Deployment::ComponentSequence& Deployment::
  getComponent ()
  {
    return this->component_;
  }

  void Deployment::
  setComponent (const ComponentSequence& s)
  {
    this->component_ = s;
  }

  const Deployment::ConditionSequence& Deployment::
  getCondition () const
  {
    return this->condition_;
  }

  Deployment::ConditionSequence& Deployment::
  getCondition ()
  {
    return this->condition_;
  }

  void Deployment::
  setCondition (const ConditionSequence& s)
  {
    this->condition_ = s;
  }

  const Deployment::ContinuousSequence& Deployment::
  getContinuous () const
  {
    return this->continuous_;
  }

  Deployment::ContinuousSequence& Deployment::
  getContinuous ()
  {
    return this->continuous_;
  }

  void Deployment::
  setContinuous (const ContinuousSequence& s)
  {
    this->continuous_ = s;
  }

  const Deployment::TimedSequence& Deployment::
  getTimed () const
  {
    return this->timed_;
  }

  Deployment::TimedSequence& Deployment::
  getTimed ()
  {
    return this->timed_;
  }

  void Deployment::
  setTimed (const TimedSequence& s)
  {
    this->timed_ = s;
  }

  const Deployment::NameOptional& Deployment::
  getName () const
  {
    return this->name_;
  }

  Deployment::NameOptional& Deployment::
  getName ()
  {
    return this->name_;
  }

  void Deployment::
  setName (const NameType& x)
  {
    this->name_.set (x);
  }

  void Deployment::
  setName (const NameOptional& x)
  {
    this->name_ = x;
  }

  void Deployment::
  setName (::std::unique_ptr< NameType > x)
  {
    this->name_.set (std::move (x));
  }


  // RecruitmentOnly
  // 


  // ClearImmunity
  // 


  // Description
  // 

  const Description::AnophelesSequence& Description::
  getAnopheles () const
  {
    return this->anopheles_;
  }

  Description::AnophelesSequence& Description::
  getAnopheles ()
  {
    return this->anopheles_;
  }

  void Description::
  setAnopheles (const AnophelesSequence& s)
  {
    this->anopheles_ = s;
  }


  // Description1
  // 

  const Description1::RelativeAvailabilityType& Description1::
  getRelativeAvailability () const
  {
    return this->relativeAvailability_.get ();
  }

  Description1::RelativeAvailabilityType& Description1::
  getRelativeAvailability ()
  {
    return this->relativeAvailability_.get ();
  }

  void Description1::
  setRelativeAvailability (const RelativeAvailabilityType& x)
  {
    this->relativeAvailability_.set (x);
  }

  void Description1::
  setRelativeAvailability (::std::unique_ptr< RelativeAvailabilityType > x)
  {
    this->relativeAvailability_.set (std::move (x));
  }

  const Description1::DecayOfAvailabilityType& Description1::
  getDecayOfAvailability () const
  {
    return this->decayOfAvailability_.get ();
  }

  Description1::DecayOfAvailabilityType& Description1::
  getDecayOfAvailability ()
  {
    return this->decayOfAvailability_.get ();
  }

  void Description1::
  setDecayOfAvailability (const DecayOfAvailabilityType& x)
  {
    this->decayOfAvailability_.set (x);
  }

  void Description1::
  setDecayOfAvailability (::std::unique_ptr< DecayOfAvailabilityType > x)
  {
    this->decayOfAvailability_.set (std::move (x));
  }

  const Description1::MosquitoType& Description1::
  getMosquito () const
  {
    return this->mosquito_.get ();
  }

  Description1::MosquitoType& Description1::
  getMosquito ()
  {
    return this->mosquito_.get ();
  }

  void Description1::
  setMosquito (const MosquitoType& x)
  {
    this->mosquito_.set (x);
  }

  void Description1::
  setMosquito (::std::unique_ptr< MosquitoType > x)
  {
    this->mosquito_.set (std::move (x));
  }


  // Timed
  // 

  const Timed::DeploySequence& Timed::
  getDeploy () const
  {
    return this->deploy_;
  }

  Timed::DeploySequence& Timed::
  getDeploy ()
  {
    return this->deploy_;
  }

  void Timed::
  setDeploy (const DeploySequence& s)
  {
    this->deploy_ = s;
  }


  // CumulativeCoverage
  // 

  const CumulativeCoverage::ComponentType& CumulativeCoverage::
  getComponent () const
  {
    return this->component_.get ();
  }

  CumulativeCoverage::ComponentType& CumulativeCoverage::
  getComponent ()
  {
    return this->component_.get ();
  }

  void CumulativeCoverage::
  setComponent (const ComponentType& x)
  {
    this->component_.set (x);
  }

  void CumulativeCoverage::
  setComponent (::std::unique_ptr< ComponentType > x)
  {
    this->component_.set (std::move (x));
  }


  // AnophelesParams1
  // 

  const AnophelesParams1::HoleIndexMaxOptional& AnophelesParams1::
  getHoleIndexMax () const
  {
    return this->holeIndexMax_;
  }

  AnophelesParams1::HoleIndexMaxOptional& AnophelesParams1::
  getHoleIndexMax ()
  {
    return this->holeIndexMax_;
  }

  void AnophelesParams1::
  setHoleIndexMax (const HoleIndexMaxType& x)
  {
    this->holeIndexMax_.set (x);
  }

  void AnophelesParams1::
  setHoleIndexMax (const HoleIndexMaxOptional& x)
  {
    this->holeIndexMax_ = x;
  }

  void AnophelesParams1::
  setHoleIndexMax (::std::unique_ptr< HoleIndexMaxType > x)
  {
    this->holeIndexMax_.set (std::move (x));
  }

  const AnophelesParams1::DeterrencyOptional& AnophelesParams1::
  getDeterrency () const
  {
    return this->deterrency_;
  }

  AnophelesParams1::DeterrencyOptional& AnophelesParams1::
  getDeterrency ()
  {
    return this->deterrency_;
  }

  void AnophelesParams1::
  setDeterrency (const DeterrencyType& x)
  {
    this->deterrency_.set (x);
  }

  void AnophelesParams1::
  setDeterrency (const DeterrencyOptional& x)
  {
    this->deterrency_ = x;
  }

  void AnophelesParams1::
  setDeterrency (::std::unique_ptr< DeterrencyType > x)
  {
    this->deterrency_.set (std::move (x));
  }

  const AnophelesParams1::TwoStageDeterrencyOptional& AnophelesParams1::
  getTwoStageDeterrency () const
  {
    return this->twoStageDeterrency_;
  }

  AnophelesParams1::TwoStageDeterrencyOptional& AnophelesParams1::
  getTwoStageDeterrency ()
  {
    return this->twoStageDeterrency_;
  }

  void AnophelesParams1::
  setTwoStageDeterrency (const TwoStageDeterrencyType& x)
  {
    this->twoStageDeterrency_.set (x);
  }

  void AnophelesParams1::
  setTwoStageDeterrency (const TwoStageDeterrencyOptional& x)
  {
    this->twoStageDeterrency_ = x;
  }

  void AnophelesParams1::
  setTwoStageDeterrency (::std::unique_ptr< TwoStageDeterrencyType > x)
  {
    this->twoStageDeterrency_.set (std::move (x));
  }

  const AnophelesParams1::PreprandialKillingEffectOptional& AnophelesParams1::
  getPreprandialKillingEffect () const
  {
    return this->preprandialKillingEffect_;
  }

  AnophelesParams1::PreprandialKillingEffectOptional& AnophelesParams1::
  getPreprandialKillingEffect ()
  {
    return this->preprandialKillingEffect_;
  }

  void AnophelesParams1::
  setPreprandialKillingEffect (const PreprandialKillingEffectType& x)
  {
    this->preprandialKillingEffect_.set (x);
  }

  void AnophelesParams1::
  setPreprandialKillingEffect (const PreprandialKillingEffectOptional& x)
  {
    this->preprandialKillingEffect_ = x;
  }

  void AnophelesParams1::
  setPreprandialKillingEffect (::std::unique_ptr< PreprandialKillingEffectType > x)
  {
    this->preprandialKillingEffect_.set (std::move (x));
  }

  const AnophelesParams1::PreprandialKillingEffectLogitOptional& AnophelesParams1::
  getPreprandialKillingEffectLogit () const
  {
    return this->preprandialKillingEffectLogit_;
  }

  AnophelesParams1::PreprandialKillingEffectLogitOptional& AnophelesParams1::
  getPreprandialKillingEffectLogit ()
  {
    return this->preprandialKillingEffectLogit_;
  }

  void AnophelesParams1::
  setPreprandialKillingEffectLogit (const PreprandialKillingEffectLogitType& x)
  {
    this->preprandialKillingEffectLogit_.set (x);
  }

  void AnophelesParams1::
  setPreprandialKillingEffectLogit (const PreprandialKillingEffectLogitOptional& x)
  {
    this->preprandialKillingEffectLogit_ = x;
  }

  void AnophelesParams1::
  setPreprandialKillingEffectLogit (::std::unique_ptr< PreprandialKillingEffectLogitType > x)
  {
    this->preprandialKillingEffectLogit_.set (std::move (x));
  }

  const AnophelesParams1::PostprandialKillingEffectOptional& AnophelesParams1::
  getPostprandialKillingEffect () const
  {
    return this->postprandialKillingEffect_;
  }

  AnophelesParams1::PostprandialKillingEffectOptional& AnophelesParams1::
  getPostprandialKillingEffect ()
  {
    return this->postprandialKillingEffect_;
  }

  void AnophelesParams1::
  setPostprandialKillingEffect (const PostprandialKillingEffectType& x)
  {
    this->postprandialKillingEffect_.set (x);
  }

  void AnophelesParams1::
  setPostprandialKillingEffect (const PostprandialKillingEffectOptional& x)
  {
    this->postprandialKillingEffect_ = x;
  }

  void AnophelesParams1::
  setPostprandialKillingEffect (::std::unique_ptr< PostprandialKillingEffectType > x)
  {
    this->postprandialKillingEffect_.set (std::move (x));
  }

  const AnophelesParams1::PostprandialKillingEffectLogitOptional& AnophelesParams1::
  getPostprandialKillingEffectLogit () const
  {
    return this->postprandialKillingEffectLogit_;
  }

  AnophelesParams1::PostprandialKillingEffectLogitOptional& AnophelesParams1::
  getPostprandialKillingEffectLogit ()
  {
    return this->postprandialKillingEffectLogit_;
  }

  void AnophelesParams1::
  setPostprandialKillingEffectLogit (const PostprandialKillingEffectLogitType& x)
  {
    this->postprandialKillingEffectLogit_.set (x);
  }

  void AnophelesParams1::
  setPostprandialKillingEffectLogit (const PostprandialKillingEffectLogitOptional& x)
  {
    this->postprandialKillingEffectLogit_ = x;
  }

  void AnophelesParams1::
  setPostprandialKillingEffectLogit (::std::unique_ptr< PostprandialKillingEffectLogitType > x)
  {
    this->postprandialKillingEffectLogit_.set (std::move (x));
  }

  const AnophelesParams1::FecundityReductionOptional& AnophelesParams1::
  getFecundityReduction () const
  {
    return this->fecundityReduction_;
  }

  AnophelesParams1::FecundityReductionOptional& AnophelesParams1::
  getFecundityReduction ()
  {
    return this->fecundityReduction_;
  }

  void AnophelesParams1::
  setFecundityReduction (const FecundityReductionType& x)
  {
    this->fecundityReduction_.set (x);
  }

  void AnophelesParams1::
  setFecundityReduction (const FecundityReductionOptional& x)
  {
    this->fecundityReduction_ = x;
  }

  void AnophelesParams1::
  setFecundityReduction (::std::unique_ptr< FecundityReductionType > x)
  {
    this->fecundityReduction_.set (std::move (x));
  }

  const AnophelesParams1::FecundityReductionLogitOptional& AnophelesParams1::
  getFecundityReductionLogit () const
  {
    return this->fecundityReductionLogit_;
  }

  AnophelesParams1::FecundityReductionLogitOptional& AnophelesParams1::
  getFecundityReductionLogit ()
  {
    return this->fecundityReductionLogit_;
  }

  void AnophelesParams1::
  setFecundityReductionLogit (const FecundityReductionLogitType& x)
  {
    this->fecundityReductionLogit_.set (x);
  }

  void AnophelesParams1::
  setFecundityReductionLogit (const FecundityReductionLogitOptional& x)
  {
    this->fecundityReductionLogit_ = x;
  }

  void AnophelesParams1::
  setFecundityReductionLogit (::std::unique_ptr< FecundityReductionLogitType > x)
  {
    this->fecundityReductionLogit_.set (std::move (x));
  }

  const AnophelesParams1::MosquitoType& AnophelesParams1::
  getMosquito () const
  {
    return this->mosquito_.get ();
  }

  AnophelesParams1::MosquitoType& AnophelesParams1::
  getMosquito ()
  {
    return this->mosquito_.get ();
  }

  void AnophelesParams1::
  setMosquito (const MosquitoType& x)
  {
    this->mosquito_.set (x);
  }

  void AnophelesParams1::
  setMosquito (::std::unique_ptr< MosquitoType > x)
  {
    this->mosquito_.set (std::move (x));
  }

  const AnophelesParams1::PropActiveType& AnophelesParams1::
  getPropActive () const
  {
    return this->propActive_.get ();
  }

  AnophelesParams1::PropActiveType& AnophelesParams1::
  getPropActive ()
  {
    return this->propActive_.get ();
  }

  void AnophelesParams1::
  setPropActive (const PropActiveType& x)
  {
    this->propActive_.set (x);
  }

  AnophelesParams1::PropActiveType AnophelesParams1::
  getPropActiveDefaultValue ()
  {
    return PropActiveType (1.0);
  }


  // AnophelesParams11
  // 

  const AnophelesParams11::DeterrencyOptional& AnophelesParams11::
  getDeterrency () const
  {
    return this->deterrency_;
  }

  AnophelesParams11::DeterrencyOptional& AnophelesParams11::
  getDeterrency ()
  {
    return this->deterrency_;
  }

  void AnophelesParams11::
  setDeterrency (const DeterrencyType& x)
  {
    this->deterrency_.set (x);
  }

  void AnophelesParams11::
  setDeterrency (const DeterrencyOptional& x)
  {
    this->deterrency_ = x;
  }

  void AnophelesParams11::
  setDeterrency (::std::unique_ptr< DeterrencyType > x)
  {
    this->deterrency_.set (std::move (x));
  }

  const AnophelesParams11::PreprandialKillingEffectOptional& AnophelesParams11::
  getPreprandialKillingEffect () const
  {
    return this->preprandialKillingEffect_;
  }

  AnophelesParams11::PreprandialKillingEffectOptional& AnophelesParams11::
  getPreprandialKillingEffect ()
  {
    return this->preprandialKillingEffect_;
  }

  void AnophelesParams11::
  setPreprandialKillingEffect (const PreprandialKillingEffectType& x)
  {
    this->preprandialKillingEffect_.set (x);
  }

  void AnophelesParams11::
  setPreprandialKillingEffect (const PreprandialKillingEffectOptional& x)
  {
    this->preprandialKillingEffect_ = x;
  }

  void AnophelesParams11::
  setPreprandialKillingEffect (::std::unique_ptr< PreprandialKillingEffectType > x)
  {
    this->preprandialKillingEffect_.set (std::move (x));
  }

  const AnophelesParams11::PostprandialKillingEffectOptional& AnophelesParams11::
  getPostprandialKillingEffect () const
  {
    return this->postprandialKillingEffect_;
  }

  AnophelesParams11::PostprandialKillingEffectOptional& AnophelesParams11::
  getPostprandialKillingEffect ()
  {
    return this->postprandialKillingEffect_;
  }

  void AnophelesParams11::
  setPostprandialKillingEffect (const PostprandialKillingEffectType& x)
  {
    this->postprandialKillingEffect_.set (x);
  }

  void AnophelesParams11::
  setPostprandialKillingEffect (const PostprandialKillingEffectOptional& x)
  {
    this->postprandialKillingEffect_ = x;
  }

  void AnophelesParams11::
  setPostprandialKillingEffect (::std::unique_ptr< PostprandialKillingEffectType > x)
  {
    this->postprandialKillingEffect_.set (std::move (x));
  }

  const AnophelesParams11::FecundityReductionOptional& AnophelesParams11::
  getFecundityReduction () const
  {
    return this->fecundityReduction_;
  }

  AnophelesParams11::FecundityReductionOptional& AnophelesParams11::
  getFecundityReduction ()
  {
    return this->fecundityReduction_;
  }

  void AnophelesParams11::
  setFecundityReduction (const FecundityReductionType& x)
  {
    this->fecundityReduction_.set (x);
  }

  void AnophelesParams11::
  setFecundityReduction (const FecundityReductionOptional& x)
  {
    this->fecundityReduction_ = x;
  }

  void AnophelesParams11::
  setFecundityReduction (::std::unique_ptr< FecundityReductionType > x)
  {
    this->fecundityReduction_.set (std::move (x));
  }

  const AnophelesParams11::MosquitoType& AnophelesParams11::
  getMosquito () const
  {
    return this->mosquito_.get ();
  }

  AnophelesParams11::MosquitoType& AnophelesParams11::
  getMosquito ()
  {
    return this->mosquito_.get ();
  }

  void AnophelesParams11::
  setMosquito (const MosquitoType& x)
  {
    this->mosquito_.set (x);
  }

  void AnophelesParams11::
  setMosquito (::std::unique_ptr< MosquitoType > x)
  {
    this->mosquito_.set (std::move (x));
  }

  const AnophelesParams11::PropActiveType& AnophelesParams11::
  getPropActive () const
  {
    return this->propActive_.get ();
  }

  AnophelesParams11::PropActiveType& AnophelesParams11::
  getPropActive ()
  {
    return this->propActive_.get ();
  }

  void AnophelesParams11::
  setPropActive (const PropActiveType& x)
  {
    this->propActive_.set (x);
  }

  AnophelesParams11::PropActiveType AnophelesParams11::
  getPropActiveDefaultValue ()
  {
    return PropActiveType (1.0);
  }


  // AnophelesParams2
  // 

  const AnophelesParams2::DeterrencyType& AnophelesParams2::
  getDeterrency () const
  {
    return this->deterrency_.get ();
  }

  AnophelesParams2::DeterrencyType& AnophelesParams2::
  getDeterrency ()
  {
    return this->deterrency_.get ();
  }

  void AnophelesParams2::
  setDeterrency (const DeterrencyType& x)
  {
    this->deterrency_.set (x);
  }

  void AnophelesParams2::
  setDeterrency (::std::unique_ptr< DeterrencyType > x)
  {
    this->deterrency_.set (std::move (x));
  }

  const AnophelesParams2::PreprandialKillingEffectType& AnophelesParams2::
  getPreprandialKillingEffect () const
  {
    return this->preprandialKillingEffect_.get ();
  }

  AnophelesParams2::PreprandialKillingEffectType& AnophelesParams2::
  getPreprandialKillingEffect ()
  {
    return this->preprandialKillingEffect_.get ();
  }

  void AnophelesParams2::
  setPreprandialKillingEffect (const PreprandialKillingEffectType& x)
  {
    this->preprandialKillingEffect_.set (x);
  }

  void AnophelesParams2::
  setPreprandialKillingEffect (::std::unique_ptr< PreprandialKillingEffectType > x)
  {
    this->preprandialKillingEffect_.set (std::move (x));
  }

  const AnophelesParams2::PostprandialKillingEffectType& AnophelesParams2::
  getPostprandialKillingEffect () const
  {
    return this->postprandialKillingEffect_.get ();
  }

  AnophelesParams2::PostprandialKillingEffectType& AnophelesParams2::
  getPostprandialKillingEffect ()
  {
    return this->postprandialKillingEffect_.get ();
  }

  void AnophelesParams2::
  setPostprandialKillingEffect (const PostprandialKillingEffectType& x)
  {
    this->postprandialKillingEffect_.set (x);
  }

  void AnophelesParams2::
  setPostprandialKillingEffect (::std::unique_ptr< PostprandialKillingEffectType > x)
  {
    this->postprandialKillingEffect_.set (std::move (x));
  }

  const AnophelesParams2::FecundityReductionOptional& AnophelesParams2::
  getFecundityReduction () const
  {
    return this->fecundityReduction_;
  }

  AnophelesParams2::FecundityReductionOptional& AnophelesParams2::
  getFecundityReduction ()
  {
    return this->fecundityReduction_;
  }

  void AnophelesParams2::
  setFecundityReduction (const FecundityReductionType& x)
  {
    this->fecundityReduction_.set (x);
  }

  void AnophelesParams2::
  setFecundityReduction (const FecundityReductionOptional& x)
  {
    this->fecundityReduction_ = x;
  }

  void AnophelesParams2::
  setFecundityReduction (::std::unique_ptr< FecundityReductionType > x)
  {
    this->fecundityReduction_.set (std::move (x));
  }

  const AnophelesParams2::MosquitoType& AnophelesParams2::
  getMosquito () const
  {
    return this->mosquito_.get ();
  }

  AnophelesParams2::MosquitoType& AnophelesParams2::
  getMosquito ()
  {
    return this->mosquito_.get ();
  }

  void AnophelesParams2::
  setMosquito (const MosquitoType& x)
  {
    this->mosquito_.set (x);
  }

  void AnophelesParams2::
  setMosquito (::std::unique_ptr< MosquitoType > x)
  {
    this->mosquito_.set (std::move (x));
  }

  const AnophelesParams2::PropActiveType& AnophelesParams2::
  getPropActive () const
  {
    return this->propActive_.get ();
  }

  AnophelesParams2::PropActiveType& AnophelesParams2::
  getPropActive ()
  {
    return this->propActive_.get ();
  }

  void AnophelesParams2::
  setPropActive (const PropActiveType& x)
  {
    this->propActive_.set (x);
  }

  AnophelesParams2::PropActiveType AnophelesParams2::
  getPropActiveDefaultValue ()
  {
    return PropActiveType (1.0);
  }


  // SeekingDeathRateIncrease
  // 

  const SeekingDeathRateIncrease::DecayType& SeekingDeathRateIncrease::
  getDecay () const
  {
    return this->decay_.get ();
  }

  SeekingDeathRateIncrease::DecayType& SeekingDeathRateIncrease::
  getDecay ()
  {
    return this->decay_.get ();
  }

  void SeekingDeathRateIncrease::
  setDecay (const DecayType& x)
  {
    this->decay_.set (x);
  }

  void SeekingDeathRateIncrease::
  setDecay (::std::unique_ptr< DecayType > x)
  {
    this->decay_.set (std::move (x));
  }

  const SeekingDeathRateIncrease::InitialType& SeekingDeathRateIncrease::
  getInitial () const
  {
    return this->initial_.get ();
  }

  SeekingDeathRateIncrease::InitialType& SeekingDeathRateIncrease::
  getInitial ()
  {
    return this->initial_.get ();
  }

  void SeekingDeathRateIncrease::
  setInitial (const InitialType& x)
  {
    this->initial_.set (x);
  }


  // ProbDeathOvipositing
  // 

  const ProbDeathOvipositing::DecayType& ProbDeathOvipositing::
  getDecay () const
  {
    return this->decay_.get ();
  }

  ProbDeathOvipositing::DecayType& ProbDeathOvipositing::
  getDecay ()
  {
    return this->decay_.get ();
  }

  void ProbDeathOvipositing::
  setDecay (const DecayType& x)
  {
    this->decay_.set (x);
  }

  void ProbDeathOvipositing::
  setDecay (::std::unique_ptr< DecayType > x)
  {
    this->decay_.set (std::move (x));
  }

  const ProbDeathOvipositing::InitialType& ProbDeathOvipositing::
  getInitial () const
  {
    return this->initial_.get ();
  }

  ProbDeathOvipositing::InitialType& ProbDeathOvipositing::
  getInitial ()
  {
    return this->initial_.get ();
  }

  void ProbDeathOvipositing::
  setInitial (const InitialType& x)
  {
    this->initial_.set (x);
  }


  // EmergenceReduction
  // 

  const EmergenceReduction::DecayType& EmergenceReduction::
  getDecay () const
  {
    return this->decay_.get ();
  }

  EmergenceReduction::DecayType& EmergenceReduction::
  getDecay ()
  {
    return this->decay_.get ();
  }

  void EmergenceReduction::
  setDecay (const DecayType& x)
  {
    this->decay_.set (x);
  }

  void EmergenceReduction::
  setDecay (::std::unique_ptr< DecayType > x)
  {
    this->decay_.set (std::move (x));
  }

  const EmergenceReduction::InitialType& EmergenceReduction::
  getInitial () const
  {
    return this->initial_.get ();
  }

  EmergenceReduction::InitialType& EmergenceReduction::
  getInitial ()
  {
    return this->initial_.get ();
  }

  void EmergenceReduction::
  setInitial (const InitialType& x)
  {
    this->initial_.set (x);
  }


  // TimedDeployment
  // 

  const TimedDeployment::TimeType& TimedDeployment::
  getTime () const
  {
    return this->time_.get ();
  }

  TimedDeployment::TimeType& TimedDeployment::
  getTime ()
  {
    return this->time_.get ();
  }

  void TimedDeployment::
  setTime (const TimeType& x)
  {
    this->time_.set (x);
  }

  void TimedDeployment::
  setTime (::std::unique_ptr< TimeType > x)
  {
    this->time_.set (std::move (x));
  }


  // TimedDeployment1
  // 

  const TimedDeployment1::TimeType& TimedDeployment1::
  getTime () const
  {
    return this->time_.get ();
  }

  TimedDeployment1::TimeType& TimedDeployment1::
  getTime ()
  {
    return this->time_.get ();
  }

  void TimedDeployment1::
  setTime (const TimeType& x)
  {
    this->time_.set (x);
  }

  void TimedDeployment1::
  setTime (::std::unique_ptr< TimeType > x)
  {
    this->time_.set (std::move (x));
  }


  // Timed1
  // 

  const Timed1::RateSequence& Timed1::
  getRate () const
  {
    return this->rate_;
  }

  Timed1::RateSequence& Timed1::
  getRate ()
  {
    return this->rate_;
  }

  void Timed1::
  setRate (const RateSequence& s)
  {
    this->rate_ = s;
  }

  const Timed1::PeriodType& Timed1::
  getPeriod () const
  {
    return this->period_.get ();
  }

  Timed1::PeriodType& Timed1::
  getPeriod ()
  {
    return this->period_.get ();
  }

  void Timed1::
  setPeriod (const PeriodType& x)
  {
    this->period_.set (x);
  }

  void Timed1::
  setPeriod (::std::unique_ptr< PeriodType > x)
  {
    this->period_.set (std::move (x));
  }

  const Timed1::PeriodType& Timed1::
  getPeriodDefaultValue ()
  {
    return period_default_value_;
  }


  // TimedDeployment2
  // 

  const TimedDeployment2::TimeType& TimedDeployment2::
  getTime () const
  {
    return this->time_.get ();
  }

  TimedDeployment2::TimeType& TimedDeployment2::
  getTime ()
  {
    return this->time_.get ();
  }

  void TimedDeployment2::
  setTime (const TimeType& x)
  {
    this->time_.set (x);
  }

  void TimedDeployment2::
  setTime (::std::unique_ptr< TimeType > x)
  {
    this->time_.set (std::move (x));
  }


  // Condition
  // 

  const Condition::MeasureType& Condition::
  getMeasure () const
  {
    return this->measure_.get ();
  }

  Condition::MeasureType& Condition::
  getMeasure ()
  {
    return this->measure_.get ();
  }

  void Condition::
  setMeasure (const MeasureType& x)
  {
    this->measure_.set (x);
  }

  void Condition::
  setMeasure (::std::unique_ptr< MeasureType > x)
  {
    this->measure_.set (std::move (x));
  }

  const Condition::MinValueOptional& Condition::
  getMinValue () const
  {
    return this->minValue_;
  }

  Condition::MinValueOptional& Condition::
  getMinValue ()
  {
    return this->minValue_;
  }

  void Condition::
  setMinValue (const MinValueType& x)
  {
    this->minValue_.set (x);
  }

  void Condition::
  setMinValue (const MinValueOptional& x)
  {
    this->minValue_ = x;
  }

  const Condition::MaxValueOptional& Condition::
  getMaxValue () const
  {
    return this->maxValue_;
  }

  Condition::MaxValueOptional& Condition::
  getMaxValue ()
  {
    return this->maxValue_;
  }

  void Condition::
  setMaxValue (const MaxValueType& x)
  {
    this->maxValue_.set (x);
  }

  void Condition::
  setMaxValue (const MaxValueOptional& x)
  {
    this->maxValue_ = x;
  }

  const Condition::InitialStateType& Condition::
  getInitialState () const
  {
    return this->initialState_.get ();
  }

  Condition::InitialStateType& Condition::
  getInitialState ()
  {
    return this->initialState_.get ();
  }

  void Condition::
  setInitialState (const InitialStateType& x)
  {
    this->initialState_.set (x);
  }


  // Deploy1
  // 

  const Deploy1::RatioToHumansType& Deploy1::
  getRatioToHumans () const
  {
    return this->ratioToHumans_.get ();
  }

  Deploy1::RatioToHumansType& Deploy1::
  getRatioToHumans ()
  {
    return this->ratioToHumans_.get ();
  }

  void Deploy1::
  setRatioToHumans (const RatioToHumansType& x)
  {
    this->ratioToHumans_.set (x);
  }

  const Deploy1::LifespanType& Deploy1::
  getLifespan () const
  {
    return this->lifespan_.get ();
  }

  Deploy1::LifespanType& Deploy1::
  getLifespan ()
  {
    return this->lifespan_.get ();
  }

  void Deploy1::
  setLifespan (const LifespanType& x)
  {
    this->lifespan_.set (x);
  }

  void Deploy1::
  setLifespan (::std::unique_ptr< LifespanType > x)
  {
    this->lifespan_.set (std::move (x));
  }


  // TwoStageDeterrency
  // 

  const TwoStageDeterrency::EnteringOptional& TwoStageDeterrency::
  getEntering () const
  {
    return this->entering_;
  }

  TwoStageDeterrency::EnteringOptional& TwoStageDeterrency::
  getEntering ()
  {
    return this->entering_;
  }

  void TwoStageDeterrency::
  setEntering (const EnteringType& x)
  {
    this->entering_.set (x);
  }

  void TwoStageDeterrency::
  setEntering (const EnteringOptional& x)
  {
    this->entering_ = x;
  }

  void TwoStageDeterrency::
  setEntering (::std::unique_ptr< EnteringType > x)
  {
    this->entering_.set (std::move (x));
  }

  const TwoStageDeterrency::EnteringLogitOptional& TwoStageDeterrency::
  getEnteringLogit () const
  {
    return this->enteringLogit_;
  }

  TwoStageDeterrency::EnteringLogitOptional& TwoStageDeterrency::
  getEnteringLogit ()
  {
    return this->enteringLogit_;
  }

  void TwoStageDeterrency::
  setEnteringLogit (const EnteringLogitType& x)
  {
    this->enteringLogit_.set (x);
  }

  void TwoStageDeterrency::
  setEnteringLogit (const EnteringLogitOptional& x)
  {
    this->enteringLogit_ = x;
  }

  void TwoStageDeterrency::
  setEnteringLogit (::std::unique_ptr< EnteringLogitType > x)
  {
    this->enteringLogit_.set (std::move (x));
  }

  const TwoStageDeterrency::AttackingOptional& TwoStageDeterrency::
  getAttacking () const
  {
    return this->attacking_;
  }

  TwoStageDeterrency::AttackingOptional& TwoStageDeterrency::
  getAttacking ()
  {
    return this->attacking_;
  }

  void TwoStageDeterrency::
  setAttacking (const AttackingType& x)
  {
    this->attacking_.set (x);
  }

  void TwoStageDeterrency::
  setAttacking (const AttackingOptional& x)
  {
    this->attacking_ = x;
  }

  void TwoStageDeterrency::
  setAttacking (::std::unique_ptr< AttackingType > x)
  {
    this->attacking_.set (std::move (x));
  }

  const TwoStageDeterrency::AttackingLogitOptional& TwoStageDeterrency::
  getAttackingLogit () const
  {
    return this->attackingLogit_;
  }

  TwoStageDeterrency::AttackingLogitOptional& TwoStageDeterrency::
  getAttackingLogit ()
  {
    return this->attackingLogit_;
  }

  void TwoStageDeterrency::
  setAttackingLogit (const AttackingLogitType& x)
  {
    this->attackingLogit_.set (x);
  }

  void TwoStageDeterrency::
  setAttackingLogit (const AttackingLogitOptional& x)
  {
    this->attackingLogit_ = x;
  }

  void TwoStageDeterrency::
  setAttackingLogit (::std::unique_ptr< AttackingLogitType > x)
  {
    this->attackingLogit_.set (std::move (x));
  }


  // Rate
  // 

  const Rate::TimeType& Rate::
  getTime () const
  {
    return this->time_.get ();
  }

  Rate::TimeType& Rate::
  getTime ()
  {
    return this->time_.get ();
  }

  void Rate::
  setTime (const TimeType& x)
  {
    this->time_.set (x);
  }

  void Rate::
  setTime (::std::unique_ptr< TimeType > x)
  {
    this->time_.set (std::move (x));
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace scnXml
{
  // Interventions
  //

  Interventions::
  Interventions (const NameType& name)
  : ::xml_schema::Type (),
    changeHS_ (this),
    changeEIR_ (this),
    importedInfections_ (this),
    insertR_0Case_ (this),
    uninfectVectors_ (this),
    vectorPop_ (this),
    vectorTrap_ (this),
    human_ (this),
    name_ (name, this)
  {
  }

  Interventions::
  Interventions (const Interventions& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    changeHS_ (x.changeHS_, f, this),
    changeEIR_ (x.changeEIR_, f, this),
    importedInfections_ (x.importedInfections_, f, this),
    insertR_0Case_ (x.insertR_0Case_, f, this),
    uninfectVectors_ (x.uninfectVectors_, f, this),
    vectorPop_ (x.vectorPop_, f, this),
    vectorTrap_ (x.vectorTrap_, f, this),
    human_ (x.human_, f, this),
    name_ (x.name_, f, this)
  {
  }

  Interventions::
  Interventions (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    changeHS_ (this),
    changeEIR_ (this),
    importedInfections_ (this),
    insertR_0Case_ (this),
    uninfectVectors_ (this),
    vectorPop_ (this),
    vectorTrap_ (this),
    human_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Interventions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // changeHS
      //
      if (n.name () == "changeHS" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ChangeHSType > r (
          ChangeHSTraits::create (i, f, this));

        if (!this->changeHS_)
        {
          this->changeHS_.set (::std::move (r));
          continue;
        }
      }

      // changeEIR
      //
      if (n.name () == "changeEIR" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ChangeEIRType > r (
          ChangeEIRTraits::create (i, f, this));

        if (!this->changeEIR_)
        {
          this->changeEIR_.set (::std::move (r));
          continue;
        }
      }

      // importedInfections
      //
      if (n.name () == "importedInfections" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ImportedInfectionsType > r (
          ImportedInfectionsTraits::create (i, f, this));

        if (!this->importedInfections_)
        {
          this->importedInfections_.set (::std::move (r));
          continue;
        }
      }

      // insertR_0Case
      //
      if (n.name () == "insertR_0Case" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< InsertR_0CaseType > r (
          InsertR_0CaseTraits::create (i, f, this));

        if (!this->insertR_0Case_)
        {
          this->insertR_0Case_.set (::std::move (r));
          continue;
        }
      }

      // uninfectVectors
      //
      if (n.name () == "uninfectVectors" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< UninfectVectorsType > r (
          UninfectVectorsTraits::create (i, f, this));

        if (!this->uninfectVectors_)
        {
          this->uninfectVectors_.set (::std::move (r));
          continue;
        }
      }

      // vectorPop
      //
      if (n.name () == "vectorPop" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< VectorPopType > r (
          VectorPopTraits::create (i, f, this));

        if (!this->vectorPop_)
        {
          this->vectorPop_.set (::std::move (r));
          continue;
        }
      }

      // vectorTrap
      //
      if (n.name () == "vectorTrap" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< VectorTrapType > r (
          VectorTrapTraits::create (i, f, this));

        if (!this->vectorTrap_)
        {
          this->vectorTrap_.set (::std::move (r));
          continue;
        }
      }

      // human
      //
      if (n.name () == "human" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< HumanType > r (
          HumanTraits::create (i, f, this));

        if (!this->human_)
        {
          this->human_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  Interventions* Interventions::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Interventions (*this, f, c);
  }

  Interventions& Interventions::
  operator= (const Interventions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->changeHS_ = x.changeHS_;
      this->changeEIR_ = x.changeEIR_;
      this->importedInfections_ = x.importedInfections_;
      this->insertR_0Case_ = x.insertR_0Case_;
      this->uninfectVectors_ = x.uninfectVectors_;
      this->vectorPop_ = x.vectorPop_;
      this->vectorTrap_ = x.vectorTrap_;
      this->human_ = x.human_;
      this->name_ = x.name_;
    }

    return *this;
  }

  Interventions::
  ~Interventions ()
  {
  }

  // HumanInterventions
  //

  HumanInterventions::
  HumanInterventions ()
  : ::xml_schema::Type (),
    component_ (this),
    deployment_ (this)
  {
  }

  HumanInterventions::
  HumanInterventions (const HumanInterventions& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    component_ (x.component_, f, this),
    deployment_ (x.deployment_, f, this)
  {
  }

  HumanInterventions::
  HumanInterventions (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    component_ (this),
    deployment_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void HumanInterventions::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // component
      //
      if (n.name () == "component" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ComponentType > r (
          ComponentTraits::create (i, f, this));

        this->component_.push_back (::std::move (r));
        continue;
      }

      // deployment
      //
      if (n.name () == "deployment" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DeploymentType > r (
          DeploymentTraits::create (i, f, this));

        this->deployment_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  HumanInterventions* HumanInterventions::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HumanInterventions (*this, f, c);
  }

  HumanInterventions& HumanInterventions::
  operator= (const HumanInterventions& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->component_ = x.component_;
      this->deployment_ = x.deployment_;
    }

    return *this;
  }

  HumanInterventions::
  ~HumanInterventions ()
  {
  }

  // HumanInterventionComponent
  //

  HumanInterventionComponent::
  HumanInterventionComponent (const IdType& id)
  : ::xml_schema::Type (),
    screen_ (this),
    treatSimple_ (this),
    treatPKPD_ (this),
    decisionTree_ (this),
    PEV_ (this),
    BSV_ (this),
    TBV_ (this),
    ITN_ (this),
    IRS_ (this),
    GVI_ (this),
    recruitmentOnly_ (this),
    clearImmunity_ (this),
    subPopRemoval_ (this),
    id_ (id, this),
    name_ (this)
  {
  }

  HumanInterventionComponent::
  HumanInterventionComponent (const HumanInterventionComponent& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    screen_ (x.screen_, f, this),
    treatSimple_ (x.treatSimple_, f, this),
    treatPKPD_ (x.treatPKPD_, f, this),
    decisionTree_ (x.decisionTree_, f, this),
    PEV_ (x.PEV_, f, this),
    BSV_ (x.BSV_, f, this),
    TBV_ (x.TBV_, f, this),
    ITN_ (x.ITN_, f, this),
    IRS_ (x.IRS_, f, this),
    GVI_ (x.GVI_, f, this),
    recruitmentOnly_ (x.recruitmentOnly_, f, this),
    clearImmunity_ (x.clearImmunity_, f, this),
    subPopRemoval_ (x.subPopRemoval_, f, this),
    id_ (x.id_, f, this),
    name_ (x.name_, f, this)
  {
  }

  HumanInterventionComponent::
  HumanInterventionComponent (const xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    screen_ (this),
    treatSimple_ (this),
    treatPKPD_ (this),
    decisionTree_ (this),
    PEV_ (this),
    BSV_ (this),
    TBV_ (this),
    ITN_ (this),
    IRS_ (this),
    GVI_ (this),
    recruitmentOnly_ (this),
    clearImmunity_ (this),
    subPopRemoval_ (this),
    id_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void HumanInterventionComponent::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // screen
      //
      if (n.name () == "screen" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ScreenType > r (
          ScreenTraits::create (i, f, this));

        if (!this->screen_)
        {
          this->screen_.set (::std::move (r));
          continue;
        }
      }

      // treatSimple
      //
      if (n.name () == "treatSimple" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TreatSimpleType > r (
          TreatSimpleTraits::create (i, f, this));

        if (!this->treatSimple_)
        {
          this->treatSimple_.set (::std::move (r));
          continue;
        }
      }

      // treatPKPD
      //
      if (n.name () == "treatPKPD" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TreatPKPDType > r (
          TreatPKPDTraits::create (i, f, this));

        if (!this->treatPKPD_)
        {
          this->treatPKPD_.set (::std::move (r));
          continue;
        }
      }

      // decisionTree
      //
      if (n.name () == "decisionTree" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DecisionTreeType > r (
          DecisionTreeTraits::create (i, f, this));

        if (!this->decisionTree_)
        {
          this->decisionTree_.set (::std::move (r));
          continue;
        }
      }

      // PEV
      //
      if (n.name () == "PEV" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PEVType > r (
          PEVTraits::create (i, f, this));

        if (!this->PEV_)
        {
          this->PEV_.set (::std::move (r));
          continue;
        }
      }

      // BSV
      //
      if (n.name () == "BSV" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< BSVType > r (
          BSVTraits::create (i, f, this));

        if (!this->BSV_)
        {
          this->BSV_.set (::std::move (r));
          continue;
        }
      }

      // TBV
      //
      if (n.name () == "TBV" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TBVType > r (
          TBVTraits::create (i, f, this));

        if (!this->TBV_)
        {
          this->TBV_.set (::std::move (r));
          continue;
        }
      }

      // ITN
      //
      if (n.name () == "ITN" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ITNType > r (
          ITNTraits::create (i, f, this));

        if (!this->ITN_)
        {
          this->ITN_.set (::std::move (r));
          continue;
        }
      }

      // IRS
      //
      if (n.name () == "IRS" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< IRSType > r (
          IRSTraits::create (i, f, this));

        if (!this->IRS_)
        {
          this->IRS_.set (::std::move (r));
          continue;
        }
      }

      // GVI
      //
      if (n.name () == "GVI" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< GVIType > r (
          GVITraits::create (i, f, this));

        if (!this->GVI_)
        {
          this->GVI_.set (::std::move (r));
          continue;
        }
      }

      // recruitmentOnly
      //
      if (n.name () == "recruitmentOnly" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< RecruitmentOnlyType > r (
          RecruitmentOnlyTraits::create (i, f, this));

        if (!this->recruitmentOnly_)
        {
          this->recruitmentOnly_.set (::std::move (r));
          continue;
        }
      }

      // clearImmunity
      //
      if (n.name () == "clearImmunity" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ClearImmunityType > r (
          ClearImmunityTraits::create (i, f, this));

        if (!this->clearImmunity_)
        {
          this->clearImmunity_.set (::std::move (r));
          continue;
        }
      }

      // subPopRemoval
      //
      if (n.name () == "subPopRemoval" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SubPopRemovalType > r (
          SubPopRemovalTraits::create (i, f, this));

        if (!this->subPopRemoval_)
        {
          this->subPopRemoval_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (IdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }
  }

  HumanInterventionComponent* HumanInterventionComponent::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class HumanInterventionComponent (*this, f, c);
  }

  HumanInterventionComponent& HumanInterventionComponent::
  operator= (const HumanInterventionComponent& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->screen_ = x.screen_;
      this->treatSimple_ = x.treatSimple_;
      this->treatPKPD_ = x.treatPKPD_;
      this->decisionTree_ = x.decisionTree_;
      this->PEV_ = x.PEV_;
      this->BSV_ = x.BSV_;
      this->TBV_ = x.TBV_;
      this->ITN_ = x.ITN_;
      this->IRS_ = x.IRS_;
      this->GVI_ = x.GVI_;
      this->recruitmentOnly_ = x.recruitmentOnly_;
      this->clearImmunity_ = x.clearImmunity_;
      this->subPopRemoval_ = x.subPopRemoval_;
      this->id_ = x.id_;
      this->name_ = x.name_;
    }

    return *this;
  }

  HumanInterventionComponent::
  ~HumanInterventionComponent ()
  {
  }

  // SubPopRemoval
  //

  SubPopRemoval::
  SubPopRemoval ()
  : ::xml_schema::Type (),
    onFirstBout_ (getOnFirstBoutDefaultValue (), this),
    onFirstTreatment_ (getOnFirstTreatmentDefaultValue (), this),
    onFirstInfection_ (getOnFirstInfectionDefaultValue (), this),
    afterYears_ (this)
  {
  }

  SubPopRemoval::
  SubPopRemoval (const SubPopRemoval& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    onFirstBout_ (x.onFirstBout_, f, this),
    onFirstTreatment_ (x.onFirstTreatment_, f, this),
    onFirstInfection_ (x.onFirstInfection_, f, this),
    afterYears_ (x.afterYears_, f, this)
  {
  }

  SubPopRemoval::
  SubPopRemoval (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    onFirstBout_ (this),
    onFirstTreatment_ (this),
    onFirstInfection_ (this),
    afterYears_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void SubPopRemoval::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "onFirstBout" && n.namespace_ ().empty ())
      {
        this->onFirstBout_.set (OnFirstBoutTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "onFirstTreatment" && n.namespace_ ().empty ())
      {
        this->onFirstTreatment_.set (OnFirstTreatmentTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "onFirstInfection" && n.namespace_ ().empty ())
      {
        this->onFirstInfection_.set (OnFirstInfectionTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "afterYears" && n.namespace_ ().empty ())
      {
        this->afterYears_.set (AfterYearsTraits::create (i, f, this));
        continue;
      }
    }

    if (!onFirstBout_.present ())
    {
      this->onFirstBout_.set (getOnFirstBoutDefaultValue ());
    }

    if (!onFirstTreatment_.present ())
    {
      this->onFirstTreatment_.set (getOnFirstTreatmentDefaultValue ());
    }

    if (!onFirstInfection_.present ())
    {
      this->onFirstInfection_.set (getOnFirstInfectionDefaultValue ());
    }
  }

  SubPopRemoval* SubPopRemoval::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SubPopRemoval (*this, f, c);
  }

  SubPopRemoval& SubPopRemoval::
  operator= (const SubPopRemoval& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->onFirstBout_ = x.onFirstBout_;
      this->onFirstTreatment_ = x.onFirstTreatment_;
      this->onFirstInfection_ = x.onFirstInfection_;
      this->afterYears_ = x.afterYears_;
    }

    return *this;
  }

  SubPopRemoval::
  ~SubPopRemoval ()
  {
  }

  // Screen
  //

  Screen::
  Screen (const DiagnosticType& diagnostic)
  : ::xml_schema::Type (),
    positive_ (this),
    negative_ (this),
    diagnostic_ (diagnostic, this)
  {
  }

  Screen::
  Screen (const Screen& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    positive_ (x.positive_, f, this),
    negative_ (x.negative_, f, this),
    diagnostic_ (x.diagnostic_, f, this)
  {
  }

  Screen::
  Screen (const xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    positive_ (this),
    negative_ (this),
    diagnostic_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Screen::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // positive
      //
      if (n.name () == "positive" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PositiveType > r (
          PositiveTraits::create (i, f, this));

        this->positive_.push_back (::std::move (r));
        continue;
      }

      // negative
      //
      if (n.name () == "negative" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< NegativeType > r (
          NegativeTraits::create (i, f, this));

        this->negative_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "diagnostic" && n.namespace_ ().empty ())
      {
        this->diagnostic_.set (DiagnosticTraits::create (i, f, this));
        continue;
      }
    }

    if (!diagnostic_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "diagnostic",
        "");
    }
  }

  Screen* Screen::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Screen (*this, f, c);
  }

  Screen& Screen::
  operator= (const Screen& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->positive_ = x.positive_;
      this->negative_ = x.negative_;
      this->diagnostic_ = x.diagnostic_;
    }

    return *this;
  }

  Screen::
  ~Screen ()
  {
  }

  // VectorIntervention
  //

  VectorIntervention::
  VectorIntervention (const DescriptionType& description,
                      const NameType& name)
  : ::xml_schema::Type (),
    description_ (description, this),
    timed_ (this),
    name_ (name, this)
  {
  }

  VectorIntervention::
  VectorIntervention (::std::unique_ptr< DescriptionType > description,
                      const NameType& name)
  : ::xml_schema::Type (),
    description_ (std::move (description), this),
    timed_ (this),
    name_ (name, this)
  {
  }

  VectorIntervention::
  VectorIntervention (const VectorIntervention& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    description_ (x.description_, f, this),
    timed_ (x.timed_, f, this),
    name_ (x.name_, f, this)
  {
  }

  VectorIntervention::
  VectorIntervention (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    description_ (this),
    timed_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void VectorIntervention::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // description
      //
      if (n.name () == "description" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DescriptionType > r (
          DescriptionTraits::create (i, f, this));

        if (!description_.present ())
        {
          this->description_.set (::std::move (r));
          continue;
        }
      }

      // timed
      //
      if (n.name () == "timed" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TimedType > r (
          TimedTraits::create (i, f, this));

        if (!this->timed_)
        {
          this->timed_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!description_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "description",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }

    if (!name_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "name",
        "");
    }
  }

  VectorIntervention* VectorIntervention::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VectorIntervention (*this, f, c);
  }

  VectorIntervention& VectorIntervention::
  operator= (const VectorIntervention& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->description_ = x.description_;
      this->timed_ = x.timed_;
      this->name_ = x.name_;
    }

    return *this;
  }

  VectorIntervention::
  ~VectorIntervention ()
  {
  }

  // VectorTrap
  //

  VectorTrap::
  VectorTrap ()
  : ::xml_schema::Type (),
    description_ (this),
    timed_ (this),
    name_ (this)
  {
  }

  VectorTrap::
  VectorTrap (const VectorTrap& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    description_ (x.description_, f, this),
    timed_ (x.timed_, f, this),
    name_ (x.name_, f, this)
  {
  }

  VectorTrap::
  VectorTrap (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    description_ (this),
    timed_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void VectorTrap::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // description
      //
      if (n.name () == "description" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DescriptionType > r (
          DescriptionTraits::create (i, f, this));

        this->description_.push_back (::std::move (r));
        continue;
      }

      // timed
      //
      if (n.name () == "timed" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TimedType > r (
          TimedTraits::create (i, f, this));

        if (!this->timed_)
        {
          this->timed_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  VectorTrap* VectorTrap::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VectorTrap (*this, f, c);
  }

  VectorTrap& VectorTrap::
  operator= (const VectorTrap& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->description_ = x.description_;
      this->timed_ = x.timed_;
      this->name_ = x.name_;
    }

    return *this;
  }

  VectorTrap::
  ~VectorTrap ()
  {
  }

  // TimedBase
  //

  TimedBase::
  TimedBase (const TimeType& time)
  : ::xml_schema::Type (),
    time_ (time, this)
  {
  }

  TimedBase::
  TimedBase (const TimedBase& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    time_ (x.time_, f, this)
  {
  }

  TimedBase::
  TimedBase (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    time_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void TimedBase::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        this->time_.set (TimeTraits::create (i, f, this));
        continue;
      }
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time",
        "");
    }
  }

  TimedBase* TimedBase::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimedBase (*this, f, c);
  }

  TimedBase& TimedBase::
  operator= (const TimedBase& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->time_ = x.time_;
    }

    return *this;
  }

  TimedBase::
  ~TimedBase ()
  {
  }

  // DeploymentBase
  //

  DeploymentBase::
  DeploymentBase (const CoverageType& coverage)
  : ::xml_schema::Type (),
    coverage_ (coverage, this),
    vaccMinPrevDoses_ (this),
    vaccMaxCumDoses_ (this)
  {
  }

  DeploymentBase::
  DeploymentBase (const DeploymentBase& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    coverage_ (x.coverage_, f, this),
    vaccMinPrevDoses_ (x.vaccMinPrevDoses_, f, this),
    vaccMaxCumDoses_ (x.vaccMaxCumDoses_, f, this)
  {
  }

  DeploymentBase::
  DeploymentBase (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    coverage_ (this),
    vaccMinPrevDoses_ (this),
    vaccMaxCumDoses_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void DeploymentBase::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "coverage" && n.namespace_ ().empty ())
      {
        this->coverage_.set (CoverageTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "vaccMinPrevDoses" && n.namespace_ ().empty ())
      {
        this->vaccMinPrevDoses_.set (VaccMinPrevDosesTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "vaccMaxCumDoses" && n.namespace_ ().empty ())
      {
        this->vaccMaxCumDoses_.set (VaccMaxCumDosesTraits::create (i, f, this));
        continue;
      }
    }

    if (!coverage_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "coverage",
        "");
    }
  }

  DeploymentBase* DeploymentBase::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class DeploymentBase (*this, f, c);
  }

  DeploymentBase& DeploymentBase::
  operator= (const DeploymentBase& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->coverage_ = x.coverage_;
      this->vaccMinPrevDoses_ = x.vaccMinPrevDoses_;
      this->vaccMaxCumDoses_ = x.vaccMaxCumDoses_;
    }

    return *this;
  }

  DeploymentBase::
  ~DeploymentBase ()
  {
  }

  // MassDeployment
  //

  MassDeployment::
  MassDeployment (const CoverageType& coverage,
                  const TimeType& time)
  : ::scnXml::DeploymentBase (coverage),
    time_ (time, this),
    maxAge_ (this),
    minAge_ (getMinAgeDefaultValue (), this),
    repeatStep_ (this),
    repeatEnd_ (this)
  {
  }

  MassDeployment::
  MassDeployment (const MassDeployment& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::scnXml::DeploymentBase (x, f, c),
    time_ (x.time_, f, this),
    maxAge_ (x.maxAge_, f, this),
    minAge_ (x.minAge_, f, this),
    repeatStep_ (x.repeatStep_, f, this),
    repeatEnd_ (x.repeatEnd_, f, this)
  {
  }

  MassDeployment::
  MassDeployment (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::scnXml::DeploymentBase (e, f | ::xml_schema::Flags::base, c),
    time_ (this),
    maxAge_ (this),
    minAge_ (this),
    repeatStep_ (this),
    repeatEnd_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void MassDeployment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::DeploymentBase::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        this->time_.set (TimeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxAge" && n.namespace_ ().empty ())
      {
        this->maxAge_.set (MaxAgeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "minAge" && n.namespace_ ().empty ())
      {
        this->minAge_.set (MinAgeTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "repeatStep" && n.namespace_ ().empty ())
      {
        this->repeatStep_.set (RepeatStepTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "repeatEnd" && n.namespace_ ().empty ())
      {
        this->repeatEnd_.set (RepeatEndTraits::create (i, f, this));
        continue;
      }
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time",
        "");
    }

    if (!minAge_.present ())
    {
      this->minAge_.set (getMinAgeDefaultValue ());
    }
  }

  MassDeployment* MassDeployment::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MassDeployment (*this, f, c);
  }

  MassDeployment& MassDeployment::
  operator= (const MassDeployment& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::DeploymentBase& > (*this) = x;
      this->time_ = x.time_;
      this->maxAge_ = x.maxAge_;
      this->minAge_ = x.minAge_;
      this->repeatStep_ = x.repeatStep_;
      this->repeatEnd_ = x.repeatEnd_;
    }

    return *this;
  }

  MassDeployment::
  ~MassDeployment ()
  {
  }

  // ContinuousList
  //

  ContinuousList::
  ContinuousList ()
  : ::xml_schema::Type (),
    restrictToSubPop_ (this),
    deploy_ (this)
  {
  }

  ContinuousList::
  ContinuousList (const ContinuousList& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    restrictToSubPop_ (x.restrictToSubPop_, f, this),
    deploy_ (x.deploy_, f, this)
  {
  }

  ContinuousList::
  ContinuousList (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    restrictToSubPop_ (this),
    deploy_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ContinuousList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // restrictToSubPop
      //
      if (n.name () == "restrictToSubPop" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< RestrictToSubPopType > r (
          RestrictToSubPopTraits::create (i, f, this));

        if (!this->restrictToSubPop_)
        {
          this->restrictToSubPop_.set (::std::move (r));
          continue;
        }
      }

      // deploy
      //
      if (n.name () == "deploy" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DeployType > r (
          DeployTraits::create (i, f, this));

        this->deploy_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  ContinuousList* ContinuousList::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ContinuousList (*this, f, c);
  }

  ContinuousList& ContinuousList::
  operator= (const ContinuousList& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->restrictToSubPop_ = x.restrictToSubPop_;
      this->deploy_ = x.deploy_;
    }

    return *this;
  }

  ContinuousList::
  ~ContinuousList ()
  {
  }

  // ContinuousDeployment
  //

  ContinuousDeployment::
  ContinuousDeployment (const CoverageType& coverage,
                        const TargetAgeYrsType& targetAgeYrs)
  : ::scnXml::DeploymentBase (coverage),
    targetAgeYrs_ (targetAgeYrs, this),
    begin_ (this),
    end_ (this)
  {
  }

  ContinuousDeployment::
  ContinuousDeployment (const ContinuousDeployment& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::scnXml::DeploymentBase (x, f, c),
    targetAgeYrs_ (x.targetAgeYrs_, f, this),
    begin_ (x.begin_, f, this),
    end_ (x.end_, f, this)
  {
  }

  ContinuousDeployment::
  ContinuousDeployment (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::scnXml::DeploymentBase (e, f | ::xml_schema::Flags::base, c),
    targetAgeYrs_ (this),
    begin_ (this),
    end_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ContinuousDeployment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::DeploymentBase::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "targetAgeYrs" && n.namespace_ ().empty ())
      {
        this->targetAgeYrs_.set (TargetAgeYrsTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "begin" && n.namespace_ ().empty ())
      {
        this->begin_.set (BeginTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "end" && n.namespace_ ().empty ())
      {
        this->end_.set (EndTraits::create (i, f, this));
        continue;
      }
    }

    if (!targetAgeYrs_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "targetAgeYrs",
        "");
    }
  }

  ContinuousDeployment* ContinuousDeployment::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ContinuousDeployment (*this, f, c);
  }

  ContinuousDeployment& ContinuousDeployment::
  operator= (const ContinuousDeployment& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::DeploymentBase& > (*this) = x;
      this->targetAgeYrs_ = x.targetAgeYrs_;
      this->begin_ = x.begin_;
      this->end_ = x.end_;
    }

    return *this;
  }

  ContinuousDeployment::
  ~ContinuousDeployment ()
  {
  }

  // TimedBaseList
  //

  TimedBaseList::
  TimedBaseList ()
  : ::xml_schema::Type (),
    deploy_ (this)
  {
  }

  TimedBaseList::
  TimedBaseList (const TimedBaseList& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    deploy_ (x.deploy_, f, this)
  {
  }

  TimedBaseList::
  TimedBaseList (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    deploy_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TimedBaseList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // deploy
      //
      if (n.name () == "deploy" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DeployType > r (
          DeployTraits::create (i, f, this));

        this->deploy_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  TimedBaseList* TimedBaseList::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimedBaseList (*this, f, c);
  }

  TimedBaseList& TimedBaseList::
  operator= (const TimedBaseList& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->deploy_ = x.deploy_;
    }

    return *this;
  }

  TimedBaseList::
  ~TimedBaseList ()
  {
  }

  // MassListWithCum
  //

  MassListWithCum::
  MassListWithCum ()
  : ::xml_schema::Type (),
    restrictToSubPop_ (this),
    cumulativeCoverage_ (this),
    deploy_ (this)
  {
  }

  MassListWithCum::
  MassListWithCum (const MassListWithCum& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    restrictToSubPop_ (x.restrictToSubPop_, f, this),
    cumulativeCoverage_ (x.cumulativeCoverage_, f, this),
    deploy_ (x.deploy_, f, this)
  {
  }

  MassListWithCum::
  MassListWithCum (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    restrictToSubPop_ (this),
    cumulativeCoverage_ (this),
    deploy_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void MassListWithCum::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // restrictToSubPop
      //
      if (n.name () == "restrictToSubPop" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< RestrictToSubPopType > r (
          RestrictToSubPopTraits::create (i, f, this));

        if (!this->restrictToSubPop_)
        {
          this->restrictToSubPop_.set (::std::move (r));
          continue;
        }
      }

      // cumulativeCoverage
      //
      if (n.name () == "cumulativeCoverage" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< CumulativeCoverageType > r (
          CumulativeCoverageTraits::create (i, f, this));

        if (!this->cumulativeCoverage_)
        {
          this->cumulativeCoverage_.set (::std::move (r));
          continue;
        }
      }

      // deploy
      //
      if (n.name () == "deploy" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DeployType > r (
          DeployTraits::create (i, f, this));

        this->deploy_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  MassListWithCum* MassListWithCum::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class MassListWithCum (*this, f, c);
  }

  MassListWithCum& MassListWithCum::
  operator= (const MassListWithCum& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->restrictToSubPop_ = x.restrictToSubPop_;
      this->cumulativeCoverage_ = x.cumulativeCoverage_;
      this->deploy_ = x.deploy_;
    }

    return *this;
  }

  MassListWithCum::
  ~MassListWithCum ()
  {
  }

  // RestrictToSubPop
  //

  RestrictToSubPop::
  RestrictToSubPop (const IdType& id)
  : ::xml_schema::Type (),
    id_ (id, this),
    complement_ (getComplementDefaultValue (), this)
  {
  }

  RestrictToSubPop::
  RestrictToSubPop (const RestrictToSubPop& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    id_ (x.id_, f, this),
    complement_ (x.complement_, f, this)
  {
  }

  RestrictToSubPop::
  RestrictToSubPop (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    id_ (this),
    complement_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void RestrictToSubPop::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        this->id_.set (IdTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "complement" && n.namespace_ ().empty ())
      {
        this->complement_.set (ComplementTraits::create (i, f, this));
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!complement_.present ())
    {
      this->complement_.set (getComplementDefaultValue ());
    }
  }

  RestrictToSubPop* RestrictToSubPop::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RestrictToSubPop (*this, f, c);
  }

  RestrictToSubPop& RestrictToSubPop::
  operator= (const RestrictToSubPop& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->id_ = x.id_;
      this->complement_ = x.complement_;
    }

    return *this;
  }

  RestrictToSubPop::
  ~RestrictToSubPop ()
  {
  }

  // VaccineDescription
  //

  VaccineDescription::
  VaccineDescription (const DecayType& decay,
                      const EfficacyBType& efficacyB)
  : ::xml_schema::Type (),
    decay_ (decay, this),
    efficacyB_ (efficacyB, this),
    initialEfficacy_ (this)
  {
  }

  VaccineDescription::
  VaccineDescription (::std::unique_ptr< DecayType > decay,
                      ::std::unique_ptr< EfficacyBType > efficacyB)
  : ::xml_schema::Type (),
    decay_ (std::move (decay), this),
    efficacyB_ (std::move (efficacyB), this),
    initialEfficacy_ (this)
  {
  }

  VaccineDescription::
  VaccineDescription (const VaccineDescription& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    decay_ (x.decay_, f, this),
    efficacyB_ (x.efficacyB_, f, this),
    initialEfficacy_ (x.initialEfficacy_, f, this)
  {
  }

  VaccineDescription::
  VaccineDescription (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    decay_ (this),
    efficacyB_ (this),
    initialEfficacy_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VaccineDescription::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // decay
      //
      if (n.name () == "decay" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DecayType > r (
          DecayTraits::create (i, f, this));

        if (!decay_.present ())
        {
          this->decay_.set (::std::move (r));
          continue;
        }
      }

      // efficacyB
      //
      if (n.name () == "efficacyB" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< EfficacyBType > r (
          EfficacyBTraits::create (i, f, this));

        if (!efficacyB_.present ())
        {
          this->efficacyB_.set (::std::move (r));
          continue;
        }
      }

      // initialEfficacy
      //
      if (n.name () == "initialEfficacy" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< InitialEfficacyType > r (
          InitialEfficacyTraits::create (i, f, this));

        this->initialEfficacy_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!decay_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "decay",
        "");
    }

    if (!efficacyB_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "efficacyB",
        "");
    }
  }

  VaccineDescription* VaccineDescription::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VaccineDescription (*this, f, c);
  }

  VaccineDescription& VaccineDescription::
  operator= (const VaccineDescription& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->decay_ = x.decay_;
      this->efficacyB_ = x.efficacyB_;
      this->initialEfficacy_ = x.initialEfficacy_;
    }

    return *this;
  }

  VaccineDescription::
  ~VaccineDescription ()
  {
  }

  // ITNDescription
  //

  ITNDescription::
  ITNDescription (const HoleRateType& holeRate,
                  const RipRateType& ripRate,
                  const RipFactorType& ripFactor,
                  const InitialInsecticideType& initialInsecticide,
                  const InsecticideDecayType& insecticideDecay,
                  const AttritionOfNetsType& attritionOfNets)
  : ::xml_schema::Type (),
    usage_ (this),
    holeRate_ (holeRate, this),
    ripRate_ (ripRate, this),
    ripFactor_ (ripFactor, this),
    initialInsecticide_ (initialInsecticide, this),
    insecticideDecay_ (insecticideDecay, this),
    attritionOfNets_ (attritionOfNets, this),
    anophelesParams_ (this)
  {
  }

  ITNDescription::
  ITNDescription (::std::unique_ptr< HoleRateType > holeRate,
                  ::std::unique_ptr< RipRateType > ripRate,
                  ::std::unique_ptr< RipFactorType > ripFactor,
                  ::std::unique_ptr< InitialInsecticideType > initialInsecticide,
                  ::std::unique_ptr< InsecticideDecayType > insecticideDecay,
                  ::std::unique_ptr< AttritionOfNetsType > attritionOfNets)
  : ::xml_schema::Type (),
    usage_ (this),
    holeRate_ (std::move (holeRate), this),
    ripRate_ (std::move (ripRate), this),
    ripFactor_ (std::move (ripFactor), this),
    initialInsecticide_ (std::move (initialInsecticide), this),
    insecticideDecay_ (std::move (insecticideDecay), this),
    attritionOfNets_ (std::move (attritionOfNets), this),
    anophelesParams_ (this)
  {
  }

  ITNDescription::
  ITNDescription (const ITNDescription& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    usage_ (x.usage_, f, this),
    holeRate_ (x.holeRate_, f, this),
    ripRate_ (x.ripRate_, f, this),
    ripFactor_ (x.ripFactor_, f, this),
    initialInsecticide_ (x.initialInsecticide_, f, this),
    insecticideDecay_ (x.insecticideDecay_, f, this),
    attritionOfNets_ (x.attritionOfNets_, f, this),
    anophelesParams_ (x.anophelesParams_, f, this)
  {
  }

  ITNDescription::
  ITNDescription (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    usage_ (this),
    holeRate_ (this),
    ripRate_ (this),
    ripFactor_ (this),
    initialInsecticide_ (this),
    insecticideDecay_ (this),
    attritionOfNets_ (this),
    anophelesParams_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void ITNDescription::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // usage
      //
      if (n.name () == "usage" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< UsageType > r (
          UsageTraits::create (i, f, this));

        if (!this->usage_)
        {
          this->usage_.set (::std::move (r));
          continue;
        }
      }

      // holeRate
      //
      if (n.name () == "holeRate" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< HoleRateType > r (
          HoleRateTraits::create (i, f, this));

        if (!holeRate_.present ())
        {
          this->holeRate_.set (::std::move (r));
          continue;
        }
      }

      // ripRate
      //
      if (n.name () == "ripRate" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< RipRateType > r (
          RipRateTraits::create (i, f, this));

        if (!ripRate_.present ())
        {
          this->ripRate_.set (::std::move (r));
          continue;
        }
      }

      // ripFactor
      //
      if (n.name () == "ripFactor" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< RipFactorType > r (
          RipFactorTraits::create (i, f, this));

        if (!ripFactor_.present ())
        {
          this->ripFactor_.set (::std::move (r));
          continue;
        }
      }

      // initialInsecticide
      //
      if (n.name () == "initialInsecticide" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< InitialInsecticideType > r (
          InitialInsecticideTraits::create (i, f, this));

        if (!initialInsecticide_.present ())
        {
          this->initialInsecticide_.set (::std::move (r));
          continue;
        }
      }

      // insecticideDecay
      //
      if (n.name () == "insecticideDecay" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< InsecticideDecayType > r (
          InsecticideDecayTraits::create (i, f, this));

        if (!insecticideDecay_.present ())
        {
          this->insecticideDecay_.set (::std::move (r));
          continue;
        }
      }

      // attritionOfNets
      //
      if (n.name () == "attritionOfNets" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AttritionOfNetsType > r (
          AttritionOfNetsTraits::create (i, f, this));

        if (!attritionOfNets_.present ())
        {
          this->attritionOfNets_.set (::std::move (r));
          continue;
        }
      }

      // anophelesParams
      //
      if (n.name () == "anophelesParams" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AnophelesParamsType > r (
          AnophelesParamsTraits::create (i, f, this));

        this->anophelesParams_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!holeRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "holeRate",
        "");
    }

    if (!ripRate_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ripRate",
        "");
    }

    if (!ripFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "ripFactor",
        "");
    }

    if (!initialInsecticide_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "initialInsecticide",
        "");
    }

    if (!insecticideDecay_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "insecticideDecay",
        "");
    }

    if (!attritionOfNets_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "attritionOfNets",
        "");
    }
  }

  ITNDescription* ITNDescription::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ITNDescription (*this, f, c);
  }

  ITNDescription& ITNDescription::
  operator= (const ITNDescription& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->usage_ = x.usage_;
      this->holeRate_ = x.holeRate_;
      this->ripRate_ = x.ripRate_;
      this->ripFactor_ = x.ripFactor_;
      this->initialInsecticide_ = x.initialInsecticide_;
      this->insecticideDecay_ = x.insecticideDecay_;
      this->attritionOfNets_ = x.attritionOfNets_;
      this->anophelesParams_ = x.anophelesParams_;
    }

    return *this;
  }

  ITNDescription::
  ~ITNDescription ()
  {
  }

  // GVIDescription
  //

  GVIDescription::
  GVIDescription (const DecayType& decay)
  : ::xml_schema::Type (),
    usage_ (this),
    decay_ (decay, this),
    anophelesParams_ (this)
  {
  }

  GVIDescription::
  GVIDescription (::std::unique_ptr< DecayType > decay)
  : ::xml_schema::Type (),
    usage_ (this),
    decay_ (std::move (decay), this),
    anophelesParams_ (this)
  {
  }

  GVIDescription::
  GVIDescription (const GVIDescription& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    usage_ (x.usage_, f, this),
    decay_ (x.decay_, f, this),
    anophelesParams_ (x.anophelesParams_, f, this)
  {
  }

  GVIDescription::
  GVIDescription (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    usage_ (this),
    decay_ (this),
    anophelesParams_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void GVIDescription::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // usage
      //
      if (n.name () == "usage" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< UsageType > r (
          UsageTraits::create (i, f, this));

        if (!this->usage_)
        {
          this->usage_.set (::std::move (r));
          continue;
        }
      }

      // decay
      //
      if (n.name () == "decay" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DecayType > r (
          DecayTraits::create (i, f, this));

        if (!decay_.present ())
        {
          this->decay_.set (::std::move (r));
          continue;
        }
      }

      // anophelesParams
      //
      if (n.name () == "anophelesParams" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AnophelesParamsType > r (
          AnophelesParamsTraits::create (i, f, this));

        this->anophelesParams_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!decay_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "decay",
        "");
    }
  }

  GVIDescription* GVIDescription::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class GVIDescription (*this, f, c);
  }

  GVIDescription& GVIDescription::
  operator= (const GVIDescription& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->usage_ = x.usage_;
      this->decay_ = x.decay_;
      this->anophelesParams_ = x.anophelesParams_;
    }

    return *this;
  }

  GVIDescription::
  ~GVIDescription ()
  {
  }

  // IRSDescription
  //

  IRSDescription::
  IRSDescription (const InitialInsecticideType& initialInsecticide,
                  const InsecticideDecayType& insecticideDecay)
  : ::xml_schema::Type (),
    usage_ (this),
    initialInsecticide_ (initialInsecticide, this),
    insecticideDecay_ (insecticideDecay, this),
    anophelesParams_ (this)
  {
  }

  IRSDescription::
  IRSDescription (::std::unique_ptr< InitialInsecticideType > initialInsecticide,
                  ::std::unique_ptr< InsecticideDecayType > insecticideDecay)
  : ::xml_schema::Type (),
    usage_ (this),
    initialInsecticide_ (std::move (initialInsecticide), this),
    insecticideDecay_ (std::move (insecticideDecay), this),
    anophelesParams_ (this)
  {
  }

  IRSDescription::
  IRSDescription (const IRSDescription& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    usage_ (x.usage_, f, this),
    initialInsecticide_ (x.initialInsecticide_, f, this),
    insecticideDecay_ (x.insecticideDecay_, f, this),
    anophelesParams_ (x.anophelesParams_, f, this)
  {
  }

  IRSDescription::
  IRSDescription (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    usage_ (this),
    initialInsecticide_ (this),
    insecticideDecay_ (this),
    anophelesParams_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void IRSDescription::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // usage
      //
      if (n.name () == "usage" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< UsageType > r (
          UsageTraits::create (i, f, this));

        if (!this->usage_)
        {
          this->usage_.set (::std::move (r));
          continue;
        }
      }

      // initialInsecticide
      //
      if (n.name () == "initialInsecticide" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< InitialInsecticideType > r (
          InitialInsecticideTraits::create (i, f, this));

        if (!initialInsecticide_.present ())
        {
          this->initialInsecticide_.set (::std::move (r));
          continue;
        }
      }

      // insecticideDecay
      //
      if (n.name () == "insecticideDecay" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< InsecticideDecayType > r (
          InsecticideDecayTraits::create (i, f, this));

        if (!insecticideDecay_.present ())
        {
          this->insecticideDecay_.set (::std::move (r));
          continue;
        }
      }

      // anophelesParams
      //
      if (n.name () == "anophelesParams" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AnophelesParamsType > r (
          AnophelesParamsTraits::create (i, f, this));

        this->anophelesParams_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    if (!initialInsecticide_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "initialInsecticide",
        "");
    }

    if (!insecticideDecay_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "insecticideDecay",
        "");
    }
  }

  IRSDescription* IRSDescription::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IRSDescription (*this, f, c);
  }

  IRSDescription& IRSDescription::
  operator= (const IRSDescription& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->usage_ = x.usage_;
      this->initialInsecticide_ = x.initialInsecticide_;
      this->insecticideDecay_ = x.insecticideDecay_;
      this->anophelesParams_ = x.anophelesParams_;
    }

    return *this;
  }

  IRSDescription::
  ~IRSDescription ()
  {
  }

  // IRSDeterrency
  //

  IRSDeterrency::
  IRSDeterrency (const InsecticideFactorType& insecticideFactor,
                 const InsecticideScalingFactorType& insecticideScalingFactor)
  : ::xml_schema::Type (),
    insecticideFactor_ (insecticideFactor, this),
    insecticideScalingFactor_ (insecticideScalingFactor, this)
  {
  }

  IRSDeterrency::
  IRSDeterrency (const IRSDeterrency& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    insecticideFactor_ (x.insecticideFactor_, f, this),
    insecticideScalingFactor_ (x.insecticideScalingFactor_, f, this)
  {
  }

  IRSDeterrency::
  IRSDeterrency (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    insecticideFactor_ (this),
    insecticideScalingFactor_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void IRSDeterrency::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "insecticideFactor" && n.namespace_ ().empty ())
      {
        this->insecticideFactor_.set (InsecticideFactorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "insecticideScalingFactor" && n.namespace_ ().empty ())
      {
        this->insecticideScalingFactor_.set (InsecticideScalingFactorTraits::create (i, f, this));
        continue;
      }
    }

    if (!insecticideFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "insecticideFactor",
        "");
    }

    if (!insecticideScalingFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "insecticideScalingFactor",
        "");
    }
  }

  IRSDeterrency* IRSDeterrency::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IRSDeterrency (*this, f, c);
  }

  IRSDeterrency& IRSDeterrency::
  operator= (const IRSDeterrency& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->insecticideFactor_ = x.insecticideFactor_;
      this->insecticideScalingFactor_ = x.insecticideScalingFactor_;
    }

    return *this;
  }

  IRSDeterrency::
  ~IRSDeterrency ()
  {
  }

  // ITNEnteringDeterrencyLogit
  //

  ITNEnteringDeterrencyLogit::
  ITNEnteringDeterrencyLogit (const BaseFactorType& baseFactor,
                              const InsecticideFactorType& insecticideFactor)
  : ::xml_schema::Type (),
    baseFactor_ (baseFactor, this),
    insecticideFactor_ (insecticideFactor, this)
  {
  }

  ITNEnteringDeterrencyLogit::
  ITNEnteringDeterrencyLogit (const ITNEnteringDeterrencyLogit& x,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    baseFactor_ (x.baseFactor_, f, this),
    insecticideFactor_ (x.insecticideFactor_, f, this)
  {
  }

  ITNEnteringDeterrencyLogit::
  ITNEnteringDeterrencyLogit (const xercesc::DOMElement& e,
                              ::xml_schema::Flags f,
                              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    baseFactor_ (this),
    insecticideFactor_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ITNEnteringDeterrencyLogit::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "baseFactor" && n.namespace_ ().empty ())
      {
        this->baseFactor_.set (BaseFactorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "insecticideFactor" && n.namespace_ ().empty ())
      {
        this->insecticideFactor_.set (InsecticideFactorTraits::create (i, f, this));
        continue;
      }
    }

    if (!baseFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "baseFactor",
        "");
    }

    if (!insecticideFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "insecticideFactor",
        "");
    }
  }

  ITNEnteringDeterrencyLogit* ITNEnteringDeterrencyLogit::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ITNEnteringDeterrencyLogit (*this, f, c);
  }

  ITNEnteringDeterrencyLogit& ITNEnteringDeterrencyLogit::
  operator= (const ITNEnteringDeterrencyLogit& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->baseFactor_ = x.baseFactor_;
      this->insecticideFactor_ = x.insecticideFactor_;
    }

    return *this;
  }

  ITNEnteringDeterrencyLogit::
  ~ITNEnteringDeterrencyLogit ()
  {
  }

  // IRSKillingEffect
  //

  IRSKillingEffect::
  IRSKillingEffect (const InsecticideFactorType& insecticideFactor,
                    const InsecticideScalingFactorType& insecticideScalingFactor,
                    const BaseFactorType& baseFactor)
  : ::scnXml::IRSDeterrency (insecticideFactor,
                             insecticideScalingFactor),
    baseFactor_ (baseFactor, this)
  {
  }

  IRSKillingEffect::
  IRSKillingEffect (const IRSKillingEffect& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::scnXml::IRSDeterrency (x, f, c),
    baseFactor_ (x.baseFactor_, f, this)
  {
  }

  IRSKillingEffect::
  IRSKillingEffect (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::scnXml::IRSDeterrency (e, f | ::xml_schema::Flags::base, c),
    baseFactor_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void IRSKillingEffect::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::IRSDeterrency::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "baseFactor" && n.namespace_ ().empty ())
      {
        this->baseFactor_.set (BaseFactorTraits::create (i, f, this));
        continue;
      }
    }

    if (!baseFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "baseFactor",
        "");
    }
  }

  IRSKillingEffect* IRSKillingEffect::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class IRSKillingEffect (*this, f, c);
  }

  IRSKillingEffect& IRSKillingEffect::
  operator= (const IRSKillingEffect& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::IRSDeterrency& > (*this) = x;
      this->baseFactor_ = x.baseFactor_;
    }

    return *this;
  }

  IRSKillingEffect::
  ~IRSKillingEffect ()
  {
  }

  // ITNDeterrency
  //

  ITNDeterrency::
  ITNDeterrency (const InsecticideFactorType& insecticideFactor,
                 const InsecticideScalingFactorType& insecticideScalingFactor,
                 const HoleFactorType& holeFactor,
                 const InteractionFactorType& interactionFactor,
                 const HoleScalingFactorType& holeScalingFactor)
  : ::scnXml::IRSDeterrency (insecticideFactor,
                             insecticideScalingFactor),
    holeFactor_ (holeFactor, this),
    interactionFactor_ (interactionFactor, this),
    holeScalingFactor_ (holeScalingFactor, this)
  {
  }

  ITNDeterrency::
  ITNDeterrency (const ITNDeterrency& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::scnXml::IRSDeterrency (x, f, c),
    holeFactor_ (x.holeFactor_, f, this),
    interactionFactor_ (x.interactionFactor_, f, this),
    holeScalingFactor_ (x.holeScalingFactor_, f, this)
  {
  }

  ITNDeterrency::
  ITNDeterrency (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::scnXml::IRSDeterrency (e, f | ::xml_schema::Flags::base, c),
    holeFactor_ (this),
    interactionFactor_ (this),
    holeScalingFactor_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ITNDeterrency::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::IRSDeterrency::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "holeFactor" && n.namespace_ ().empty ())
      {
        this->holeFactor_.set (HoleFactorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "interactionFactor" && n.namespace_ ().empty ())
      {
        this->interactionFactor_.set (InteractionFactorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "holeScalingFactor" && n.namespace_ ().empty ())
      {
        this->holeScalingFactor_.set (HoleScalingFactorTraits::create (i, f, this));
        continue;
      }
    }

    if (!holeFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "holeFactor",
        "");
    }

    if (!interactionFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "interactionFactor",
        "");
    }

    if (!holeScalingFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "holeScalingFactor",
        "");
    }
  }

  ITNDeterrency* ITNDeterrency::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ITNDeterrency (*this, f, c);
  }

  ITNDeterrency& ITNDeterrency::
  operator= (const ITNDeterrency& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::IRSDeterrency& > (*this) = x;
      this->holeFactor_ = x.holeFactor_;
      this->interactionFactor_ = x.interactionFactor_;
      this->holeScalingFactor_ = x.holeScalingFactor_;
    }

    return *this;
  }

  ITNDeterrency::
  ~ITNDeterrency ()
  {
  }

  // ITNKillingEffect
  //

  ITNKillingEffect::
  ITNKillingEffect (const InsecticideFactorType& insecticideFactor,
                    const InsecticideScalingFactorType& insecticideScalingFactor,
                    const HoleFactorType& holeFactor,
                    const InteractionFactorType& interactionFactor,
                    const HoleScalingFactorType& holeScalingFactor,
                    const BaseFactorType& baseFactor)
  : ::scnXml::ITNDeterrency (insecticideFactor,
                             insecticideScalingFactor,
                             holeFactor,
                             interactionFactor,
                             holeScalingFactor),
    baseFactor_ (baseFactor, this)
  {
  }

  ITNKillingEffect::
  ITNKillingEffect (const ITNKillingEffect& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::scnXml::ITNDeterrency (x, f, c),
    baseFactor_ (x.baseFactor_, f, this)
  {
  }

  ITNKillingEffect::
  ITNKillingEffect (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::scnXml::ITNDeterrency (e, f | ::xml_schema::Flags::base, c),
    baseFactor_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ITNKillingEffect::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::ITNDeterrency::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "baseFactor" && n.namespace_ ().empty ())
      {
        this->baseFactor_.set (BaseFactorTraits::create (i, f, this));
        continue;
      }
    }

    if (!baseFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "baseFactor",
        "");
    }
  }

  ITNKillingEffect* ITNKillingEffect::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ITNKillingEffect (*this, f, c);
  }

  ITNKillingEffect& ITNKillingEffect::
  operator= (const ITNKillingEffect& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::ITNDeterrency& > (*this) = x;
      this->baseFactor_ = x.baseFactor_;
    }

    return *this;
  }

  ITNKillingEffect::
  ~ITNKillingEffect ()
  {
  }

  // ITNEffectLogit
  //

  ITNEffectLogit::
  ITNEffectLogit (const BaseFactorType& baseFactor,
                  const InsecticideFactorType& insecticideFactor,
                  const HoleFactorType& holeFactor,
                  const InteractionFactorType& interactionFactor)
  : ::xml_schema::Type (),
    baseFactor_ (baseFactor, this),
    insecticideFactor_ (insecticideFactor, this),
    holeFactor_ (holeFactor, this),
    interactionFactor_ (interactionFactor, this)
  {
  }

  ITNEffectLogit::
  ITNEffectLogit (const ITNEffectLogit& x,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    baseFactor_ (x.baseFactor_, f, this),
    insecticideFactor_ (x.insecticideFactor_, f, this),
    holeFactor_ (x.holeFactor_, f, this),
    interactionFactor_ (x.interactionFactor_, f, this)
  {
  }

  ITNEffectLogit::
  ITNEffectLogit (const xercesc::DOMElement& e,
                  ::xml_schema::Flags f,
                  ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    baseFactor_ (this),
    insecticideFactor_ (this),
    holeFactor_ (this),
    interactionFactor_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void ITNEffectLogit::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "baseFactor" && n.namespace_ ().empty ())
      {
        this->baseFactor_.set (BaseFactorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "insecticideFactor" && n.namespace_ ().empty ())
      {
        this->insecticideFactor_.set (InsecticideFactorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "holeFactor" && n.namespace_ ().empty ())
      {
        this->holeFactor_.set (HoleFactorTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "interactionFactor" && n.namespace_ ().empty ())
      {
        this->interactionFactor_.set (InteractionFactorTraits::create (i, f, this));
        continue;
      }
    }

    if (!baseFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "baseFactor",
        "");
    }

    if (!insecticideFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "insecticideFactor",
        "");
    }

    if (!holeFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "holeFactor",
        "");
    }

    if (!interactionFactor_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "interactionFactor",
        "");
    }
  }

  ITNEffectLogit* ITNEffectLogit::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ITNEffectLogit (*this, f, c);
  }

  ITNEffectLogit& ITNEffectLogit::
  operator= (const ITNEffectLogit& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->baseFactor_ = x.baseFactor_;
      this->insecticideFactor_ = x.insecticideFactor_;
      this->holeFactor_ = x.holeFactor_;
      this->interactionFactor_ = x.interactionFactor_;
    }

    return *this;
  }

  ITNEffectLogit::
  ~ITNEffectLogit ()
  {
  }

  // VectorSpeciesIntervention
  //

  VectorSpeciesIntervention::
  VectorSpeciesIntervention (const MosquitoType& mosquito)
  : ::xml_schema::Type (),
    seekingDeathRateIncrease_ (this),
    probDeathOvipositing_ (this),
    emergenceReduction_ (this),
    mosquito_ (mosquito, this)
  {
  }

  VectorSpeciesIntervention::
  VectorSpeciesIntervention (const VectorSpeciesIntervention& x,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    seekingDeathRateIncrease_ (x.seekingDeathRateIncrease_, f, this),
    probDeathOvipositing_ (x.probDeathOvipositing_, f, this),
    emergenceReduction_ (x.emergenceReduction_, f, this),
    mosquito_ (x.mosquito_, f, this)
  {
  }

  VectorSpeciesIntervention::
  VectorSpeciesIntervention (const xercesc::DOMElement& e,
                             ::xml_schema::Flags f,
                             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    seekingDeathRateIncrease_ (this),
    probDeathOvipositing_ (this),
    emergenceReduction_ (this),
    mosquito_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void VectorSpeciesIntervention::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // seekingDeathRateIncrease
      //
      if (n.name () == "seekingDeathRateIncrease" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< SeekingDeathRateIncreaseType > r (
          SeekingDeathRateIncreaseTraits::create (i, f, this));

        if (!this->seekingDeathRateIncrease_)
        {
          this->seekingDeathRateIncrease_.set (::std::move (r));
          continue;
        }
      }

      // probDeathOvipositing
      //
      if (n.name () == "probDeathOvipositing" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ProbDeathOvipositingType > r (
          ProbDeathOvipositingTraits::create (i, f, this));

        if (!this->probDeathOvipositing_)
        {
          this->probDeathOvipositing_.set (::std::move (r));
          continue;
        }
      }

      // emergenceReduction
      //
      if (n.name () == "emergenceReduction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< EmergenceReductionType > r (
          EmergenceReductionTraits::create (i, f, this));

        if (!this->emergenceReduction_)
        {
          this->emergenceReduction_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mosquito" && n.namespace_ ().empty ())
      {
        this->mosquito_.set (MosquitoTraits::create (i, f, this));
        continue;
      }
    }

    if (!mosquito_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mosquito",
        "");
    }
  }

  VectorSpeciesIntervention* VectorSpeciesIntervention::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VectorSpeciesIntervention (*this, f, c);
  }

  VectorSpeciesIntervention& VectorSpeciesIntervention::
  operator= (const VectorSpeciesIntervention& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->seekingDeathRateIncrease_ = x.seekingDeathRateIncrease_;
      this->probDeathOvipositing_ = x.probDeathOvipositing_;
      this->emergenceReduction_ = x.emergenceReduction_;
      this->mosquito_ = x.mosquito_;
    }

    return *this;
  }

  VectorSpeciesIntervention::
  ~VectorSpeciesIntervention ()
  {
  }

  // ChangeHS
  //

  ChangeHS::
  ChangeHS ()
  : ::xml_schema::Type (),
    timedDeployment_ (this),
    name_ (this)
  {
  }

  ChangeHS::
  ChangeHS (const ChangeHS& x,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    timedDeployment_ (x.timedDeployment_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ChangeHS::
  ChangeHS (const xercesc::DOMElement& e,
            ::xml_schema::Flags f,
            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    timedDeployment_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ChangeHS::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // timedDeployment
      //
      if (n.name () == "timedDeployment" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TimedDeploymentType > r (
          TimedDeploymentTraits::create (i, f, this));

        this->timedDeployment_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  ChangeHS* ChangeHS::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ChangeHS (*this, f, c);
  }

  ChangeHS& ChangeHS::
  operator= (const ChangeHS& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->timedDeployment_ = x.timedDeployment_;
      this->name_ = x.name_;
    }

    return *this;
  }

  ChangeHS::
  ~ChangeHS ()
  {
  }

  // ChangeEIR
  //

  ChangeEIR::
  ChangeEIR ()
  : ::xml_schema::Type (),
    timedDeployment_ (this),
    name_ (this)
  {
  }

  ChangeEIR::
  ChangeEIR (const ChangeEIR& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    timedDeployment_ (x.timedDeployment_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ChangeEIR::
  ChangeEIR (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    timedDeployment_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ChangeEIR::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // timedDeployment
      //
      if (n.name () == "timedDeployment" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TimedDeploymentType > r (
          TimedDeploymentTraits::create (i, f, this));

        this->timedDeployment_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  ChangeEIR* ChangeEIR::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ChangeEIR (*this, f, c);
  }

  ChangeEIR& ChangeEIR::
  operator= (const ChangeEIR& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->timedDeployment_ = x.timedDeployment_;
      this->name_ = x.name_;
    }

    return *this;
  }

  ChangeEIR::
  ~ChangeEIR ()
  {
  }

  // ImportedInfections
  //

  ImportedInfections::
  ImportedInfections (const TimedType& timed)
  : ::xml_schema::Type (),
    timed_ (timed, this),
    name_ (this)
  {
  }

  ImportedInfections::
  ImportedInfections (::std::unique_ptr< TimedType > timed)
  : ::xml_schema::Type (),
    timed_ (std::move (timed), this),
    name_ (this)
  {
  }

  ImportedInfections::
  ImportedInfections (const ImportedInfections& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    timed_ (x.timed_, f, this),
    name_ (x.name_, f, this)
  {
  }

  ImportedInfections::
  ImportedInfections (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    timed_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ImportedInfections::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // timed
      //
      if (n.name () == "timed" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TimedType > r (
          TimedTraits::create (i, f, this));

        if (!timed_.present ())
        {
          this->timed_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!timed_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "timed",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  ImportedInfections* ImportedInfections::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ImportedInfections (*this, f, c);
  }

  ImportedInfections& ImportedInfections::
  operator= (const ImportedInfections& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->timed_ = x.timed_;
      this->name_ = x.name_;
    }

    return *this;
  }

  ImportedInfections::
  ~ImportedInfections ()
  {
  }

  // InsertR_0Case
  //

  InsertR_0Case::
  InsertR_0Case ()
  : ::xml_schema::Type (),
    timedDeployment_ (this),
    name_ (this)
  {
  }

  InsertR_0Case::
  InsertR_0Case (const InsertR_0Case& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    timedDeployment_ (x.timedDeployment_, f, this),
    name_ (x.name_, f, this)
  {
  }

  InsertR_0Case::
  InsertR_0Case (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    timedDeployment_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void InsertR_0Case::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // timedDeployment
      //
      if (n.name () == "timedDeployment" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TimedDeploymentType > r (
          TimedDeploymentTraits::create (i, f, this));

        this->timedDeployment_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  InsertR_0Case* InsertR_0Case::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class InsertR_0Case (*this, f, c);
  }

  InsertR_0Case& InsertR_0Case::
  operator= (const InsertR_0Case& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->timedDeployment_ = x.timedDeployment_;
      this->name_ = x.name_;
    }

    return *this;
  }

  InsertR_0Case::
  ~InsertR_0Case ()
  {
  }

  // UninfectVectors
  //

  UninfectVectors::
  UninfectVectors ()
  : ::xml_schema::Type (),
    timedDeployment_ (this),
    name_ (this)
  {
  }

  UninfectVectors::
  UninfectVectors (const UninfectVectors& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    timedDeployment_ (x.timedDeployment_, f, this),
    name_ (x.name_, f, this)
  {
  }

  UninfectVectors::
  UninfectVectors (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    timedDeployment_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void UninfectVectors::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // timedDeployment
      //
      if (n.name () == "timedDeployment" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TimedDeploymentType > r (
          TimedDeploymentTraits::create (i, f, this));

        this->timedDeployment_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  UninfectVectors* UninfectVectors::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class UninfectVectors (*this, f, c);
  }

  UninfectVectors& UninfectVectors::
  operator= (const UninfectVectors& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->timedDeployment_ = x.timedDeployment_;
      this->name_ = x.name_;
    }

    return *this;
  }

  UninfectVectors::
  ~UninfectVectors ()
  {
  }

  // VectorPop
  //

  VectorPop::
  VectorPop ()
  : ::xml_schema::Type (),
    intervention_ (this)
  {
  }

  VectorPop::
  VectorPop (const VectorPop& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    intervention_ (x.intervention_, f, this)
  {
  }

  VectorPop::
  VectorPop (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    intervention_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VectorPop::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // intervention
      //
      if (n.name () == "intervention" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< InterventionType > r (
          InterventionTraits::create (i, f, this));

        this->intervention_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  VectorPop* VectorPop::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VectorPop (*this, f, c);
  }

  VectorPop& VectorPop::
  operator= (const VectorPop& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->intervention_ = x.intervention_;
    }

    return *this;
  }

  VectorPop::
  ~VectorPop ()
  {
  }

  // VectorTrap1
  //

  VectorTrap1::
  VectorTrap1 ()
  : ::xml_schema::Type (),
    intervention_ (this)
  {
  }

  VectorTrap1::
  VectorTrap1 (const VectorTrap1& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    intervention_ (x.intervention_, f, this)
  {
  }

  VectorTrap1::
  VectorTrap1 (const xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    intervention_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void VectorTrap1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // intervention
      //
      if (n.name () == "intervention" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< InterventionType > r (
          InterventionTraits::create (i, f, this));

        this->intervention_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  VectorTrap1* VectorTrap1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class VectorTrap1 (*this, f, c);
  }

  VectorTrap1& VectorTrap1::
  operator= (const VectorTrap1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->intervention_ = x.intervention_;
    }

    return *this;
  }

  VectorTrap1::
  ~VectorTrap1 ()
  {
  }

  // Deployment
  //

  Deployment::
  Deployment ()
  : ::xml_schema::Type (),
    component_ (this),
    condition_ (this),
    continuous_ (this),
    timed_ (this),
    name_ (this)
  {
  }

  Deployment::
  Deployment (const Deployment& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    component_ (x.component_, f, this),
    condition_ (x.condition_, f, this),
    continuous_ (x.continuous_, f, this),
    timed_ (x.timed_, f, this),
    name_ (x.name_, f, this)
  {
  }

  Deployment::
  Deployment (const xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    component_ (this),
    condition_ (this),
    continuous_ (this),
    timed_ (this),
    name_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Deployment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // component
      //
      if (n.name () == "component" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ComponentType > r (
          ComponentTraits::create (i, f, this));

        this->component_.push_back (::std::move (r));
        continue;
      }

      // condition
      //
      if (n.name () == "condition" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ConditionType > r (
          ConditionTraits::create (i, f, this));

        this->condition_.push_back (::std::move (r));
        continue;
      }

      // continuous
      //
      if (n.name () == "continuous" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< ContinuousType > r (
          ContinuousTraits::create (i, f, this));

        this->continuous_.push_back (::std::move (r));
        continue;
      }

      // timed
      //
      if (n.name () == "timed" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TimedType > r (
          TimedTraits::create (i, f, this));

        this->timed_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "name" && n.namespace_ ().empty ())
      {
        this->name_.set (NameTraits::create (i, f, this));
        continue;
      }
    }
  }

  Deployment* Deployment::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Deployment (*this, f, c);
  }

  Deployment& Deployment::
  operator= (const Deployment& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->component_ = x.component_;
      this->condition_ = x.condition_;
      this->continuous_ = x.continuous_;
      this->timed_ = x.timed_;
      this->name_ = x.name_;
    }

    return *this;
  }

  Deployment::
  ~Deployment ()
  {
  }

  // RecruitmentOnly
  //

  RecruitmentOnly::
  RecruitmentOnly ()
  : ::xml_schema::Type ()
  {
  }

  RecruitmentOnly::
  RecruitmentOnly (const RecruitmentOnly& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c)
  {
  }

  RecruitmentOnly::
  RecruitmentOnly (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f, c)
  {
  }

  RecruitmentOnly::
  RecruitmentOnly (const xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (a, f, c)
  {
  }

  RecruitmentOnly::
  RecruitmentOnly (const ::std::string& s,
                   const xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::xml_schema::Type (s, e, f, c)
  {
  }

  RecruitmentOnly* RecruitmentOnly::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class RecruitmentOnly (*this, f, c);
  }

  RecruitmentOnly::
  ~RecruitmentOnly ()
  {
  }

  // ClearImmunity
  //

  ClearImmunity::
  ClearImmunity ()
  : ::xml_schema::Type ()
  {
  }

  ClearImmunity::
  ClearImmunity (const ClearImmunity& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c)
  {
  }

  ClearImmunity::
  ClearImmunity (const xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f, c)
  {
  }

  ClearImmunity::
  ClearImmunity (const xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (a, f, c)
  {
  }

  ClearImmunity::
  ClearImmunity (const ::std::string& s,
                 const xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
  : ::xml_schema::Type (s, e, f, c)
  {
  }

  ClearImmunity* ClearImmunity::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ClearImmunity (*this, f, c);
  }

  ClearImmunity::
  ~ClearImmunity ()
  {
  }

  // Description
  //

  Description::
  Description ()
  : ::xml_schema::Type (),
    anopheles_ (this)
  {
  }

  Description::
  Description (const Description& x,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    anopheles_ (x.anopheles_, f, this)
  {
  }

  Description::
  Description (const xercesc::DOMElement& e,
               ::xml_schema::Flags f,
               ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    anopheles_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Description::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // anopheles
      //
      if (n.name () == "anopheles" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AnophelesType > r (
          AnophelesTraits::create (i, f, this));

        this->anopheles_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Description* Description::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Description (*this, f, c);
  }

  Description& Description::
  operator= (const Description& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->anopheles_ = x.anopheles_;
    }

    return *this;
  }

  Description::
  ~Description ()
  {
  }

  // Description1
  //

  Description1::
  Description1 (const RelativeAvailabilityType& relativeAvailability,
                const DecayOfAvailabilityType& decayOfAvailability,
                const MosquitoType& mosquito)
  : ::xml_schema::Type (),
    relativeAvailability_ (relativeAvailability, this),
    decayOfAvailability_ (decayOfAvailability, this),
    mosquito_ (mosquito, this)
  {
  }

  Description1::
  Description1 (::std::unique_ptr< RelativeAvailabilityType > relativeAvailability,
                ::std::unique_ptr< DecayOfAvailabilityType > decayOfAvailability,
                const MosquitoType& mosquito)
  : ::xml_schema::Type (),
    relativeAvailability_ (std::move (relativeAvailability), this),
    decayOfAvailability_ (std::move (decayOfAvailability), this),
    mosquito_ (mosquito, this)
  {
  }

  Description1::
  Description1 (const Description1& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    relativeAvailability_ (x.relativeAvailability_, f, this),
    decayOfAvailability_ (x.decayOfAvailability_, f, this),
    mosquito_ (x.mosquito_, f, this)
  {
  }

  Description1::
  Description1 (const xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    relativeAvailability_ (this),
    decayOfAvailability_ (this),
    mosquito_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Description1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // relativeAvailability
      //
      if (n.name () == "relativeAvailability" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< RelativeAvailabilityType > r (
          RelativeAvailabilityTraits::create (i, f, this));

        if (!relativeAvailability_.present ())
        {
          this->relativeAvailability_.set (::std::move (r));
          continue;
        }
      }

      // decayOfAvailability
      //
      if (n.name () == "decayOfAvailability" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DecayOfAvailabilityType > r (
          DecayOfAvailabilityTraits::create (i, f, this));

        if (!decayOfAvailability_.present ())
        {
          this->decayOfAvailability_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!relativeAvailability_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "relativeAvailability",
        "");
    }

    if (!decayOfAvailability_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "decayOfAvailability",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mosquito" && n.namespace_ ().empty ())
      {
        this->mosquito_.set (MosquitoTraits::create (i, f, this));
        continue;
      }
    }

    if (!mosquito_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mosquito",
        "");
    }
  }

  Description1* Description1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Description1 (*this, f, c);
  }

  Description1& Description1::
  operator= (const Description1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->relativeAvailability_ = x.relativeAvailability_;
      this->decayOfAvailability_ = x.decayOfAvailability_;
      this->mosquito_ = x.mosquito_;
    }

    return *this;
  }

  Description1::
  ~Description1 ()
  {
  }

  // Timed
  //

  Timed::
  Timed ()
  : ::xml_schema::Type (),
    deploy_ (this)
  {
  }

  Timed::
  Timed (const Timed& x,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    deploy_ (x.deploy_, f, this)
  {
  }

  Timed::
  Timed (const xercesc::DOMElement& e,
         ::xml_schema::Flags f,
         ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    deploy_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void Timed::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // deploy
      //
      if (n.name () == "deploy" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DeployType > r (
          DeployTraits::create (i, f, this));

        this->deploy_.push_back (::std::move (r));
        continue;
      }

      break;
    }
  }

  Timed* Timed::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Timed (*this, f, c);
  }

  Timed& Timed::
  operator= (const Timed& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->deploy_ = x.deploy_;
    }

    return *this;
  }

  Timed::
  ~Timed ()
  {
  }

  // CumulativeCoverage
  //

  CumulativeCoverage::
  CumulativeCoverage (const ComponentType& component)
  : ::xml_schema::Type (),
    component_ (component, this)
  {
  }

  CumulativeCoverage::
  CumulativeCoverage (const CumulativeCoverage& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    component_ (x.component_, f, this)
  {
  }

  CumulativeCoverage::
  CumulativeCoverage (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    component_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void CumulativeCoverage::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "component" && n.namespace_ ().empty ())
      {
        this->component_.set (ComponentTraits::create (i, f, this));
        continue;
      }
    }

    if (!component_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "component",
        "");
    }
  }

  CumulativeCoverage* CumulativeCoverage::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class CumulativeCoverage (*this, f, c);
  }

  CumulativeCoverage& CumulativeCoverage::
  operator= (const CumulativeCoverage& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->component_ = x.component_;
    }

    return *this;
  }

  CumulativeCoverage::
  ~CumulativeCoverage ()
  {
  }

  // AnophelesParams1
  //

  AnophelesParams1::
  AnophelesParams1 (const MosquitoType& mosquito)
  : ::xml_schema::Type (),
    holeIndexMax_ (this),
    deterrency_ (this),
    twoStageDeterrency_ (this),
    preprandialKillingEffect_ (this),
    preprandialKillingEffectLogit_ (this),
    postprandialKillingEffect_ (this),
    postprandialKillingEffectLogit_ (this),
    fecundityReduction_ (this),
    fecundityReductionLogit_ (this),
    mosquito_ (mosquito, this),
    propActive_ (getPropActiveDefaultValue (), this)
  {
  }

  AnophelesParams1::
  AnophelesParams1 (const AnophelesParams1& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    holeIndexMax_ (x.holeIndexMax_, f, this),
    deterrency_ (x.deterrency_, f, this),
    twoStageDeterrency_ (x.twoStageDeterrency_, f, this),
    preprandialKillingEffect_ (x.preprandialKillingEffect_, f, this),
    preprandialKillingEffectLogit_ (x.preprandialKillingEffectLogit_, f, this),
    postprandialKillingEffect_ (x.postprandialKillingEffect_, f, this),
    postprandialKillingEffectLogit_ (x.postprandialKillingEffectLogit_, f, this),
    fecundityReduction_ (x.fecundityReduction_, f, this),
    fecundityReductionLogit_ (x.fecundityReductionLogit_, f, this),
    mosquito_ (x.mosquito_, f, this),
    propActive_ (x.propActive_, f, this)
  {
  }

  AnophelesParams1::
  AnophelesParams1 (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    holeIndexMax_ (this),
    deterrency_ (this),
    twoStageDeterrency_ (this),
    preprandialKillingEffect_ (this),
    preprandialKillingEffectLogit_ (this),
    postprandialKillingEffect_ (this),
    postprandialKillingEffectLogit_ (this),
    fecundityReduction_ (this),
    fecundityReductionLogit_ (this),
    mosquito_ (this),
    propActive_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AnophelesParams1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // holeIndexMax
      //
      if (n.name () == "holeIndexMax" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< HoleIndexMaxType > r (
          HoleIndexMaxTraits::create (i, f, this));

        if (!this->holeIndexMax_)
        {
          this->holeIndexMax_.set (::std::move (r));
          continue;
        }
      }

      // deterrency
      //
      if (n.name () == "deterrency" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DeterrencyType > r (
          DeterrencyTraits::create (i, f, this));

        if (!this->deterrency_)
        {
          this->deterrency_.set (::std::move (r));
          continue;
        }
      }

      // twoStageDeterrency
      //
      if (n.name () == "twoStageDeterrency" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< TwoStageDeterrencyType > r (
          TwoStageDeterrencyTraits::create (i, f, this));

        if (!this->twoStageDeterrency_)
        {
          this->twoStageDeterrency_.set (::std::move (r));
          continue;
        }
      }

      // preprandialKillingEffect
      //
      if (n.name () == "preprandialKillingEffect" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PreprandialKillingEffectType > r (
          PreprandialKillingEffectTraits::create (i, f, this));

        if (!this->preprandialKillingEffect_)
        {
          this->preprandialKillingEffect_.set (::std::move (r));
          continue;
        }
      }

      // preprandialKillingEffectLogit
      //
      if (n.name () == "preprandialKillingEffectLogit" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PreprandialKillingEffectLogitType > r (
          PreprandialKillingEffectLogitTraits::create (i, f, this));

        if (!this->preprandialKillingEffectLogit_)
        {
          this->preprandialKillingEffectLogit_.set (::std::move (r));
          continue;
        }
      }

      // postprandialKillingEffect
      //
      if (n.name () == "postprandialKillingEffect" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PostprandialKillingEffectType > r (
          PostprandialKillingEffectTraits::create (i, f, this));

        if (!this->postprandialKillingEffect_)
        {
          this->postprandialKillingEffect_.set (::std::move (r));
          continue;
        }
      }

      // postprandialKillingEffectLogit
      //
      if (n.name () == "postprandialKillingEffectLogit" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PostprandialKillingEffectLogitType > r (
          PostprandialKillingEffectLogitTraits::create (i, f, this));

        if (!this->postprandialKillingEffectLogit_)
        {
          this->postprandialKillingEffectLogit_.set (::std::move (r));
          continue;
        }
      }

      // fecundityReduction
      //
      if (n.name () == "fecundityReduction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< FecundityReductionType > r (
          FecundityReductionTraits::create (i, f, this));

        if (!this->fecundityReduction_)
        {
          this->fecundityReduction_.set (::std::move (r));
          continue;
        }
      }

      // fecundityReductionLogit
      //
      if (n.name () == "fecundityReductionLogit" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< FecundityReductionLogitType > r (
          FecundityReductionLogitTraits::create (i, f, this));

        if (!this->fecundityReductionLogit_)
        {
          this->fecundityReductionLogit_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mosquito" && n.namespace_ ().empty ())
      {
        this->mosquito_.set (MosquitoTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "propActive" && n.namespace_ ().empty ())
      {
        this->propActive_.set (PropActiveTraits::create (i, f, this));
        continue;
      }
    }

    if (!mosquito_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mosquito",
        "");
    }

    if (!propActive_.present ())
    {
      this->propActive_.set (getPropActiveDefaultValue ());
    }
  }

  AnophelesParams1* AnophelesParams1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AnophelesParams1 (*this, f, c);
  }

  AnophelesParams1& AnophelesParams1::
  operator= (const AnophelesParams1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->holeIndexMax_ = x.holeIndexMax_;
      this->deterrency_ = x.deterrency_;
      this->twoStageDeterrency_ = x.twoStageDeterrency_;
      this->preprandialKillingEffect_ = x.preprandialKillingEffect_;
      this->preprandialKillingEffectLogit_ = x.preprandialKillingEffectLogit_;
      this->postprandialKillingEffect_ = x.postprandialKillingEffect_;
      this->postprandialKillingEffectLogit_ = x.postprandialKillingEffectLogit_;
      this->fecundityReduction_ = x.fecundityReduction_;
      this->fecundityReductionLogit_ = x.fecundityReductionLogit_;
      this->mosquito_ = x.mosquito_;
      this->propActive_ = x.propActive_;
    }

    return *this;
  }

  AnophelesParams1::
  ~AnophelesParams1 ()
  {
  }

  // AnophelesParams11
  //

  AnophelesParams11::
  AnophelesParams11 (const MosquitoType& mosquito)
  : ::xml_schema::Type (),
    deterrency_ (this),
    preprandialKillingEffect_ (this),
    postprandialKillingEffect_ (this),
    fecundityReduction_ (this),
    mosquito_ (mosquito, this),
    propActive_ (getPropActiveDefaultValue (), this)
  {
  }

  AnophelesParams11::
  AnophelesParams11 (const AnophelesParams11& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    deterrency_ (x.deterrency_, f, this),
    preprandialKillingEffect_ (x.preprandialKillingEffect_, f, this),
    postprandialKillingEffect_ (x.postprandialKillingEffect_, f, this),
    fecundityReduction_ (x.fecundityReduction_, f, this),
    mosquito_ (x.mosquito_, f, this),
    propActive_ (x.propActive_, f, this)
  {
  }

  AnophelesParams11::
  AnophelesParams11 (const xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    deterrency_ (this),
    preprandialKillingEffect_ (this),
    postprandialKillingEffect_ (this),
    fecundityReduction_ (this),
    mosquito_ (this),
    propActive_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AnophelesParams11::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // deterrency
      //
      if (n.name () == "deterrency" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DeterrencyType > r (
          DeterrencyTraits::create (i, f, this));

        if (!this->deterrency_)
        {
          this->deterrency_.set (::std::move (r));
          continue;
        }
      }

      // preprandialKillingEffect
      //
      if (n.name () == "preprandialKillingEffect" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PreprandialKillingEffectType > r (
          PreprandialKillingEffectTraits::create (i, f, this));

        if (!this->preprandialKillingEffect_)
        {
          this->preprandialKillingEffect_.set (::std::move (r));
          continue;
        }
      }

      // postprandialKillingEffect
      //
      if (n.name () == "postprandialKillingEffect" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PostprandialKillingEffectType > r (
          PostprandialKillingEffectTraits::create (i, f, this));

        if (!this->postprandialKillingEffect_)
        {
          this->postprandialKillingEffect_.set (::std::move (r));
          continue;
        }
      }

      // fecundityReduction
      //
      if (n.name () == "fecundityReduction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< FecundityReductionType > r (
          FecundityReductionTraits::create (i, f, this));

        if (!this->fecundityReduction_)
        {
          this->fecundityReduction_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mosquito" && n.namespace_ ().empty ())
      {
        this->mosquito_.set (MosquitoTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "propActive" && n.namespace_ ().empty ())
      {
        this->propActive_.set (PropActiveTraits::create (i, f, this));
        continue;
      }
    }

    if (!mosquito_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mosquito",
        "");
    }

    if (!propActive_.present ())
    {
      this->propActive_.set (getPropActiveDefaultValue ());
    }
  }

  AnophelesParams11* AnophelesParams11::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AnophelesParams11 (*this, f, c);
  }

  AnophelesParams11& AnophelesParams11::
  operator= (const AnophelesParams11& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->deterrency_ = x.deterrency_;
      this->preprandialKillingEffect_ = x.preprandialKillingEffect_;
      this->postprandialKillingEffect_ = x.postprandialKillingEffect_;
      this->fecundityReduction_ = x.fecundityReduction_;
      this->mosquito_ = x.mosquito_;
      this->propActive_ = x.propActive_;
    }

    return *this;
  }

  AnophelesParams11::
  ~AnophelesParams11 ()
  {
  }

  // AnophelesParams2
  //

  AnophelesParams2::
  AnophelesParams2 (const DeterrencyType& deterrency,
                    const PreprandialKillingEffectType& preprandialKillingEffect,
                    const PostprandialKillingEffectType& postprandialKillingEffect,
                    const MosquitoType& mosquito)
  : ::xml_schema::Type (),
    deterrency_ (deterrency, this),
    preprandialKillingEffect_ (preprandialKillingEffect, this),
    postprandialKillingEffect_ (postprandialKillingEffect, this),
    fecundityReduction_ (this),
    mosquito_ (mosquito, this),
    propActive_ (getPropActiveDefaultValue (), this)
  {
  }

  AnophelesParams2::
  AnophelesParams2 (::std::unique_ptr< DeterrencyType > deterrency,
                    ::std::unique_ptr< PreprandialKillingEffectType > preprandialKillingEffect,
                    ::std::unique_ptr< PostprandialKillingEffectType > postprandialKillingEffect,
                    const MosquitoType& mosquito)
  : ::xml_schema::Type (),
    deterrency_ (std::move (deterrency), this),
    preprandialKillingEffect_ (std::move (preprandialKillingEffect), this),
    postprandialKillingEffect_ (std::move (postprandialKillingEffect), this),
    fecundityReduction_ (this),
    mosquito_ (mosquito, this),
    propActive_ (getPropActiveDefaultValue (), this)
  {
  }

  AnophelesParams2::
  AnophelesParams2 (const AnophelesParams2& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    deterrency_ (x.deterrency_, f, this),
    preprandialKillingEffect_ (x.preprandialKillingEffect_, f, this),
    postprandialKillingEffect_ (x.postprandialKillingEffect_, f, this),
    fecundityReduction_ (x.fecundityReduction_, f, this),
    mosquito_ (x.mosquito_, f, this),
    propActive_ (x.propActive_, f, this)
  {
  }

  AnophelesParams2::
  AnophelesParams2 (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    deterrency_ (this),
    preprandialKillingEffect_ (this),
    postprandialKillingEffect_ (this),
    fecundityReduction_ (this),
    mosquito_ (this),
    propActive_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void AnophelesParams2::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // deterrency
      //
      if (n.name () == "deterrency" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DeterrencyType > r (
          DeterrencyTraits::create (i, f, this));

        if (!deterrency_.present ())
        {
          this->deterrency_.set (::std::move (r));
          continue;
        }
      }

      // preprandialKillingEffect
      //
      if (n.name () == "preprandialKillingEffect" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PreprandialKillingEffectType > r (
          PreprandialKillingEffectTraits::create (i, f, this));

        if (!preprandialKillingEffect_.present ())
        {
          this->preprandialKillingEffect_.set (::std::move (r));
          continue;
        }
      }

      // postprandialKillingEffect
      //
      if (n.name () == "postprandialKillingEffect" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< PostprandialKillingEffectType > r (
          PostprandialKillingEffectTraits::create (i, f, this));

        if (!postprandialKillingEffect_.present ())
        {
          this->postprandialKillingEffect_.set (::std::move (r));
          continue;
        }
      }

      // fecundityReduction
      //
      if (n.name () == "fecundityReduction" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< FecundityReductionType > r (
          FecundityReductionTraits::create (i, f, this));

        if (!this->fecundityReduction_)
        {
          this->fecundityReduction_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!deterrency_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "deterrency",
        "");
    }

    if (!preprandialKillingEffect_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "preprandialKillingEffect",
        "");
    }

    if (!postprandialKillingEffect_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "postprandialKillingEffect",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "mosquito" && n.namespace_ ().empty ())
      {
        this->mosquito_.set (MosquitoTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "propActive" && n.namespace_ ().empty ())
      {
        this->propActive_.set (PropActiveTraits::create (i, f, this));
        continue;
      }
    }

    if (!mosquito_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "mosquito",
        "");
    }

    if (!propActive_.present ())
    {
      this->propActive_.set (getPropActiveDefaultValue ());
    }
  }

  AnophelesParams2* AnophelesParams2::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class AnophelesParams2 (*this, f, c);
  }

  AnophelesParams2& AnophelesParams2::
  operator= (const AnophelesParams2& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->deterrency_ = x.deterrency_;
      this->preprandialKillingEffect_ = x.preprandialKillingEffect_;
      this->postprandialKillingEffect_ = x.postprandialKillingEffect_;
      this->fecundityReduction_ = x.fecundityReduction_;
      this->mosquito_ = x.mosquito_;
      this->propActive_ = x.propActive_;
    }

    return *this;
  }

  AnophelesParams2::
  ~AnophelesParams2 ()
  {
  }

  // SeekingDeathRateIncrease
  //

  SeekingDeathRateIncrease::
  SeekingDeathRateIncrease (const DecayType& decay,
                            const InitialType& initial)
  : ::xml_schema::Type (),
    decay_ (decay, this),
    initial_ (initial, this)
  {
  }

  SeekingDeathRateIncrease::
  SeekingDeathRateIncrease (::std::unique_ptr< DecayType > decay,
                            const InitialType& initial)
  : ::xml_schema::Type (),
    decay_ (std::move (decay), this),
    initial_ (initial, this)
  {
  }

  SeekingDeathRateIncrease::
  SeekingDeathRateIncrease (const SeekingDeathRateIncrease& x,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    decay_ (x.decay_, f, this),
    initial_ (x.initial_, f, this)
  {
  }

  SeekingDeathRateIncrease::
  SeekingDeathRateIncrease (const xercesc::DOMElement& e,
                            ::xml_schema::Flags f,
                            ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    decay_ (this),
    initial_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void SeekingDeathRateIncrease::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // decay
      //
      if (n.name () == "decay" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DecayType > r (
          DecayTraits::create (i, f, this));

        if (!decay_.present ())
        {
          this->decay_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!decay_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "decay",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "initial" && n.namespace_ ().empty ())
      {
        this->initial_.set (InitialTraits::create (i, f, this));
        continue;
      }
    }

    if (!initial_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "initial",
        "");
    }
  }

  SeekingDeathRateIncrease* SeekingDeathRateIncrease::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class SeekingDeathRateIncrease (*this, f, c);
  }

  SeekingDeathRateIncrease& SeekingDeathRateIncrease::
  operator= (const SeekingDeathRateIncrease& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->decay_ = x.decay_;
      this->initial_ = x.initial_;
    }

    return *this;
  }

  SeekingDeathRateIncrease::
  ~SeekingDeathRateIncrease ()
  {
  }

  // ProbDeathOvipositing
  //

  ProbDeathOvipositing::
  ProbDeathOvipositing (const DecayType& decay,
                        const InitialType& initial)
  : ::xml_schema::Type (),
    decay_ (decay, this),
    initial_ (initial, this)
  {
  }

  ProbDeathOvipositing::
  ProbDeathOvipositing (::std::unique_ptr< DecayType > decay,
                        const InitialType& initial)
  : ::xml_schema::Type (),
    decay_ (std::move (decay), this),
    initial_ (initial, this)
  {
  }

  ProbDeathOvipositing::
  ProbDeathOvipositing (const ProbDeathOvipositing& x,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    decay_ (x.decay_, f, this),
    initial_ (x.initial_, f, this)
  {
  }

  ProbDeathOvipositing::
  ProbDeathOvipositing (const xercesc::DOMElement& e,
                        ::xml_schema::Flags f,
                        ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    decay_ (this),
    initial_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void ProbDeathOvipositing::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // decay
      //
      if (n.name () == "decay" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DecayType > r (
          DecayTraits::create (i, f, this));

        if (!decay_.present ())
        {
          this->decay_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!decay_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "decay",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "initial" && n.namespace_ ().empty ())
      {
        this->initial_.set (InitialTraits::create (i, f, this));
        continue;
      }
    }

    if (!initial_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "initial",
        "");
    }
  }

  ProbDeathOvipositing* ProbDeathOvipositing::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class ProbDeathOvipositing (*this, f, c);
  }

  ProbDeathOvipositing& ProbDeathOvipositing::
  operator= (const ProbDeathOvipositing& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->decay_ = x.decay_;
      this->initial_ = x.initial_;
    }

    return *this;
  }

  ProbDeathOvipositing::
  ~ProbDeathOvipositing ()
  {
  }

  // EmergenceReduction
  //

  EmergenceReduction::
  EmergenceReduction (const DecayType& decay,
                      const InitialType& initial)
  : ::xml_schema::Type (),
    decay_ (decay, this),
    initial_ (initial, this)
  {
  }

  EmergenceReduction::
  EmergenceReduction (::std::unique_ptr< DecayType > decay,
                      const InitialType& initial)
  : ::xml_schema::Type (),
    decay_ (std::move (decay), this),
    initial_ (initial, this)
  {
  }

  EmergenceReduction::
  EmergenceReduction (const EmergenceReduction& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    decay_ (x.decay_, f, this),
    initial_ (x.initial_, f, this)
  {
  }

  EmergenceReduction::
  EmergenceReduction (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    decay_ (this),
    initial_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void EmergenceReduction::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // decay
      //
      if (n.name () == "decay" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< DecayType > r (
          DecayTraits::create (i, f, this));

        if (!decay_.present ())
        {
          this->decay_.set (::std::move (r));
          continue;
        }
      }

      break;
    }

    if (!decay_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "decay",
        "");
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "initial" && n.namespace_ ().empty ())
      {
        this->initial_.set (InitialTraits::create (i, f, this));
        continue;
      }
    }

    if (!initial_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "initial",
        "");
    }
  }

  EmergenceReduction* EmergenceReduction::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class EmergenceReduction (*this, f, c);
  }

  EmergenceReduction& EmergenceReduction::
  operator= (const EmergenceReduction& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->decay_ = x.decay_;
      this->initial_ = x.initial_;
    }

    return *this;
  }

  EmergenceReduction::
  ~EmergenceReduction ()
  {
  }

  // TimedDeployment
  //

  TimedDeployment::
  TimedDeployment (const CFRType& CFR,
                   const PSequelaeInpatientType& pSequelaeInpatient,
                   const TimeType& time)
  : ::scnXml::HealthSystem (CFR,
                            pSequelaeInpatient),
    time_ (time, this)
  {
  }

  TimedDeployment::
  TimedDeployment (::std::unique_ptr< CFRType > CFR,
                   ::std::unique_ptr< PSequelaeInpatientType > pSequelaeInpatient,
                   const TimeType& time)
  : ::scnXml::HealthSystem (std::move (CFR),
                            std::move (pSequelaeInpatient)),
    time_ (time, this)
  {
  }

  TimedDeployment::
  TimedDeployment (const TimedDeployment& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::scnXml::HealthSystem (x, f, c),
    time_ (x.time_, f, this)
  {
  }

  TimedDeployment::
  TimedDeployment (const xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
  : ::scnXml::HealthSystem (e, f | ::xml_schema::Flags::base, c),
    time_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void TimedDeployment::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::HealthSystem::parse (p, f);

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        this->time_.set (TimeTraits::create (i, f, this));
        continue;
      }
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time",
        "");
    }
  }

  TimedDeployment* TimedDeployment::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimedDeployment (*this, f, c);
  }

  TimedDeployment& TimedDeployment::
  operator= (const TimedDeployment& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::HealthSystem& > (*this) = x;
      this->time_ = x.time_;
    }

    return *this;
  }

  TimedDeployment::
  ~TimedDeployment ()
  {
  }

  // TimedDeployment1
  //

  TimedDeployment1::
  TimedDeployment1 (const EipDurationType& eipDuration,
                    const TimeType& time)
  : ::scnXml::NonVector (eipDuration),
    time_ (time, this)
  {
  }

  TimedDeployment1::
  TimedDeployment1 (const TimedDeployment1& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::scnXml::NonVector (x, f, c),
    time_ (x.time_, f, this)
  {
  }

  TimedDeployment1::
  TimedDeployment1 (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::scnXml::NonVector (e, f | ::xml_schema::Flags::base, c),
    time_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void TimedDeployment1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::NonVector::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        this->time_.set (TimeTraits::create (i, f, this));
        continue;
      }
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time",
        "");
    }
  }

  TimedDeployment1* TimedDeployment1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimedDeployment1 (*this, f, c);
  }

  TimedDeployment1& TimedDeployment1::
  operator= (const TimedDeployment1& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::NonVector& > (*this) = x;
      this->time_ = x.time_;
    }

    return *this;
  }

  TimedDeployment1::
  ~TimedDeployment1 ()
  {
  }

  // Timed1
  //

  const Timed1::PeriodType Timed1::period_default_value_ (
    "0");

  Timed1::
  Timed1 ()
  : ::xml_schema::Type (),
    rate_ (this),
    period_ (getPeriodDefaultValue (), this)
  {
  }

  Timed1::
  Timed1 (const Timed1& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    rate_ (x.rate_, f, this),
    period_ (x.period_, f, this)
  {
  }

  Timed1::
  Timed1 (const xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    rate_ (this),
    period_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
      this->parse (p, f);
    }
  }

  void Timed1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // rate
      //
      if (n.name () == "rate" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< RateType > r (
          RateTraits::create (i, f, this));

        this->rate_.push_back (::std::move (r));
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "period" && n.namespace_ ().empty ())
      {
        this->period_.set (PeriodTraits::create (i, f, this));
        continue;
      }
    }

    if (!period_.present ())
    {
      this->period_.set (getPeriodDefaultValue ());
    }
  }

  Timed1* Timed1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Timed1 (*this, f, c);
  }

  Timed1& Timed1::
  operator= (const Timed1& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->rate_ = x.rate_;
      this->period_ = x.period_;
    }

    return *this;
  }

  Timed1::
  ~Timed1 ()
  {
  }

  // TimedDeployment2
  //

  TimedDeployment2::
  TimedDeployment2 (const TimeType& time)
  : ::xml_schema::Type (),
    time_ (time, this)
  {
  }

  TimedDeployment2::
  TimedDeployment2 (const TimedDeployment2& x,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    time_ (x.time_, f, this)
  {
  }

  TimedDeployment2::
  TimedDeployment2 (const xercesc::DOMElement& e,
                    ::xml_schema::Flags f,
                    ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    time_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void TimedDeployment2::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        this->time_.set (TimeTraits::create (i, f, this));
        continue;
      }
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time",
        "");
    }
  }

  TimedDeployment2* TimedDeployment2::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TimedDeployment2 (*this, f, c);
  }

  TimedDeployment2& TimedDeployment2::
  operator= (const TimedDeployment2& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->time_ = x.time_;
    }

    return *this;
  }

  TimedDeployment2::
  ~TimedDeployment2 ()
  {
  }

  // Condition
  //

  Condition::
  Condition (const MeasureType& measure,
             const InitialStateType& initialState)
  : ::xml_schema::Type (),
    measure_ (measure, this),
    minValue_ (this),
    maxValue_ (this),
    initialState_ (initialState, this)
  {
  }

  Condition::
  Condition (const Condition& x,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    measure_ (x.measure_, f, this),
    minValue_ (x.minValue_, f, this),
    maxValue_ (x.maxValue_, f, this),
    initialState_ (x.initialState_, f, this)
  {
  }

  Condition::
  Condition (const xercesc::DOMElement& e,
             ::xml_schema::Flags f,
             ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    measure_ (this),
    minValue_ (this),
    maxValue_ (this),
    initialState_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Condition::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "measure" && n.namespace_ ().empty ())
      {
        this->measure_.set (MeasureTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "minValue" && n.namespace_ ().empty ())
      {
        this->minValue_.set (MinValueTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "maxValue" && n.namespace_ ().empty ())
      {
        this->maxValue_.set (MaxValueTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "initialState" && n.namespace_ ().empty ())
      {
        this->initialState_.set (InitialStateTraits::create (i, f, this));
        continue;
      }
    }

    if (!measure_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "measure",
        "");
    }

    if (!initialState_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "initialState",
        "");
    }
  }

  Condition* Condition::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Condition (*this, f, c);
  }

  Condition& Condition::
  operator= (const Condition& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->measure_ = x.measure_;
      this->minValue_ = x.minValue_;
      this->maxValue_ = x.maxValue_;
      this->initialState_ = x.initialState_;
    }

    return *this;
  }

  Condition::
  ~Condition ()
  {
  }

  // Deploy1
  //

  Deploy1::
  Deploy1 (const TimeType& time,
           const RatioToHumansType& ratioToHumans,
           const LifespanType& lifespan)
  : ::scnXml::TimedBase (time),
    ratioToHumans_ (ratioToHumans, this),
    lifespan_ (lifespan, this)
  {
  }

  Deploy1::
  Deploy1 (const Deploy1& x,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::scnXml::TimedBase (x, f, c),
    ratioToHumans_ (x.ratioToHumans_, f, this),
    lifespan_ (x.lifespan_, f, this)
  {
  }

  Deploy1::
  Deploy1 (const xercesc::DOMElement& e,
           ::xml_schema::Flags f,
           ::xml_schema::Container* c)
  : ::scnXml::TimedBase (e, f | ::xml_schema::Flags::base, c),
    ratioToHumans_ (this),
    lifespan_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Deploy1::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::TimedBase::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "ratioToHumans" && n.namespace_ ().empty ())
      {
        this->ratioToHumans_.set (RatioToHumansTraits::create (i, f, this));
        continue;
      }

      if (n.name () == "lifespan" && n.namespace_ ().empty ())
      {
        this->lifespan_.set (LifespanTraits::create (i, f, this));
        continue;
      }
    }

    if (!ratioToHumans_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "ratioToHumans",
        "");
    }

    if (!lifespan_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "lifespan",
        "");
    }
  }

  Deploy1* Deploy1::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Deploy1 (*this, f, c);
  }

  Deploy1& Deploy1::
  operator= (const Deploy1& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::TimedBase& > (*this) = x;
      this->ratioToHumans_ = x.ratioToHumans_;
      this->lifespan_ = x.lifespan_;
    }

    return *this;
  }

  Deploy1::
  ~Deploy1 ()
  {
  }

  // TwoStageDeterrency
  //

  TwoStageDeterrency::
  TwoStageDeterrency ()
  : ::xml_schema::Type (),
    entering_ (this),
    enteringLogit_ (this),
    attacking_ (this),
    attackingLogit_ (this)
  {
  }

  TwoStageDeterrency::
  TwoStageDeterrency (const TwoStageDeterrency& x,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (x, f, c),
    entering_ (x.entering_, f, this),
    enteringLogit_ (x.enteringLogit_, f, this),
    attacking_ (x.attacking_, f, this),
    attackingLogit_ (x.attackingLogit_, f, this)
  {
  }

  TwoStageDeterrency::
  TwoStageDeterrency (const xercesc::DOMElement& e,
                      ::xml_schema::Flags f,
                      ::xml_schema::Container* c)
  : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
    entering_ (this),
    enteringLogit_ (this),
    attacking_ (this),
    attackingLogit_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
      this->parse (p, f);
    }
  }

  void TwoStageDeterrency::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    for (; p.more_content (); p.next_content (false))
    {
      const xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // entering
      //
      if (n.name () == "entering" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< EnteringType > r (
          EnteringTraits::create (i, f, this));

        if (!this->entering_)
        {
          this->entering_.set (::std::move (r));
          continue;
        }
      }

      // enteringLogit
      //
      if (n.name () == "enteringLogit" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< EnteringLogitType > r (
          EnteringLogitTraits::create (i, f, this));

        if (!this->enteringLogit_)
        {
          this->enteringLogit_.set (::std::move (r));
          continue;
        }
      }

      // attacking
      //
      if (n.name () == "attacking" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AttackingType > r (
          AttackingTraits::create (i, f, this));

        if (!this->attacking_)
        {
          this->attacking_.set (::std::move (r));
          continue;
        }
      }

      // attackingLogit
      //
      if (n.name () == "attackingLogit" && n.namespace_ ().empty ())
      {
        ::std::unique_ptr< AttackingLogitType > r (
          AttackingLogitTraits::create (i, f, this));

        if (!this->attackingLogit_)
        {
          this->attackingLogit_.set (::std::move (r));
          continue;
        }
      }

      break;
    }
  }

  TwoStageDeterrency* TwoStageDeterrency::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class TwoStageDeterrency (*this, f, c);
  }

  TwoStageDeterrency& TwoStageDeterrency::
  operator= (const TwoStageDeterrency& x)
  {
    if (this != &x)
    {
      static_cast< ::xml_schema::Type& > (*this) = x;
      this->entering_ = x.entering_;
      this->enteringLogit_ = x.enteringLogit_;
      this->attacking_ = x.attacking_;
      this->attackingLogit_ = x.attackingLogit_;
    }

    return *this;
  }

  TwoStageDeterrency::
  ~TwoStageDeterrency ()
  {
  }

  // Rate
  //

  Rate::
  Rate (const ValueType& value,
        const TimeType& time)
  : ::scnXml::DoubleValue (value),
    time_ (time, this)
  {
  }

  Rate::
  Rate (const Rate& x,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::scnXml::DoubleValue (x, f, c),
    time_ (x.time_, f, this)
  {
  }

  Rate::
  Rate (const xercesc::DOMElement& e,
        ::xml_schema::Flags f,
        ::xml_schema::Container* c)
  : ::scnXml::DoubleValue (e, f | ::xml_schema::Flags::base, c),
    time_ (this)
  {
    if ((f & ::xml_schema::Flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
      this->parse (p, f);
    }
  }

  void Rate::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::Flags f)
  {
    this->::scnXml::DoubleValue::parse (p, f);

    p.reset_attributes ();

    while (p.more_attributes ())
    {
      const xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "time" && n.namespace_ ().empty ())
      {
        this->time_.set (TimeTraits::create (i, f, this));
        continue;
      }
    }

    if (!time_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "time",
        "");
    }
  }

  Rate* Rate::
  _clone (::xml_schema::Flags f,
          ::xml_schema::Container* c) const
  {
    return new class Rate (*this, f, c);
  }

  Rate& Rate::
  operator= (const Rate& x)
  {
    if (this != &x)
    {
      static_cast< ::scnXml::DoubleValue& > (*this) = x;
      this->time_ = x.time_;
    }

    return *this;
  }

  Rate::
  ~Rate ()
  {
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace scnXml
{
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

